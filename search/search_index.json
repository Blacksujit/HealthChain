{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to HealthChain","text":"<p>HealthChain \ud83d\udcab\ud83c\udfe5 is an open-source Python framework designed to streamline the development, testing, and validation of AI, Natural Language Processing, and Machine Learning applications in a healthcare context.</p> <p>  Join our Discord  Quickstart Guide</p>"},{"location":"#what-are-the-main-features","title":"What are the main features?","text":"<ul> <li> <p> Build a pipeline</p> <p>Create custom pipelines or use pre-built ones for your healthcare NLP and ML tasks</p> <p> Pipeline</p> </li> <li> <p> Test in a sandbox</p> <p>Test your models in a full health-context aware environment from day 1</p> <p> Sandbox</p> </li> <li> <p> Generate synthetic data</p> <p>Use the data generator to create synthetic healthcare data for testing and development</p> <p> Data Generator</p> </li> <li> <p> Contribute</p> <p>If you have an idea or suggestions, we'd love to hear from you!</p> <p> Community</p> </li> </ul>"},{"location":"#why-healthchain","title":"Why HealthChain?","text":"<p>You've probably heard every AI will revolutionize healthcare pitch by now, but if you're one of the people who think: wait, can we go beyond just vibe-checking and actually build products that are reliable, reactive, and easy to scale in complex healthcare systems? Then HealthChain is probably for you.</p> <p>Specifically, HealthChain addresses two challenges:</p> <ol> <li> <p>Scaling Electronic Health Record system (EHRs) integrations of real-time AI, NLP, and ML applications is a manual and time-consuming process.</p> </li> <li> <p>Testing and evaluating unstructured data in complex, outcome focused systems is a challenging and labour-intensive task.</p> </li> </ol> <p>We believe more efficient end-to-end pipeline and integration testing at an early stage in development will give you back time to focus on what actually matters: developing safer, more effective and more explainable models that scale to real-world adoption. Building products for healthcare in a process that is human-centric.</p> <p>HealthChain is made by a (very) small team with experience in software engineering, machine learning, and healthcare NLP. We understand that good data science is about more than just building models, and that good engineering is about more than just building systems. This rings especially true in healthcare, where people, processes, and technology all play a role in making an impact.</p> <p>For inquiries and collaborations, please get in touch!</p>"},{"location":"distribution/","title":"Licence and citations","text":"<p>HealthChain is licensed under Apache 2.0. To comply with the licence you need to add the following notice at the top every file that uses part of HealthChain code:</p> <pre><code>Copyright 2024 - dotimplement\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>You can install HealthChain with <code>pip</code>:</p> <pre><code>pip install healthchain\n</code></pre> <p>Note you need to download any libraries that you require separetly:</p> <pre><code>pip install langchain\npip install transformers\npip install torch\n...\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>After installing HealthChain, get up to speed quickly with the core components before diving further into the full documentation!</p>"},{"location":"quickstart/#core-components","title":"Core Components","text":""},{"location":"quickstart/#pipeline","title":"Pipeline \ud83d\udee0\ufe0f","text":"<p>HealthChain Pipelines provide a flexible way to build and manage processing pipelines for NLP and ML tasks that can easily integrate with electronic health record (EHR) systems.</p> <p>You can build pipelines with three different approaches:</p>"},{"location":"quickstart/#1-build-your-own-pipeline-with-inline-functions","title":"1. Build Your Own Pipeline with Inline Functions","text":"<p>This is the most flexible approach, ideal for quick experiments and prototyping. Initialize a pipeline type hinted with the container type you want to process, then add components to your pipeline with the <code>@add_node</code> decorator.</p> <p>Compile the pipeline with <code>.build()</code> to use it.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io import Document\n\nnlp_pipeline = Pipeline[Document]()\n\n@nlp_pipeline.add_node\ndef tokenize(doc: Document) -&gt; Document:\n    doc.tokens = doc.text.split()\n    return doc\n\n@nlp_pipeline.add_node\ndef pos_tag(doc: Document) -&gt; Document:\n    doc.pos_tags = [\"NOUN\" if token[0].isupper() else \"VERB\" for token in doc.tokens]\n    return doc\n\nnlp = nlp_pipeline.build()\n\ndoc = Document(\"Patient has a fracture of the left femur.\")\ndoc = nlp(doc)\n\nprint(doc.tokens)\nprint(doc.pos_tags)\n\n# ['Patient', 'has', 'fracture', 'of', 'left', 'femur.']\n# ['NOUN', 'VERB', 'VERB', 'VERB', 'VERB', 'VERB']\n</code></pre>"},{"location":"quickstart/#2-build-your-own-pipeline-with-components-models-and-connectors","title":"2. Build Your Own Pipeline with Components, Models, and Connectors","text":"<p>Components are stateful - they're classes instead of functions. They can be useful for grouping related processing steps together, setting configurations, or wrapping specific model loading steps.</p> <p>HealthChain comes with a few pre-built components, but you can also easily add your own. You can find more details on the Components and Integrations documentation pages.</p> <p>Add components to your pipeline with the <code>.add_node()</code> method and compile with <code>.build()</code>.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import TextPreProcessor, SpacyNLP, TextPostProcessor\nfrom healthchain.io import Document\n\npipeline = Pipeline[Document]()\n\npipeline.add_node(TextPreProcessor())\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_sci_sm\"))\npipeline.add_node(TextPostProcessor())\n\npipe = pipeline.build()\n\ndoc = Document(\"Patient presents with hypertension.\")\noutput = pipe(doc)\n</code></pre> <p>Let's go one step further! You can use Connectors to work directly with CDA and FHIR data received from healthcare system APIs. Add Connectors to your pipeline with the <code>.add_input()</code> and <code>.add_output()</code> methods.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import SpacyNLP\nfrom healthchain.io import CdaConnector\nfrom healthchain.models import CdaRequest\n\npipeline = Pipeline()\ncda_connector = CdaConnector()\n\npipeline.add_input(cda_connector)\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_sci_sm\"))\npipeline.add_output(cda_connector)\n\npipe = pipeline.build()\n\ncda_data = CdaRequest(document=\"&lt;CDA XML content&gt;\")\noutput = pipe(cda_data)\n</code></pre>"},{"location":"quickstart/#3-use-prebuilt-pipelines","title":"3. Use Prebuilt Pipelines","text":"<p>Prebuilt pipelines are pre-configured collections of Components, Models, and Connectors. They are built for specific use cases, offering the highest level of abstraction. This is the easiest way to get started if you already know the use case you want to build for.</p> <p>For a full list of available prebuilt pipelines and details on how to configure and customize them, see the Pipelines documentation page.</p> <pre><code>from healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\n# Load from pre-built chain\nchain = ChatPromptTemplate.from_template(\"Summarize: {text}\") | ChatOpenAI()\npipeline = MedicalCodingPipeline.load(chain, source=\"langchain\")\n\n# Or load from model ID\npipeline = MedicalCodingPipeline.from_model_id(\"facebook/bart-large-cnn\", source=\"huggingface\")\n\n# Or load from local model\npipeline = MedicalCodingPipeline.from_local_model(\"./path/to/model\", source=\"spacy\")\n\ncda_data = CdaRequest(document=\"&lt;CDA XML content&gt;\")\noutput = pipeline(cda_data)\n</code></pre>"},{"location":"quickstart/#sandbox","title":"Sandbox \ud83e\uddea","text":"<p>Once you've built your pipeline, you might want to experiment with how it interacts with different healthcare systems. A sandbox helps you stage and test the end-to-end workflow of your pipeline application where real-time EHR integrations are involved.</p> <p>Running a sandbox will start a FastAPI server with pre-defined standardized endpoints and create a sandboxed environment for you to interact with your application.</p> <p>To create a sandbox, initialize a class that inherits from a type of UseCase and decorate it with the <code>@hc.sandbox</code> decorator.</p> <p>Every sandbox also requires a client function marked by <code>@hc.ehr</code> and a service function marked by <code>@hc.api</code>. A workflow must be specified when creating an EHR client.</p> <p>(Full Documentation on Sandbox and Use Cases)</p> <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDocumentation\nfrom healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest, CdaResponse\nfrom healthchain.fhir import create_document_reference\n\nfrom fhir.resources.documentreference import DocumentReference\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDocumentation):\n    def __init__(self) -&gt; None:\n        # Load your pipeline\n        self.pipeline = MedicalCodingPipeline.from_local_model(\n            \"./path/to/model\", source=\"spacy\"\n        )\n\n    @hc.ehr(workflow=\"sign-note-inpatient\")\n    def load_data_in_client(self) -&gt; DocumentReference:\n        # Load your data\n        with open('/path/to/data.xml', \"r\") as file:\n          xml_string = file.read()\n\n        cda_document_reference = create_document_reference(\n            data=xml_string,\n            content_type=\"text/xml\",\n            description=\"Original CDA Document loaded from my sandbox\",\n        )\n\n        return cda_document_reference\n\n    @hc.api\n    def my_service(self, request: CdaRequest) -&gt; CdaResponse:\n        # Run your pipeline\n        results = self.pipeline(request)\n        return results\n\nif __name__ == \"__main__\":\n    clindoc = MyCoolSandbox()\n    clindoc.start_sandbox()\n</code></pre>"},{"location":"quickstart/#deploy-sandbox-locally-with-fastapi","title":"Deploy sandbox locally with FastAPI \ud83d\ude80","text":"<p>To run your sandbox:</p> <pre><code>healthchain run my_sandbox.py\n</code></pre> <p>This will start a server by default at <code>http://127.0.0.1:8000</code>, and you can interact with the exposed endpoints at <code>/docs</code>. Data generated from your sandbox runs is saved at <code>./output/</code> by default.</p>"},{"location":"quickstart/#utilities","title":"Utilities \u2699\ufe0f","text":""},{"location":"quickstart/#data-generator","title":"Data Generator","text":"<p>You can use the data generator to generate synthetic data for your sandbox runs.</p> <p>The <code>.generate_prefetch()</code> method is dependent on use case and workflow. For example, <code>CdsDataGenerator</code> will generate synthetic FHIR data as Pydantic models suitable for the workflow specified by the use case.</p> <p>(Full Documentation on Data Generators)</p> Within clientOn its own <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.models import Prefetch\nfrom healthchain.data_generators import CdsDataGenerator\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDecisionSupport):\n    def __init__(self) -&gt; None:\n        self.data_generator = CdsDataGenerator()\n\n    @hc.ehr(workflow=\"patient-view\")\n    def load_data_in_client(self) -&gt; Prefetch:\n        data = self.data_generator.generate_prefetch()\n        return data\n\n    @hc.api\n    def my_server(self, request) -&gt; None:\n        pass\n</code></pre> <pre><code>from healthchain.data_generators import CdsDataGenerator\nfrom healthchain.workflows import Workflow\n\n# Initialize data generator\ndata_generator = CdsDataGenerator()\n\n# Generate FHIR resources for use case workflow\ndata_generator.set_workflow(Workflow.encounter_discharge)\ndata = data_generator.generate_prefetch()\n\nprint(data.model_dump())\n\n# {\n#    \"prefetch\": {\n#        \"encounter\":\n#            {\n#              \"resourceType\": ...\n#            }\n#    }\n#}\n</code></pre>"},{"location":"quickstart/#going-further","title":"Going further \u2728","text":"<p>Check out our Cookbook section for more worked examples! HealthChain is still in its early stages, so if you have any questions please feel free to reach us on Github or Discord.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/cda_parser/","title":"CDA Parser","text":""},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator","title":"<code>CdaAnnotator</code>","text":"<p>Annotates a Clinical Document Architecture (CDA) document. Limited to problems, medications, allergies, and notes sections for now.</p> PARAMETER DESCRIPTION <code>cda_data</code> <p>The CDA document data.</p> <p> TYPE: <code>ClinicalDocument</code> </p> ATTRIBUTE DESCRIPTION <code>clinical_document</code> <p>The CDA document data.</p> <p> TYPE: <code>ClinicalDocument</code> </p> <code>fallback</code> <p>The fallback value.</p> <p> TYPE: <code>str</code> </p> <code>problem_list</code> <p>The list of problems extracted from the CDA document.</p> <p> TYPE: <code>List[Condition]</code> </p> <code>medication_list</code> <p>The list of medications extracted from the CDA document.</p> <p> TYPE: <code>List[MedicationStatement]</code> </p> <code>allergy_list</code> <p>The list of allergies extracted from the CDA document.</p> <p> TYPE: <code>List[AllergyIntolerance]</code> </p> <code>note</code> <p>The note extracted from the CDA document.</p> <p> TYPE: <code>str</code> </p> METHOD DESCRIPTION <code>from_dict</code> <p>Dict): Creates a CdaAnnotator instance from a dictionary.</p> <code>from_xml</code> <p>str): Creates a CdaAnnotator instance from an XML string.</p> <code>add_to_problem_list</code> <p>List[Condition], overwrite: bool = False) -&gt; None: Adds a list of Condition resources to the problems section.</p> <code>export</code> <p>bool = True) -&gt; str: Exports the CDA document as an XML string.</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>class CdaAnnotator:\n    \"\"\"\n    Annotates a Clinical Document Architecture (CDA) document.\n    Limited to problems, medications, allergies, and notes sections for now.\n\n    Args:\n        cda_data (ClinicalDocument): The CDA document data.\n\n    Attributes:\n        clinical_document (ClinicalDocument): The CDA document data.\n        fallback (str): The fallback value.\n        problem_list (List[Condition]): The list of problems extracted from the CDA document.\n        medication_list (List[MedicationStatement]): The list of medications extracted from the CDA document.\n        allergy_list (List[AllergyIntolerance]): The list of allergies extracted from the CDA document.\n        note (str): The note extracted from the CDA document.\n\n    Methods:\n        from_dict(cls, data: Dict): Creates a CdaAnnotator instance from a dictionary.\n        from_xml(cls, data: str): Creates a CdaAnnotator instance from an XML string.\n        add_to_problem_list(problems: List[Condition], overwrite: bool = False) -&gt; None: Adds a list of Condition resources to the problems section.\n        export(pretty_print: bool = True) -&gt; str: Exports the CDA document as an XML string.\n    \"\"\"\n\n    def __init__(self, cda_data: ClinicalDocument) -&gt; None:\n        self.clinical_document = cda_data\n        self.code_mapping = CodeMapping()\n        self._get_ccd_sections()\n        self._extract_data()\n\n    @classmethod\n    def from_dict(cls, data: Dict) -&gt; \"CdaAnnotator\":\n        \"\"\"\n        Creates an instance of the class from a dictionary.\n\n        Args:\n            data (Dict): The dictionary containing the dictionary representation of the cda xml (using xmltodict.parse).\n\n        Returns:\n            CdaAnnotator: An instance of the class initialized with the data from the dictionary.\n        \"\"\"\n        clinical_document_model = ClinicalDocument(**data.get(\"ClinicalDocument\", {}))\n        return cls(cda_data=clinical_document_model)\n\n    @classmethod\n    def from_xml(cls, data: str) -&gt; \"CdaAnnotator\":\n        \"\"\"\n        Creates an instance of the CDAAnnotator class from an XML string.\n\n        Args:\n            data (str): The XML string representing the CDA document.\n\n        Returns:\n            CDAAnnotator: An instance of the CDAAnnotator class initialized with the parsed CDA data.\n        \"\"\"\n        cda_dict = xmltodict.parse(data)\n        clinical_document_model = ClinicalDocument(\n            **cda_dict.get(\"ClinicalDocument\", {})\n        )\n        return cls(cda_data=clinical_document_model)\n\n    def __str__(self):\n        problems = \"\"\n        allergies = \"\"\n        medications = \"\"\n\n        if self.problem_list:\n            problems = \"\\n\".join(\n                [problem.model_dump_json() for problem in self.problem_list]\n            )\n        if self.allergy_list:\n            allergies = \"\\n\".join(\n                [allergy.model_dump_json() for allergy in self.allergy_list]\n            )\n        if self.medication_list:\n            medications = \"\\n\".join(\n                [medication.model_dump_json() for medication in self.medication_list]\n            )\n\n        return problems + allergies + medications\n\n    def _get_ccd_sections(self) -&gt; None:\n        \"\"\"\n        Retrieves the different sections of the CCD document.\n\n        This method finds and assigns the problem section, medication section,\n        allergy section, and note section of the CCD document.\n\n        Returns:\n            None\n        \"\"\"\n        self._problem_section = self._find_problems_section()\n        self._medication_section = self._find_medications_section()\n        self._allergy_section = self._find_allergies_section()\n        self._note_section = self._find_notes_section()\n\n    def _extract_data(self) -&gt; None:\n        \"\"\"\n        Extracts data from the CDA document and assigns it to instance variables.\n\n        This method extracts problem list, medication list, allergy list, and note from the CDA document\n        and assigns them to the corresponding instance variables.\n\n        Returns:\n            None\n        \"\"\"\n        self.problem_list: List[Condition] = self._extract_problems()\n        self.medication_list: List[MedicationStatement] = self._extract_medications()\n        self.allergy_list: List[AllergyIntolerance] = self._extract_allergies()\n        self.note: str = self._extract_note()\n\n    def _find_section_by_code(self, section_code: str) -&gt; Optional[Section]:\n        \"\"\"\n        Finds a section in the clinical document by its code value.\n\n        Args:\n            section_code (str): The code of the section to find.\n\n        Returns:\n            Optional[Section]: The section with the specified code, or None if not found.\n        \"\"\"\n        components = self.clinical_document.component.structuredBody.component\n\n        if not isinstance(components, list):\n            components = [components]\n\n        for component in components:\n            code = component.section.code.code\n\n            if code is None:\n                continue\n            if code == section_code:\n                return component.section\n        log.warning(f\"unable to find section with code {section_code}\")\n        return None\n\n    def _find_section_by_template_id(self, section_id: str) -&gt; Optional[Section]:\n        \"\"\"\n        Finds a section in the clinical document by its template ID.\n\n        Args:\n            section_id (str): The template ID of the section to find.\n\n        Returns:\n            Optional[Section]: The section with the specified template ID, or None if not found.\n        \"\"\"\n        # NOTE not all CDAs have template ids in each section (don't ask me why)\n        # TODO: It's probably safer to parse by 'code' which is a required field\n        components = self.clinical_document.component.structuredBody.component\n        # Ensure components is a list\n        if not isinstance(components, list):\n            components = [components]\n\n        for component in components:\n            template_ids = component.section.templateId\n            if template_ids is None:\n                continue\n\n            if isinstance(template_ids, list):\n                for template_id in template_ids:\n                    if template_id.root == section_id:\n                        return component.section\n            elif template_ids.root == section_id:\n                return component.section\n\n        log.warning(f\"Unable to find section templateId {section_id}\")\n\n        return None\n\n    def _find_problems_section(self) -&gt; Optional[Section]:\n        return self._find_section_by_template_id(\n            SectionId.PROBLEM.value\n        ) or self._find_section_by_code(SectionCode.PROBLEM.value)\n\n    def _find_medications_section(self) -&gt; Optional[Section]:\n        return self._find_section_by_template_id(\n            SectionId.MEDICATION.value\n        ) or self._find_section_by_code(SectionCode.MEDICATION.value)\n\n    def _find_allergies_section(self) -&gt; Optional[Section]:\n        return self._find_section_by_template_id(\n            SectionId.ALLERGY.value\n        ) or self._find_section_by_code(SectionCode.ALLERGY.value)\n\n    def _find_notes_section(self) -&gt; Optional[Section]:\n        return self._find_section_by_template_id(\n            SectionId.NOTE.value\n        ) or self._find_section_by_code(SectionCode.NOTE.value)\n\n    def _extract_problems(self) -&gt; List[Condition]:\n        \"\"\"\n        Extracts problems from the CDA document's problem section and converts them to FHIR Condition resources.\n\n        The method processes each problem entry in the CDA document and:\n        - Maps CDA status codes to FHIR clinical status\n        - Extracts onset and abatement dates\n        - Creates FHIR Condition resources with appropriate coding\n        - Sets problem list item category\n        - Handles both single entries and lists of entries\n\n        Returns:\n            List[Condition]: A list of FHIR Condition resources representing the extracted problems.\n                           Returns empty list if problem section is not found.\n        \"\"\"\n        if not self._problem_section:\n            log.warning(\"Empty problem section!\")\n            return []\n\n        conditions = []\n\n        def create_fhir_condition_from_cda(value: Dict, entry) -&gt; Condition:\n            # Map CDA status to FHIR clinical status\n            status = \"unknown\"\n            if hasattr(entry, \"act\") and hasattr(entry.act, \"statusCode\"):\n                status_code = entry.act.statusCode.code\n                status = self.code_mapping.cda_to_fhir(\n                    status_code, \"status\", case_sensitive=False, default=\"unknown\"\n                )\n\n            # Extract dates from entry\n            onset_date = None\n            abatement_date = None\n            if hasattr(entry, \"act\") and hasattr(entry.act, \"effectiveTime\"):\n                effective_time = entry.act.effectiveTime\n                if hasattr(effective_time, \"low\") and effective_time.low:\n                    onset_date = CodeMapping.convert_date_cda_to_fhir(\n                        effective_time.low.value\n                    )\n\n                if hasattr(effective_time, \"high\") and effective_time.high:\n                    abatement_date = CodeMapping.convert_date_cda_to_fhir(\n                        effective_time.high.value\n                    )\n\n            # Create condition using helper function\n            condition = create_condition(\n                subject=\"Patient/123\",  # TODO: add patient reference {self.clinical_document.recordTarget.patientRole.id}\n                clinical_status=status,\n                code=value.get(\"@code\"),\n                display=value.get(\"@displayName\"),\n                system=self.code_mapping.cda_to_fhir(\n                    value.get(\"@codeSystem\"), \"system\"\n                ),\n            )\n\n            # Add dates if present\n            if onset_date:\n                condition.onsetDateTime = onset_date\n            if abatement_date:\n                condition.abatementDateTime = abatement_date\n\n            # Set category (problem-list-item by default for problems section)\n            set_problem_list_item_category(condition)\n\n            return condition\n\n        entries = (\n            self._problem_section.entry\n            if isinstance(self._problem_section.entry, list)\n            else [self._problem_section.entry]\n        )\n\n        for entry in entries:\n            entry_relationship = entry.act.entryRelationship\n            values = get_value_from_entry_relationship(entry_relationship)\n            for value in values:\n                condition = create_fhir_condition_from_cda(value, entry)\n                conditions.append(condition)\n\n        return conditions\n\n    def _extract_medications(self) -&gt; List[MedicationStatement]:\n        \"\"\"\n        Extracts medication concepts from the medication section of the CDA document.\n\n        Returns:\n            A list of MedicationStatement resources representing the extracted medication concepts.\n        \"\"\"\n        if not self._medication_section:\n            log.warning(\"Empty medication section!\")\n            return []\n\n        medications = []\n\n        def create_medication_statement_from_cda(\n            code: CD,\n            dose_quantity: Optional[IVL_PQ],\n            route_code: Optional[CE],\n            effective_times: Optional[Union[List[Dict], Dict]],\n        ) -&gt; MedicationStatement:\n            # Map CDA system to FHIR system\n            fhir_system = self.code_mapping.cda_to_fhir(\n                code.codeSystem, \"system\", default=\"http://snomed.info/sct\"\n            )\n\n            # Create base medication statement using helper\n            medication = create_medication_statement(\n                subject=\"Patient/123\",  # TODO: extract patient reference\n                status=\"recorded\",  # TODO: extract status\n                code=code.code,\n                display=code.displayName,\n                system=fhir_system,\n            )\n\n            # Add dosage if present\n            if dose_quantity:\n                medication.dosage = [\n                    {\n                        \"doseAndRate\": [\n                            {\n                                \"doseQuantity\": {\n                                    \"value\": dose_quantity.value,\n                                    \"unit\": dose_quantity.unit,\n                                }\n                            }\n                        ]\n                    }\n                ]\n\n            # Add route if present\n            if route_code:\n                route_system = self.code_mapping.cda_to_fhir(\n                    route_code.codeSystem, \"system\", default=\"http://snomed.info/sct\"\n                )\n                medication.dosage = medication.dosage or [Dosage()]\n                medication.dosage[0].route = create_single_codeable_concept(\n                    code=route_code.code,\n                    display=route_code.displayName,\n                    system=route_system,\n                )\n\n            # Add timing if present\n            if effective_times:\n                effective_times = (\n                    effective_times\n                    if isinstance(effective_times, list)\n                    else [effective_times]\n                )\n                # TODO: could refactor this into a pydantic validator\n                for effective_time in effective_times:\n                    if effective_time.get(\"@xsi:type\") == \"IVL_TS\":\n                        # Handle duration\n                        low_value = effective_time.get(\"low\", {}).get(\"@value\")\n                        high_value = effective_time.get(\"high\", {}).get(\"@value\")\n\n                        if low_value or high_value:\n                            medication.effectivePeriod = {}\n                            if low_value:\n                                medication.effectivePeriod.start = (\n                                    CodeMapping.convert_date_cda_to_fhir(low_value)\n                                )\n                            if high_value:\n                                medication.effectivePeriod.end = (\n                                    CodeMapping.convert_date_cda_to_fhir(high_value)\n                                )\n\n                    elif effective_time.get(\"@xsi:type\") == \"PIVL_TS\":\n                        # Handle frequency\n                        period = effective_time.get(\"period\")\n                        if period:\n                            medication.dosage = medication.dosage or [Dosage()]\n                            medication.dosage[0].timing = {\n                                \"repeat\": {\n                                    \"period\": float(period.get(\"@value\")),\n                                    \"periodUnit\": period.get(\"@unit\"),\n                                }\n                            }\n\n            return medication\n\n        entries = (\n            self._medication_section.entry\n            if isinstance(self._medication_section.entry, list)\n            else [self._medication_section.entry]\n        )\n\n        for entry in entries:\n            substance_administration = entry.substanceAdministration\n            if not substance_administration:\n                log.warning(\"Substance administration not found in entry.\")\n                continue\n\n            # Get medication details\n            consumable = substance_administration.consumable\n            manufactured_product = (\n                consumable.manufacturedProduct if consumable else None\n            )\n            manufactured_material = (\n                manufactured_product.manufacturedMaterial\n                if manufactured_product\n                else None\n            )\n            code = manufactured_material.code if manufactured_material else None\n\n            if not code:\n                log.warning(\"Code not found in the consumable\")\n                continue\n\n            # Create FHIR medication statement\n            medication = create_medication_statement_from_cda(\n                code=code,\n                dose_quantity=substance_administration.doseQuantity,\n                route_code=substance_administration.routeCode,\n                effective_times=substance_administration.effectiveTime,\n            )\n            medications.append(medication)\n\n        return medications\n\n    def _extract_allergies(self) -&gt; List[AllergyIntolerance]:\n        \"\"\"\n        Extracts allergy concepts from the allergy section of the CDA document.\n\n        Returns:\n            List[AllergyIntolerance]: A list of FHIR AllergyIntolerance resources.\n        \"\"\"\n        if not self._allergy_section:\n            log.warning(\"Empty allergy section!\")\n            return []\n\n        allergies = []\n\n        def get_allergy_details_from_entry_relationship(\n            entry_relationship: EntryRelationship,\n        ) -&gt; Tuple[str, CD, Dict, Dict]:\n            allergen_name = None\n            allergy_type = None\n            reaction = None\n            severity = None\n\n            # TODO: Improve this\n\n            entry_relationships = (\n                entry_relationship\n                if isinstance(entry_relationship, list)\n                else [entry_relationship]\n            )\n            for entry_relationship in entry_relationships:\n                if check_for_entry_observation(entry_relationship):\n                    allergy_type = entry_relationship.observation.code\n                    observation = entry_relationship.observation\n                    allergen_name = (\n                        observation.participant.participantRole.playingEntity.name\n                    )\n\n                    if check_for_entry_observation(observation):\n                        observation_entry_relationships = (\n                            observation.entryRelationship\n                            if isinstance(observation.entryRelationship, list)\n                            else [observation.entryRelationship]\n                        )\n                        for observation_entry_rel in observation_entry_relationships:\n                            if check_has_template_id(\n                                observation_entry_rel.observation,\n                                \"1.3.6.1.4.1.19376.1.5.3.1.4.5\",\n                            ):\n                                reaction = observation_entry_rel.observation.value\n\n                        if check_for_entry_observation(\n                            observation_entry_rel.observation\n                        ):\n                            if check_has_template_id(\n                                observation_entry_rel.observation.entryRelationship.observation,\n                                \"1.3.6.1.4.1.19376.1.5.3.1.4.1\",\n                            ):\n                                severity = observation_entry_rel.observation.entryRelationship.observation.value\n\n            return allergen_name, allergy_type, reaction, severity\n\n        entries = (\n            self._allergy_section.entry\n            if isinstance(self._allergy_section.entry, list)\n            else [self._allergy_section.entry]\n        )\n\n        for entry in entries:\n            entry_relationship = entry.act.entryRelationship\n            values = get_value_from_entry_relationship(entry_relationship)\n\n            allergen_name, allergy_type, reaction, severity = (\n                get_allergy_details_from_entry_relationship(entry_relationship)\n            )\n\n            for value in values:\n                # Map CDA system to FHIR system\n                allergy_code_system = self.code_mapping.cda_to_fhir(\n                    value.get(\"@codeSystem\", \"\"),\n                    \"system\",\n                    default=\"http://snomed.info/sct\",\n                )\n                allergy = create_allergy_intolerance(\n                    patient=\"Patient/123\",  # TODO: Get from patient context\n                    code=value.get(\"@code\"),\n                    display=value.get(\"@displayName\"),\n                    system=allergy_code_system,\n                )\n                if allergy.code and allergy.code.coding[0].display is None:\n                    allergy.code.coding[0].display = allergen_name\n\n                if allergy_type:\n                    allergy_type_system = self.code_mapping.cda_to_fhir(\n                        allergy_type.codeSystem,\n                        \"system\",\n                        default=\"http://snomed.info/sct\",\n                    )\n                    allergy.type = create_single_codeable_concept(\n                        code=allergy_type.code,\n                        display=allergy_type.displayName,\n                        system=allergy_type_system,\n                    )\n\n                if reaction:\n                    reaction_system = self.code_mapping.cda_to_fhir(\n                        reaction.get(\"@codeSystem\"),\n                        \"system\",\n                        default=\"http://snomed.info/sct\",\n                    )\n                    allergy.reaction = create_single_reaction(\n                        code=reaction.get(\"@code\"),\n                        display=reaction.get(\"@displayName\"),\n                        system=reaction_system,\n                    )\n\n                if severity:\n                    severity_code = self.code_mapping.cda_to_fhir(\n                        severity.get(\"@code\"),\n                        \"severity\",\n                        default=\"http://snomed.info/sct\",\n                    )\n                    if allergy.reaction:\n                        allergy.reaction[0].severity = severity_code\n                allergies.append(allergy)\n\n        return allergies\n\n    def _extract_note(self) -&gt; str:\n        \"\"\"\n        Extracts the note section from the CDA document.\n\n        Returns:\n            str: The extracted note section as a string.\n        \"\"\"\n        # TODO: need to handle / escape html tags within the note section, parse with right field\n        if not self._note_section:\n            log.warning(\"Empty notes section!\")\n            return []\n\n        return self._note_section.text\n\n    def _add_new_problem_entry(\n        self,\n        new_problem: Condition,\n        timestamp: str,\n        act_id: str,\n        problem_reference_name: str,\n    ) -&gt; None:\n        \"\"\"\n        Adds a new problem entry to the problem section of the CDA document.\n\n        Args:\n            new_problem (Condition): The new problem concept to be added.\n            timestamp (str): The timestamp of the entry.\n            act_id (str): The ID of the act.\n            problem_reference_name (str): The reference name of the problem.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Get CDA status from FHIR clinical status\n        fhir_status = new_problem.clinicalStatus.coding[0].code\n        cda_status = self.code_mapping.fhir_to_cda(\n            fhir_status, \"status\", case_sensitive=False, default=\"unknown\"\n        )\n\n        # Get CDA system from FHIR system\n        if not new_problem.code:\n            log.warning(\"No code found for problem\")\n            return\n\n        fhir_system = new_problem.code.coding[0].system\n        cda_system = self.code_mapping.fhir_to_cda(\n            fhir_system, \"system\", default=\"2.16.840.1.113883.6.96\"\n        )  # Default to SNOMED-CT\n\n        template = {\n            \"act\": {\n                \"@classCode\": \"ACT\",\n                \"@moodCode\": \"EVN\",\n                \"templateId\": [\n                    {\"@root\": \"2.16.840.1.113883.10.20.1.27\"},\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5.1\"},\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5.2\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.32.7\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.83.7\"},\n                ],\n                \"id\": {\"@root\": act_id},\n                \"code\": {\"@nullflavor\": \"NA\"},\n                \"statusCode\": {\"@code\": cda_status},\n                \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                \"entryRelationship\": {\n                    \"@typeCode\": \"SUBJ\",\n                    \"@inversionInd\": False,\n                    \"observation\": {\n                        \"@classCode\": \"OBS\",\n                        \"@moodCode\": \"EVN\",\n                        \"templateId\": [\n                            {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5\"},\n                            {\"@root\": \"2.16.840.1.113883.10.20.1.28\"},\n                        ],\n                        \"id\": {\"@root\": act_id},\n                        \"code\": {\n                            \"@code\": \"55607006\",\n                            \"@codeSystem\": \"2.16.840.1.113883.6.96\",\n                            \"@codeSystemName\": \"SNOMED CT\",\n                            \"@displayName\": \"Problem\",\n                        },\n                        \"text\": {\"reference\": {\"@value\": problem_reference_name}},\n                        \"value\": {\n                            \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                            \"@code\": new_problem.code.coding[0].code,\n                            \"@codeSystem\": cda_system,\n                            \"@displayName\": new_problem.code.coding[0].display,\n                            \"originalText\": {\n                                \"reference\": {\"@value\": problem_reference_name}\n                            },\n                            \"@xsi:type\": \"CD\",\n                        },\n                        \"statusCode\": {\"@code\": \"completed\"},\n                        \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                        \"entryRelationship\": {\n                            \"@typeCode\": \"REFR\",\n                            \"observation\": {\n                                \"@classCode\": \"OBS\",\n                                \"@moodCode\": \"EVN\",\n                                \"code\": {\n                                    \"@code\": \"33999-4\",\n                                    \"@codeSystem\": \"2.16.840.1.113883.6.1\",\n                                    \"@displayName\": \"Status\",\n                                },\n                                \"value\": {\n                                    \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                                    \"@code\": \"55561003\",\n                                    \"@codeSystem\": \"2.16.840.1.113883.6.96\",\n                                    \"@displayName\": \"Active\",\n                                    \"@xsi:type\": \"CE\",\n                                },\n                                \"statusCode\": {\"@code\": \"completed\"},\n                                \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                            },\n                        },\n                    },\n                },\n            }\n        }\n        if not isinstance(self._problem_section.entry, list):\n            self._problem_section.entry = [self._problem_section.entry]\n\n        new_entry = Entry(**template)\n        self._problem_section.entry.append(new_entry)\n\n    def add_to_problem_list(\n        self, problems: List[Condition], overwrite: bool = False\n    ) -&gt; None:\n        \"\"\"\n        Adds a list of problem lists to the problems section.\n\n        Args:\n            problems (List[Condition]): A list of Condition resources to be added.\n            overwrite (bool, optional): If True, the existing problem list will be overwritten.\n                Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        if self._problem_section is None:\n            log.warning(\n                \"Skipping: No problem section to add to, check your CDA configuration\"\n            )\n            return\n\n        timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n        act_id = str(uuid.uuid4())\n        problem_reference_name = \"#p\" + str(uuid.uuid4())[:8] + \"name\"\n\n        if overwrite:\n            self._problem_section.entry = []\n\n        added_problems = []\n\n        for problem in problems:\n            if problem in self.problem_list:\n                log.debug(\n                    f\"Skipping: Problem {problem.model_dump()} already exists in the problem list.\"\n                )\n                continue\n            log.debug(f\"Adding problem: {problem}\")\n            self._add_new_problem_entry(\n                new_problem=problem,\n                timestamp=timestamp,\n                act_id=act_id,\n                problem_reference_name=problem_reference_name,\n            )\n            added_problems.append(problem)\n\n        if overwrite:\n            self.problem_list = added_problems\n        else:\n            self.problem_list.extend(added_problems)\n\n    def _add_new_medication_entry(\n        self,\n        new_medication: MedicationStatement,\n        timestamp: str,\n        subad_id: str,\n        medication_reference_name: str,\n    ) -&gt; None:\n        \"\"\"\n        Adds a new medication entry to the medication section of the CDA document.\n\n        Args:\n            new_medication (MedicationStatement): The FHIR MedicationStatement resource to add to the CDA\n            timestamp (str): The timestamp for when this entry was created, in YYYYMMDD format\n            subad_id (str): The unique ID for this substance administration entry\n            medication_reference_name (str): The reference name used to link narrative text to this medication\n\n        The method creates a CDA substance administration entry with:\n        - Medication details (code, name, etc)\n        - Dosage information if present (amount, route, frequency)\n        - Effective time periods\n        - Status as Active\n        \"\"\"\n\n        if not new_medication.medication.concept:\n            log.warning(\"No medication concept found for medication\")\n            return\n\n        # Get CDA system from FHIR system\n        fhir_system = new_medication.medication.concept.coding[0].system\n        cda_system = self.code_mapping.fhir_to_cda(\n            fhir_system, \"system\", default=\"2.16.840.1.113883.6.96\"\n        )\n\n        effective_times = []\n\n        # Handle timing/frequency\n        if new_medication.dosage and new_medication.dosage[0].timing:\n            timing = new_medication.dosage[0].timing.repeat\n            effective_times.append(\n                {\n                    \"@xsi:type\": \"PIVL_TS\",\n                    \"@institutionSpecified\": True,\n                    \"@operator\": \"A\",\n                    \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                    \"period\": {\n                        \"@unit\": timing.periodUnit,\n                        \"@value\": str(timing.period),\n                    },\n                }\n            )\n\n        # Handle effective period\n        # TODO: standardize datetime format\n        if new_medication.effectivePeriod:\n            time_range = {\n                \"@xsi:type\": \"IVL_TS\",\n                \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                \"low\": {\"@nullFlavor\": \"UNK\"},\n                \"high\": {\"@nullFlavor\": \"UNK\"},\n            }\n            if new_medication.effectivePeriod.start:\n                time_range[\"low\"] = {\n                    \"@value\": CodeMapping.convert_date_fhir_to_cda(\n                        new_medication.effectivePeriod.start\n                    )\n                }\n            if new_medication.effectivePeriod.end:\n                time_range[\"high\"] = {\n                    \"@value\": CodeMapping.convert_date_fhir_to_cda(\n                        new_medication.effectivePeriod.end\n                    )\n                }\n            effective_times.append(time_range)\n\n        template = {\n            \"substanceAdministration\": {\n                \"@classCode\": \"SBADM\",\n                \"@moodCode\": \"INT\",\n                \"templateId\": [\n                    {\"@root\": \"2.16.840.1.113883.10.20.1.24\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.83.8\"},\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.7\"},\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.7.1\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.32.8\"},\n                ],\n                \"id\": {\"@root\": subad_id},\n                \"statusCode\": {\"@code\": \"completed\"},\n            }\n        }\n\n        # Add dosage if present\n        if new_medication.dosage and new_medication.dosage[0].doseAndRate:\n            dose = new_medication.dosage[0].doseAndRate[0].doseQuantity\n            template[\"substanceAdministration\"][\"doseQuantity\"] = {\n                \"@value\": dose.value,\n                \"@unit\": dose.unit,\n            }\n\n        # Add route if present\n        if new_medication.dosage and new_medication.dosage[0].route:\n            route = new_medication.dosage[0].route.coding[0]\n            route_system = self.code_mapping.fhir_to_cda(route.system, \"system\")\n            template[\"substanceAdministration\"][\"routeCode\"] = {\n                \"@code\": route.code,\n                \"@codeSystem\": route_system,\n                \"@displayName\": route.display,\n            }\n\n        # Add timing\n        if effective_times:\n            template[\"substanceAdministration\"][\"effectiveTime\"] = effective_times\n\n        # Add medication details\n        template[\"substanceAdministration\"][\"consumable\"] = {\n            \"@typeCode\": \"CSM\",\n            \"manufacturedProduct\": {\n                \"@classCode\": \"MANU\",\n                \"templateId\": [\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.7.2\"},\n                    {\"@root\": \"2.16.840.1.113883.10.20.1.53\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.32.9\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.83.8.2\"},\n                ],\n                \"manufacturedMaterial\": {\n                    \"code\": {\n                        \"@code\": new_medication.medication.concept.coding[0].code,\n                        \"@codeSystem\": cda_system,\n                        \"@displayName\": new_medication.medication.concept.coding[\n                            0\n                        ].display,\n                        \"originalText\": {\n                            \"reference\": {\"@value\": medication_reference_name}\n                        },\n                    }\n                },\n            },\n        }\n\n        # Add an Active status\n        template[\"substanceAdministration\"][\"entryRelationship\"] = (\n            {\n                \"@typeCode\": \"REFR\",\n                \"observation\": {\n                    \"@classCode\": \"OBS\",\n                    \"@moodCode\": \"EVN\",\n                    \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                    \"templateId\": {\"@root\": \"2.16.840.1.113883.10.20.1.47\"},\n                    \"code\": {\n                        \"@code\": \"33999-4\",\n                        \"@codeSystem\": \"2.16.840.1.113883.6.1\",\n                        \"@codeSystemName\": \"LOINC\",\n                        \"@displayName\": \"Status\",\n                    },\n                    \"value\": {\n                        \"@code\": \"755561003\",\n                        \"@codeSystem\": \"2.16.840.1.113883.6.96\",\n                        \"@codeSystemName\": \"SNOMED CT\",\n                        \"@xsi:type\": \"CE\",\n                        \"@displayName\": \"Active\",\n                        \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                    },\n                    \"statusCode\": {\"@code\": \"completed\"},\n                },\n            },\n        )\n\n        if not isinstance(self._medication_section.entry, list):\n            self._medication_section.entry = [self._medication_section.entry]\n\n        new_entry = Entry(**template)\n        self._medication_section.entry.append(new_entry)\n\n    def add_to_medication_list(\n        self, medications: List[MedicationStatement], overwrite: bool = False\n    ) -&gt; None:\n        \"\"\"\n        Adds medications to the medication list.\n\n        Args:\n            medications (List[MedicationStatement]): A list of MedicationStatement resources to be added\n            overwrite (bool, optional): If True, existing medication list will be overwritten. Defaults to False.\n        \"\"\"\n        if self._medication_section is None:\n            log.warning(\n                \"Skipping: No medication section to add to, check your CDA configuration\"\n            )\n            return\n\n        timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n        subad_id = str(uuid.uuid4())\n        medication_reference_name = \"#m\" + str(uuid.uuid4())[:8] + \"name\"\n\n        if overwrite:\n            self._medication_section.entry = []\n\n        added_medications = []\n\n        for medication in medications:\n            if medication in self.medication_list:\n                log.debug(\n                    f\"Skipping: medication {medication.model_dump()} already exists in the medication list.\"\n                )\n                continue\n\n            log.debug(f\"Adding medication: {medication}\")\n            self._add_new_medication_entry(\n                new_medication=medication,\n                timestamp=timestamp,\n                subad_id=subad_id,\n                medication_reference_name=medication_reference_name,\n            )\n            added_medications.append(medication)\n\n        if overwrite:\n            self.medication_list = added_medications\n        else:\n            self.medication_list.extend(added_medications)\n\n    def _add_new_allergy_entry(\n        self,\n        new_allergy: AllergyIntolerance,\n        timestamp: str,\n        act_id: str,\n        allergy_reference_name: str,\n    ) -&gt; None:\n        \"\"\"\n        Adds a new allergy entry to the allergy section of the CDA document.\n\n        Args:\n            new_allergy (AllergyIntolerance): The new allergy concept to be added.\n            timestamp (str): The timestamp of the entry.\n            act_id (str): The ID of the act.\n            allergy_reference_name (str): The reference name of the allergy.\n\n        Returns:\n            None\n        \"\"\"\n        if not new_allergy.code:\n            log.warning(\"No code found for allergy\")\n            return\n\n        template = {\n            \"act\": {\n                \"@classCode\": \"ACT\",\n                \"@moodCode\": \"EVN\",\n                \"templateId\": [\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5.1\"},\n                    {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5.3\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.32.6\"},\n                    {\"@root\": \"2.16.840.1.113883.3.88.11.83.6\"},\n                ],\n                \"id\": {\"@root\": act_id},\n                \"code\": {\"@nullFlavor\": \"NA\"},\n                \"statusCode\": {\"@code\": \"active\"},\n                \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                \"entryRelationship\": {\n                    \"@typeCode\": \"SUBJ\",\n                    \"@inversionInd\": False,\n                    \"observation\": {\n                        \"@classCode\": \"OBS\",\n                        \"@moodCode\": \"EVN\",\n                        \"templateId\": [\n                            {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5\"},\n                            {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.6\"},\n                            {\"@root\": \"2.16.840.1.113883.10.20.1.18\"},\n                            {\n                                \"@root\": \"1.3.6.1.4.1.19376.1.5.3.1\",\n                                \"@extension\": \"allergy\",\n                            },\n                            {\"@root\": \"2.16.840.1.113883.10.20.1.28\"},\n                        ],\n                        \"id\": {\"@root\": act_id},\n                        \"text\": {\"reference\": {\"@value\": allergy_reference_name}},\n                        \"statusCode\": {\"@code\": \"completed\"},\n                        \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                    },\n                },\n            }\n        }\n        allergen_observation = template[\"act\"][\"entryRelationship\"][\"observation\"]\n\n        # Attach allergy type code\n        if new_allergy.type:\n            allergy_type_system = self.code_mapping.fhir_to_cda(\n                new_allergy.type.coding[0].system,\n                \"system\",\n                default=\"2.16.840.1.113883.6.96\",\n            )\n            allergen_observation[\"code\"] = {\n                \"@code\": new_allergy.type.coding[0].code,\n                \"@codeSystem\": allergy_type_system,\n                # \"@codeSystemName\": new_allergy.type.coding[0].display,\n                \"@displayName\": new_allergy.type.coding[0].display,\n            }\n        else:\n            log.warning(\"Allergy type code is missing, using default.\")\n            allergen_observation[\"code\"] = {\n                \"@code\": \"420134006\",\n                \"@codeSystem\": \"2.16.840.1.113883.6.96\",\n                \"@displayName\": \"Propensity to adverse reactions\",\n            }\n\n        # Attach allergen code to value and participant\n        allergen_code_system = self.code_mapping.fhir_to_cda(\n            new_allergy.code.coding[0].system,\n            \"system\",\n            default=\"2.16.840.1.113883.6.96\",\n        )\n        allergen_observation[\"value\"] = {\n            \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n            \"@code\": new_allergy.code.coding[0].code,\n            \"@codeSystem\": allergen_code_system,\n            # \"@codeSystemName\": new_allergy.code.coding[0].display,\n            \"@displayName\": new_allergy.code.coding[0].display,\n            \"originalText\": {\"reference\": {\"@value\": allergy_reference_name}},\n            \"@xsi:type\": \"CD\",\n        }\n\n        allergen_observation[\"participant\"] = {\n            \"@typeCode\": \"CSM\",\n            \"participantRole\": {\n                \"@classCode\": \"MANU\",\n                \"playingEntity\": {\n                    \"@classCode\": \"MMAT\",\n                    \"code\": {\n                        \"originalText\": {\n                            \"reference\": {\"@value\": allergy_reference_name}\n                        },\n                        \"@code\": new_allergy.code.coding[0].code,\n                        \"@codeSystem\": allergen_code_system,\n                        # \"@codeSystemName\": new_allergy.code.coding[0].display,\n                        \"@displayName\": new_allergy.code.coding[0].display,\n                    },\n                    \"name\": new_allergy.code.coding[0].display,\n                },\n            },\n        }\n\n        # We need an entryRelationship if either reaction or severity is present\n        if new_allergy.reaction:\n            allergen_observation[\"entryRelationship\"] = {\n                \"@typeCode\": \"MFST\",\n                \"observation\": {\n                    \"@classCode\": \"OBS\",\n                    \"@moodCode\": \"EVN\",\n                    \"templateId\": [\n                        {\"@root\": \"2.16.840.1.113883.10.20.1.54\"},\n                        {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5\"},\n                        {\n                            \"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.5\",\n                            \"@extension\": \"reaction\",\n                        },\n                    ],\n                    \"id\": {\"@root\": act_id},\n                    \"code\": {\"@code\": \"RXNASSESS\"},\n                    \"text\": {\n                        \"reference\": {\"@value\": allergy_reference_name + \"reaction\"}\n                    },\n                    \"statusCode\": {\"@code\": \"completed\"},\n                    \"effectiveTime\": {\"low\": {\"@value\": timestamp}},\n                },\n            }\n            # Attach reaction code if given otherwise attach nullFlavor\n            if new_allergy.reaction:\n                reaction_code_system = self.code_mapping.fhir_to_cda(\n                    new_allergy.reaction[0].manifestation[0].concept.coding[0].system,\n                    \"system\",\n                    default=\"2.16.840.1.113883.6.96\",\n                )\n                allergen_observation[\"entryRelationship\"][\"observation\"][\"value\"] = {\n                    \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                    \"@code\": new_allergy.reaction[0]\n                    .manifestation[0]\n                    .concept.coding[0]\n                    .code,\n                    \"@codeSystem\": reaction_code_system,\n                    # \"@codeSystemName\": new_allergy.reaction[0].manifestation[0].concept.coding[0].display,\n                    \"@displayName\": new_allergy.reaction[0]\n                    .manifestation[0]\n                    .concept.coding[0]\n                    .display,\n                    \"@xsi:type\": \"CD\",\n                    \"originalText\": {\n                        \"reference\": {\"@value\": allergy_reference_name + \"reaction\"}\n                    },\n                }\n            else:\n                allergen_observation[\"entryRelationship\"][\"observation\"][\"value\"] = {\n                    \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                    \"@nullFlavor\": \"OTH\",\n                    \"@xsi:type\": \"CD\",\n                }\n            # Attach severity code if given\n            if new_allergy.reaction[0].severity:\n                severity_code = self.code_mapping.fhir_to_cda(\n                    new_allergy.reaction[0].severity, \"severity\"\n                )\n                allergen_observation[\"entryRelationship\"][\"observation\"][\n                    \"entryRelationship\"\n                ] = {\n                    \"@typeCode\": \"SUBJ\",\n                    \"observation\": {\n                        \"@classCode\": \"OBS\",\n                        \"@moodCode\": \"EVN\",\n                        \"templateId\": [\n                            {\"@root\": \"2.16.840.1.113883.10.20.1.55\"},\n                            {\"@root\": \"1.3.6.1.4.1.19376.1.5.3.1.4.1\"},\n                        ],\n                        \"code\": {\n                            \"@code\": \"SEV\",\n                            \"@codeSystem\": \"2.16.840.1.113883.5.4\",\n                            \"@codeSystemName\": \"ActCode\",\n                            \"@displayName\": \"Severity\",\n                        },\n                        \"text\": {\n                            \"reference\": {\"@value\": allergy_reference_name + \"severity\"}\n                        },\n                        \"statusCode\": {\"@code\": \"completed\"},\n                        \"value\": {\n                            \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n                            \"@code\": new_allergy.reaction[0].severity,\n                            \"@codeSystem\": severity_code,\n                            # \"@codeSystemName\": new_allergy.severity.code_system_name,\n                            \"@displayName\": new_allergy.reaction[0].severity,\n                            \"@xsi:type\": \"CD\",\n                        },\n                    },\n                }\n\n        if not isinstance(self._allergy_section.entry, list):\n            self._allergy_section.entry = [self._allergy_section.entry]\n\n        new_entry = Entry(**template)\n        self._allergy_section.entry.append(new_entry)\n\n    def add_to_allergy_list(\n        self, allergies: List[AllergyIntolerance], overwrite: bool = False\n    ) -&gt; None:\n        \"\"\"\n        Adds allergies to the allergy list.\n\n        Args:\n            allergies: List of FHIR AllergyIntolerance resources to add\n            overwrite: If True, overwrites existing allergy list\n        \"\"\"\n        if self._allergy_section is None:\n            log.warning(\n                \"Skipping: No allergy section to add to, check your CDA configuration\"\n            )\n            return\n\n        timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n        act_id = str(uuid.uuid4())\n        allergy_reference_name = \"#a\" + str(uuid.uuid4())[:8] + \"name\"\n\n        if overwrite:\n            self._allergy_section.entry = []\n\n        added_allergies = []\n\n        for allergy in allergies:\n            if allergy in self.allergy_list:\n                log.debug(f\"Allergy {allergy.model_dump()} already exists\")\n                continue\n            log.debug(f\"Adding allergy: {allergy}\")\n            self._add_new_allergy_entry(\n                new_allergy=allergy,\n                timestamp=timestamp,\n                act_id=act_id,\n                allergy_reference_name=allergy_reference_name,\n            )\n            added_allergies.append(allergy)\n\n        if overwrite:\n            self.allergy_list = added_allergies\n        else:\n            self.allergy_list.extend(added_allergies)\n\n    def export(self, pretty_print: bool = True) -&gt; str:\n        \"\"\"\n        Exports CDA document as an XML string\n        \"\"\"\n        out_string = xmltodict.unparse(\n            {\n                \"ClinicalDocument\": self.clinical_document.model_dump(\n                    exclude_none=True, exclude_unset=True, by_alias=True\n                )\n            },\n            pretty=pretty_print,\n        )\n        # Fixes self closing tags - this is not strictly necessary, just looks more readable\n        pattern = r\"(&lt;(\\w+)(\\s+[^&gt;]*?)?)&gt;&lt;/\\2&gt;\"\n        export_xml = re.sub(pattern, r\"\\1/&gt;\", out_string)\n\n        return export_xml\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.add_to_allergy_list","title":"<code>add_to_allergy_list(allergies, overwrite=False)</code>","text":"<p>Adds allergies to the allergy list.</p> PARAMETER DESCRIPTION <code>allergies</code> <p>List of FHIR AllergyIntolerance resources to add</p> <p> TYPE: <code>List[AllergyIntolerance]</code> </p> <code>overwrite</code> <p>If True, overwrites existing allergy list</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def add_to_allergy_list(\n    self, allergies: List[AllergyIntolerance], overwrite: bool = False\n) -&gt; None:\n    \"\"\"\n    Adds allergies to the allergy list.\n\n    Args:\n        allergies: List of FHIR AllergyIntolerance resources to add\n        overwrite: If True, overwrites existing allergy list\n    \"\"\"\n    if self._allergy_section is None:\n        log.warning(\n            \"Skipping: No allergy section to add to, check your CDA configuration\"\n        )\n        return\n\n    timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n    act_id = str(uuid.uuid4())\n    allergy_reference_name = \"#a\" + str(uuid.uuid4())[:8] + \"name\"\n\n    if overwrite:\n        self._allergy_section.entry = []\n\n    added_allergies = []\n\n    for allergy in allergies:\n        if allergy in self.allergy_list:\n            log.debug(f\"Allergy {allergy.model_dump()} already exists\")\n            continue\n        log.debug(f\"Adding allergy: {allergy}\")\n        self._add_new_allergy_entry(\n            new_allergy=allergy,\n            timestamp=timestamp,\n            act_id=act_id,\n            allergy_reference_name=allergy_reference_name,\n        )\n        added_allergies.append(allergy)\n\n    if overwrite:\n        self.allergy_list = added_allergies\n    else:\n        self.allergy_list.extend(added_allergies)\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.add_to_medication_list","title":"<code>add_to_medication_list(medications, overwrite=False)</code>","text":"<p>Adds medications to the medication list.</p> PARAMETER DESCRIPTION <code>medications</code> <p>A list of MedicationStatement resources to be added</p> <p> TYPE: <code>List[MedicationStatement]</code> </p> <code>overwrite</code> <p>If True, existing medication list will be overwritten. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def add_to_medication_list(\n    self, medications: List[MedicationStatement], overwrite: bool = False\n) -&gt; None:\n    \"\"\"\n    Adds medications to the medication list.\n\n    Args:\n        medications (List[MedicationStatement]): A list of MedicationStatement resources to be added\n        overwrite (bool, optional): If True, existing medication list will be overwritten. Defaults to False.\n    \"\"\"\n    if self._medication_section is None:\n        log.warning(\n            \"Skipping: No medication section to add to, check your CDA configuration\"\n        )\n        return\n\n    timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n    subad_id = str(uuid.uuid4())\n    medication_reference_name = \"#m\" + str(uuid.uuid4())[:8] + \"name\"\n\n    if overwrite:\n        self._medication_section.entry = []\n\n    added_medications = []\n\n    for medication in medications:\n        if medication in self.medication_list:\n            log.debug(\n                f\"Skipping: medication {medication.model_dump()} already exists in the medication list.\"\n            )\n            continue\n\n        log.debug(f\"Adding medication: {medication}\")\n        self._add_new_medication_entry(\n            new_medication=medication,\n            timestamp=timestamp,\n            subad_id=subad_id,\n            medication_reference_name=medication_reference_name,\n        )\n        added_medications.append(medication)\n\n    if overwrite:\n        self.medication_list = added_medications\n    else:\n        self.medication_list.extend(added_medications)\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.add_to_problem_list","title":"<code>add_to_problem_list(problems, overwrite=False)</code>","text":"<p>Adds a list of problem lists to the problems section.</p> PARAMETER DESCRIPTION <code>problems</code> <p>A list of Condition resources to be added.</p> <p> TYPE: <code>List[Condition]</code> </p> <code>overwrite</code> <p>If True, the existing problem list will be overwritten. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def add_to_problem_list(\n    self, problems: List[Condition], overwrite: bool = False\n) -&gt; None:\n    \"\"\"\n    Adds a list of problem lists to the problems section.\n\n    Args:\n        problems (List[Condition]): A list of Condition resources to be added.\n        overwrite (bool, optional): If True, the existing problem list will be overwritten.\n            Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    if self._problem_section is None:\n        log.warning(\n            \"Skipping: No problem section to add to, check your CDA configuration\"\n        )\n        return\n\n    timestamp = datetime.now().strftime(format=\"%Y%m%d\")\n    act_id = str(uuid.uuid4())\n    problem_reference_name = \"#p\" + str(uuid.uuid4())[:8] + \"name\"\n\n    if overwrite:\n        self._problem_section.entry = []\n\n    added_problems = []\n\n    for problem in problems:\n        if problem in self.problem_list:\n            log.debug(\n                f\"Skipping: Problem {problem.model_dump()} already exists in the problem list.\"\n            )\n            continue\n        log.debug(f\"Adding problem: {problem}\")\n        self._add_new_problem_entry(\n            new_problem=problem,\n            timestamp=timestamp,\n            act_id=act_id,\n            problem_reference_name=problem_reference_name,\n        )\n        added_problems.append(problem)\n\n    if overwrite:\n        self.problem_list = added_problems\n    else:\n        self.problem_list.extend(added_problems)\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.export","title":"<code>export(pretty_print=True)</code>","text":"<p>Exports CDA document as an XML string</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def export(self, pretty_print: bool = True) -&gt; str:\n    \"\"\"\n    Exports CDA document as an XML string\n    \"\"\"\n    out_string = xmltodict.unparse(\n        {\n            \"ClinicalDocument\": self.clinical_document.model_dump(\n                exclude_none=True, exclude_unset=True, by_alias=True\n            )\n        },\n        pretty=pretty_print,\n    )\n    # Fixes self closing tags - this is not strictly necessary, just looks more readable\n    pattern = r\"(&lt;(\\w+)(\\s+[^&gt;]*?)?)&gt;&lt;/\\2&gt;\"\n    export_xml = re.sub(pattern, r\"\\1/&gt;\", out_string)\n\n    return export_xml\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of the class from a dictionary.</p> PARAMETER DESCRIPTION <code>data</code> <p>The dictionary containing the dictionary representation of the cda xml (using xmltodict.parse).</p> <p> TYPE: <code>Dict</code> </p> RETURNS DESCRIPTION <code>CdaAnnotator</code> <p>An instance of the class initialized with the data from the dictionary.</p> <p> TYPE: <code>CdaAnnotator</code> </p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict) -&gt; \"CdaAnnotator\":\n    \"\"\"\n    Creates an instance of the class from a dictionary.\n\n    Args:\n        data (Dict): The dictionary containing the dictionary representation of the cda xml (using xmltodict.parse).\n\n    Returns:\n        CdaAnnotator: An instance of the class initialized with the data from the dictionary.\n    \"\"\"\n    clinical_document_model = ClinicalDocument(**data.get(\"ClinicalDocument\", {}))\n    return cls(cda_data=clinical_document_model)\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.CdaAnnotator.from_xml","title":"<code>from_xml(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of the CDAAnnotator class from an XML string.</p> PARAMETER DESCRIPTION <code>data</code> <p>The XML string representing the CDA document.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>CDAAnnotator</code> <p>An instance of the CDAAnnotator class initialized with the parsed CDA data.</p> <p> TYPE: <code>CdaAnnotator</code> </p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>@classmethod\ndef from_xml(cls, data: str) -&gt; \"CdaAnnotator\":\n    \"\"\"\n    Creates an instance of the CDAAnnotator class from an XML string.\n\n    Args:\n        data (str): The XML string representing the CDA document.\n\n    Returns:\n        CDAAnnotator: An instance of the CDAAnnotator class initialized with the parsed CDA data.\n    \"\"\"\n    cda_dict = xmltodict.parse(data)\n    clinical_document_model = ClinicalDocument(\n        **cda_dict.get(\"ClinicalDocument\", {})\n    )\n    return cls(cda_data=clinical_document_model)\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.check_for_entry_observation","title":"<code>check_for_entry_observation(entry)</code>","text":"<p>Checks if the given entry contains an observation.</p> PARAMETER DESCRIPTION <code>entry</code> <p>The entry to check.</p> <p> TYPE: <code>Entry</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the entry contains an observation, False otherwise.</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def check_for_entry_observation(entry: Entry) -&gt; bool:\n    \"\"\"\n    Checks if the given entry contains an observation.\n\n    Args:\n        entry: The entry to check.\n\n    Returns:\n        True if the entry contains an observation, False otherwise.\n    \"\"\"\n    if isinstance(entry, EntryRelationship):\n        if entry.observation:\n            return True\n    elif isinstance(entry, Observation):\n        if entry.entryRelationship:\n            return check_for_entry_observation(entry.entryRelationship)\n    elif isinstance(entry, list):\n        for item in entry:\n            if isinstance(item, EntryRelationship):\n                if item.observation:\n                    return True\n            elif isinstance(item, Observation):\n                if item.entryRelationship:\n                    return check_for_entry_observation(item.entryRelationship)\n    return False\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.check_has_template_id","title":"<code>check_has_template_id(section, template_id)</code>","text":"<p>Check if the given section has a matching template ID.</p> PARAMETER DESCRIPTION <code>section</code> <p>The section to check.</p> <p> TYPE: <code>Section</code> </p> <code>template_id</code> <p>The template ID to match.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the section has a matching template ID, False otherwise.</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def check_has_template_id(section: Section, template_id: str) -&gt; bool:\n    \"\"\"\n    Check if the given section has a matching template ID.\n\n    Args:\n        section: The section to check.\n        template_id: The template ID to match.\n\n    Returns:\n        True if the section has a matching template ID, False otherwise.\n    \"\"\"\n\n    if section.templateId is None:\n        return False\n\n    if isinstance(section.templateId, list):\n        for template in section.templateId:\n            if template.root == template_id:\n                return True\n    elif section.templateId.root == template_id:\n        return True\n\n    return False\n</code></pre>"},{"location":"api/cda_parser/#healthchain.cda_parser.cdaannotator.get_value_from_entry_relationship","title":"<code>get_value_from_entry_relationship(entry_relationship)</code>","text":"<p>Retrieves the values from the given entry_relationship.</p> PARAMETER DESCRIPTION <code>entry_relationship</code> <p>The entry_relationship object to extract values from.</p> <p> TYPE: <code>EntryRelationship</code> </p> RETURNS DESCRIPTION <code>List</code> <p>A list of values extracted from the entry_relationship.</p> Source code in <code>healthchain/cda_parser/cdaannotator.py</code> <pre><code>def get_value_from_entry_relationship(entry_relationship: EntryRelationship) -&gt; List:\n    \"\"\"\n    Retrieves the values from the given entry_relationship.\n\n    Args:\n        entry_relationship: The entry_relationship object to extract values from.\n\n    Returns:\n        A list of values extracted from the entry_relationship.\n\n    \"\"\"\n    values = []\n    if isinstance(entry_relationship, list):\n        for item in entry_relationship:\n            if item.observation:\n                values.append(item.observation.value)\n    else:\n        if entry_relationship.observation:\n            values.append(entry_relationship.observation.value)\n    return values\n</code></pre>"},{"location":"api/cds_hooks/","title":"CDS Hooks","text":"<p>https://cds-hooks.org/specification/current/#discovery</p> <p>This is not compulsary</p> <p>https://cds-hooks.org/specification/current/#feedback</p>"},{"location":"api/cds_hooks/#healthchain.models.hooks.encounterdischarge.EncounterDischargeContext","title":"<code>EncounterDischargeContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: This hook is triggered during the discharge process for typically inpatient encounters. It can be invoked at any point from the start to the end of the discharge process. The purpose is to allow hook services to intervene in various aspects of the discharge decision. This includes verifying discharge medications, ensuring continuity of care planning, and verifying necessary documentation for discharge processing.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. The ID of the current user, expected to be a Practitioner or PractitionerRole.           For example, 'Practitioner/123'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id of the patient being discharged.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>REQUIRED. The FHIR Encounter.id of the encounter being ended.</p> <p> TYPE: <code>str</code> </p> <p>Documentation: https://cds-hooks.org/hooks/encounter-discharge/</p> Source code in <code>healthchain/models/hooks/encounterdischarge.py</code> <pre><code>class EncounterDischargeContext(BaseHookContext):\n    \"\"\"\n    Workflow:\n    This hook is triggered during the discharge process for typically inpatient encounters. It can be invoked\n    at any point from the start to the end of the discharge process. The purpose is to allow hook services to\n    intervene in various aspects of the discharge decision. This includes verifying discharge medications,\n    ensuring continuity of care planning, and verifying necessary documentation for discharge processing.\n\n    Attributes:\n        userId (str): REQUIRED. The ID of the current user, expected to be a Practitioner or PractitionerRole.\n                      For example, 'Practitioner/123'.\n        patientId (str): REQUIRED. The FHIR Patient.id of the patient being discharged.\n        encounterId (str): REQUIRED. The FHIR Encounter.id of the encounter being ended.\n\n    Documentation: https://cds-hooks.org/hooks/encounter-discharge/\n    \"\"\"\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"The ID of the current user, expected to be in the format 'Practitioner/123'.\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id of the patient being discharged.\",\n    )\n    encounterId: str = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the encounter being ended.\",\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.orderselect.OrderSelectContext","title":"<code>OrderSelectContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The order-select hook occurs after the clinician selects the order and before signing. This hook occurs when a clinician initially selects one or more new orders from a list of potential orders for a specific patient (including orders for medications, procedures, labs and other orders). The newly selected order defines that medication, procedure, lab, etc, but may or may not define the additional details necessary to finalize the order.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. An identifier of the current user, in the format [ResourceType]/[id],           where ResourceType is either 'Practitioner' or 'PractitionerRole'. Examples: 'PractitionerRole/123',           'Practitioner/abc'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>OPTIONAL. The FHIR Encounter.id representing the current encounter in context,                          if applicable.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>selections</code> <p>REQUIRED. A list of the FHIR id(s) of the newly selected orders, referencing resources                 in the draftOrders Bundle. Example: 'MedicationRequest/103'.</p> <p> TYPE: <code>[str]</code> </p> <code>draftOrders</code> <p>REQUIRED. A Bundle of FHIR request resources with a draft status, representing all unsigned                   orders from the current session, including newly selected orders.</p> <p> TYPE: <code>object</code> </p> <p>Documentation: https://cds-hooks.org/hooks/order-select/</p> Source code in <code>healthchain/models/hooks/orderselect.py</code> <pre><code>class OrderSelectContext(BaseHookContext):\n    \"\"\"\n    Workflow: The order-select hook occurs after the clinician selects the order and before signing.\n    This hook occurs when a clinician initially selects one or more new orders from a list of\n    potential orders for a specific patient (including orders for medications, procedures, labs\n    and other orders). The newly selected order defines that medication, procedure, lab, etc,\n    but may or may not define the additional details necessary to finalize the order.\n\n    Attributes:\n        userId (str): REQUIRED. An identifier of the current user, in the format [ResourceType]/[id],\n                      where ResourceType is either 'Practitioner' or 'PractitionerRole'. Examples: 'PractitionerRole/123',\n                      'Practitioner/abc'.\n        patientId (str): REQUIRED. The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): OPTIONAL. The FHIR Encounter.id representing the current encounter in context,\n                                     if applicable.\n        selections ([str]): REQUIRED. A list of the FHIR id(s) of the newly selected orders, referencing resources\n                            in the draftOrders Bundle. Example: 'MedicationRequest/103'.\n        draftOrders (object): REQUIRED. A Bundle of FHIR request resources with a draft status, representing all unsigned\n                              orders from the current session, including newly selected orders.\n\n    Documentation: https://cds-hooks.org/hooks/order-select/\n    \"\"\"\n\n    # TODO: validate selection and FHIR Bundle resource\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"An identifier of the current user in the format [ResourceType]/[id].\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id representing the current patient in context.\",\n    )\n    encounterId: Optional[str] = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the current encounter, if applicable.\",\n    )\n    selections: List[str] = Field(\n        ..., description=\"A list of the FHIR ids of the newly selected orders.\"\n    )\n    draftOrders: Dict[str, Any] = Field(\n        ..., description=\"A Bundle of FHIR request resources with a draft status.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\n            \"userId\",\n            \"patientId\",\n            \"encounterId\",\n            \"selections\",\n            \"draftOrders\",\n        }\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n\n    @model_validator(mode=\"after\")\n    def validate_selections(self) -&gt; Self:\n        for selection in self.selections:\n            if \"/\" not in selection:\n                raise ValueError(\n                    \"Each selection must be a valid FHIR resource identifier in the format 'ResourceType/ResourceID'.\"\n                )\n        return self\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.ordersign.OrderSignContext","title":"<code>OrderSignContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The order-sign hook is triggered when a clinician is ready to sign one or more orders for a patient. This includes orders for medications, procedures, labs, and other orders. It is one of the last workflow events before an order is promoted from a draft status. The context includes all order details such as dose, quantity, route, etc., even though the order is still in a draft status. This hook is also applicable for re-signing revised orders, which may have a status other than 'draft'. The hook replaces the medication-prescribe and order-review hooks.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. The ID of the current user, expected to be of type 'Practitioner' or 'PractitionerRole'.           Examples include 'PractitionerRole/123' or 'Practitioner/abc'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>OPTIONAL. The FHIR Encounter.id of the current encounter in context.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>draftOrders</code> <p>REQUIRED. A Bundle of FHIR request resources with a draft status, representing orders that                 aren't yet signed from the current ordering session.</p> <p> TYPE: <code>dict</code> </p> <p>Documentation: https://cds-hooks.org/hooks/order-sign/</p> Source code in <code>healthchain/models/hooks/ordersign.py</code> <pre><code>class OrderSignContext(BaseHookContext):\n    \"\"\"\n    Workflow:\n    The order-sign hook is triggered when a clinician is ready to sign one or more orders for a patient.\n    This includes orders for medications, procedures, labs, and other orders. It is one of the last workflow\n    events before an order is promoted from a draft status. The context includes all order details such as\n    dose, quantity, route, etc., even though the order is still in a draft status. This hook is also applicable\n    for re-signing revised orders, which may have a status other than 'draft'. The hook replaces the\n    medication-prescribe and order-review hooks.\n\n    Attributes:\n        userId (str): REQUIRED. The ID of the current user, expected to be of type 'Practitioner' or 'PractitionerRole'.\n                      Examples include 'PractitionerRole/123' or 'Practitioner/abc'.\n        patientId (str): REQUIRED. The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): OPTIONAL. The FHIR Encounter.id of the current encounter in context.\n        draftOrders (dict): REQUIRED. A Bundle of FHIR request resources with a draft status, representing orders that\n                            aren't yet signed from the current ordering session.\n\n    Documentation: https://cds-hooks.org/hooks/order-sign/\n    \"\"\"\n\n    # TODO: validate draftOrders\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"The ID of the current user in the format [ResourceType]/[id].\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id representing the current patient in context.\",\n    )\n    encounterId: Optional[str] = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the current encounter, if applicable.\",\n    )\n    draftOrders: Dict[str, Any] = Field(\n        ..., description=\"A Bundle of FHIR request resources with a draft status.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\", \"draftOrders\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.patientview.PatientViewContext","title":"<code>PatientViewContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The user has just opened a patient's record; typically called only once at the beginning of a user's interaction with a specific patient's record.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>An identifier of the current user, in the format [ResourceType]/[id],           where ResourceType is one of 'Practitioner', 'PractitionerRole', 'Patient',           or 'RelatedPerson'. Examples: 'Practitioner/abc', 'Patient/123'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>The FHIR Encounter.id representing the current encounter in context,                          if applicable. This field is optional.</p> <p> TYPE: <code>Optional[str]</code> </p> <p>Documentation: https://cds-hooks.org/hooks/patient-view/</p> Source code in <code>healthchain/models/hooks/patientview.py</code> <pre><code>class PatientViewContext(BaseHookContext):\n    \"\"\"\n    Workflow: The user has just opened a patient's record; typically called only once at the beginning of a user's\n    interaction with a specific patient's record.\n\n    Attributes:\n        userId (str): An identifier of the current user, in the format [ResourceType]/[id],\n                      where ResourceType is one of 'Practitioner', 'PractitionerRole', 'Patient',\n                      or 'RelatedPerson'. Examples: 'Practitioner/abc', 'Patient/123'.\n        patientId (str): The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): The FHIR Encounter.id representing the current encounter in context,\n                                     if applicable. This field is optional.\n\n    Documentation: https://cds-hooks.org/hooks/patient-view/\n    \"\"\"\n\n    # TODO: more comprehensive validator? for now regex should suffice\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole|Patient|RelatedPerson)/[^\\s]+$\",\n        description=\"The ID of the current user, expected to be in the format 'Practitioner/123'.\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id of the patient.\",\n    )\n    encounterId: Optional[str] = Field(\n        None, description=\"The FHIR Encounter.id of the encounter, if applicable.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsdiscovery.CDSService","title":"<code>CDSService</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model representing a CDS service configuration.</p> ATTRIBUTE DESCRIPTION <code>hook</code> <p>The hook this service should be invoked on. This should correspond to one of the predefined hooks.</p> <p> TYPE: <code>str</code> </p> <code>title</code> <p>The human-friendly name of this service. It is recommended to provide this for better usability.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>description</code> <p>A detailed description of what this service does and its purpose within the CDS framework.</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>The unique identifier of this service. It forms part of the URL as {baseUrl}/cds-services/{id}.</p> <p> TYPE: <code>str</code> </p> <code>prefetch</code> <p>Optional FHIR queries that the service requests the CDS Client to perform                                 and provide on each service call. Keys describe the type of data and values are the actual FHIR query strings.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> </p> <code>usageRequirements</code> <p>Human-friendly description of any preconditions for the use of this CDS service.</p> <p> TYPE: <code>Optional[str]</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#response</p> Source code in <code>healthchain/models/responses/cdsdiscovery.py</code> <pre><code>class CDSService(BaseModel):\n    \"\"\"\n    A model representing a CDS service configuration.\n\n    Attributes:\n        hook (str): The hook this service should be invoked on. This should correspond to one of the predefined hooks.\n        title (Optional[str]): The human-friendly name of this service. It is recommended to provide this for better usability.\n        description (str): A detailed description of what this service does and its purpose within the CDS framework.\n        id (str): The unique identifier of this service. It forms part of the URL as {baseUrl}/cds-services/{id}.\n        prefetch (Optional[Dict[str, str]]): Optional FHIR queries that the service requests the CDS Client to perform\n                                            and provide on each service call. Keys describe the type of data and values are the actual FHIR query strings.\n        usageRequirements (Optional[str]): Human-friendly description of any preconditions for the use of this CDS service.\n\n    Documentation: https://cds-hooks.org/specification/current/#response\n    \"\"\"\n\n    hook: str\n    description: str\n    id: str\n    title: Optional[str] = None\n    prefetch: Optional[Dict[str, Any]] = None\n    usageRequirements: Optional[str] = None\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsdiscovery.CDSServiceInformation","title":"<code>CDSServiceInformation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A CDS Service is discoverable via a stable endpoint by CDS Clients. The Discovery endpoint includes information such as a description of the CDS Service, when it should be invoked, and any data that is requested to be prefetched.</p> Source code in <code>healthchain/models/responses/cdsdiscovery.py</code> <pre><code>class CDSServiceInformation(BaseModel):\n    \"\"\"\n    A CDS Service is discoverable via a stable endpoint by CDS Clients. The Discovery endpoint includes information such as a\n    description of the CDS Service, when it should be invoked, and any data that is requested to be prefetched.\n    \"\"\"\n\n    services: List[CDSService] = []\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsfeedback.CDSFeedback","title":"<code>CDSFeedback</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A feedback endpoint enables suggestion tracking &amp; analytics. A CDS Service MAY support a feedback endpoint; a CDS Client SHOULD be capable of sending feedback.</p> ATTRIBUTE DESCRIPTION <code>card</code> <p>The card.uuid from the CDS Hooks response. Uniquely identifies the card.</p> <p> TYPE: <code>str</code> </p> <code>outcome</code> <p>The outcome of the action, either 'accepted' or 'overridden'.</p> <p> TYPE: <code>str</code> </p> <code>acceptedSuggestions</code> <p>An array of accepted suggestions, required if the outcome is 'accepted'.</p> <p> TYPE: <code>List[AcceptedSuggestion]</code> </p> <code>overrideReason</code> <p>The reason for overriding, including any coding and comments.</p> <p> TYPE: <code>Optional[OverrideReason]</code> </p> <code>outcomeTimestamp</code> <p>The ISO8601 timestamp of when the action was taken on the card.</p> <p> TYPE: <code>datetime</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#feedback</p> Source code in <code>healthchain/models/responses/cdsfeedback.py</code> <pre><code>class CDSFeedback(BaseModel):\n    \"\"\"\n    A feedback endpoint enables suggestion tracking &amp; analytics.\n    A CDS Service MAY support a feedback endpoint; a CDS Client SHOULD be capable of sending feedback.\n\n    Attributes:\n        card (str): The card.uuid from the CDS Hooks response. Uniquely identifies the card.\n        outcome (str): The outcome of the action, either 'accepted' or 'overridden'.\n        acceptedSuggestions (List[AcceptedSuggestion]): An array of accepted suggestions, required if the outcome is 'accepted'.\n        overrideReason (Optional[OverrideReason]): The reason for overriding, including any coding and comments.\n        outcomeTimestamp (datetime): The ISO8601 timestamp of when the action was taken on the card.\n\n    Documentation: https://cds-hooks.org/specification/current/#feedback\n    \"\"\"\n\n    card: str\n    outcome: OutcomeEnum\n    outcomeTimestamp: str\n    acceptedSuggestion: Optional[Dict[str, Any]] = None\n    overriddeReason: Optional[OverrideReason] = None\n</code></pre>"},{"location":"api/clients/","title":"Clients","text":""},{"location":"api/clients/#healthchain.clients.ehrclient.EHRClient","title":"<code>EHRClient</code>","text":"<p>               Bases: <code>BaseClient</code></p> Source code in <code>healthchain/clients/ehrclient.py</code> <pre><code>class EHRClient(BaseClient):\n    def __init__(\n        self,\n        func: Callable[..., Any],\n        workflow: Workflow,\n        strategy: BaseStrategy,\n        timeout: Optional[float] = 10.0,\n    ):\n        \"\"\"\n        Initializes the EHRClient with a data generator function and optional workflow and use case.\n        Should be a subclass of BaseUseCase. Example - ClinicalDecisionSupport()\n\n        Parameters:\n            func (Callable[..., Any]): A function to generate data for requests.\n            workflow ([Workflow]): The workflow context to apply to the data generator.\n            strategy (BaseStrategy): The strategy object to construct requests based on the generated data.\n            timeout (Optional[float], default=10.0) : The maximum time in seconds to wait for a response from the server. This parameter determines how long the client will wait before considering a request timed out.\n\n        \"\"\"\n        # TODO: Add option to pass in different provider options\n        self.data_generator_func: Callable[..., Any] = func\n        self.workflow: Workflow = workflow\n        self.strategy: BaseStrategy = strategy\n        self.vendor = None\n        self.request_data: List[CDSRequest] = []\n        self.timeout = timeout\n\n    def set_vendor(self, name) -&gt; None:\n        self.vendor = name\n\n    def generate_request(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Generates a request using the data produced by the data generator function,\n        and appends it to the internal request queue.\n\n            Parameters:\n                *args (Any): Positional arguments passed to the data generator function.\n                **kwargs (Any): Keyword arguments passed to the data generator function.\n\n            Raises:\n                ValueError: If the use case is not configured.\n        \"\"\"\n        data = self.data_generator_func(*args, **kwargs)\n        self.request_data.append(self.strategy.construct_request(data, self.workflow))\n\n    async def send_request(self, url: str) -&gt; List[Dict]:\n        \"\"\"\n        Sends all queued requests to the specified URL and collects the responses.\n\n            Parameters:\n                url (str): The URL to which the requests will be sent.\n            Returns:\n                List[dict]: A list of JSON responses from the server.\n            Notes:\n                This method logs errors rather than raising them, to avoid interrupting the batch processing of requests.\n        \"\"\"\n        async with httpx.AsyncClient() as client:\n            responses: List[Dict] = []\n            timeout = httpx.Timeout(self.timeout, read=None)\n            for request in self.request_data:\n                try:\n                    if self.strategy.api_protocol == ApiProtocol.soap:\n                        headers = {\"Content-Type\": \"text/xml; charset=utf-8\"}\n                        response = await client.post(\n                            url=url,\n                            data=request.document,\n                            headers=headers,\n                            timeout=timeout,\n                        )\n                        response.raise_for_status()\n                        response_model = CdaResponse(document=response.text)\n                        responses.append(response_model.model_dump_xml())\n                    else:\n                        # TODO: use model_dump_json() once Pydantic V2 timezone serialization issue is resolved\n                        response = await client.post(\n                            url=url,\n                            json=request.model_dump(exclude_none=True),\n                            timeout=timeout,\n                        )\n                        response.raise_for_status()\n                        responses.append(response.json())\n                except httpx.HTTPStatusError as exc:\n                    log.error(\n                        f\"Error response {exc.response.status_code} while requesting {exc.request.url!r}: {exc.response.json()}\"\n                    )\n                    responses.append({})\n                except httpx.TimeoutException as exc:\n                    log.error(f\"Request to {exc.request.url!r} timed out!\")\n                    responses.append({})\n                except httpx.RequestError as exc:\n                    log.error(\n                        f\"An error occurred while requesting {exc.request.url!r}.\"\n                    )\n                    responses.append({})\n\n        return responses\n</code></pre>"},{"location":"api/clients/#healthchain.clients.ehrclient.EHRClient.__init__","title":"<code>__init__(func, workflow, strategy, timeout=10.0)</code>","text":"<p>Initializes the EHRClient with a data generator function and optional workflow and use case. Should be a subclass of BaseUseCase. Example - ClinicalDecisionSupport()</p> PARAMETER DESCRIPTION <code>func</code> <p>A function to generate data for requests.</p> <p> TYPE: <code>Callable[..., Any]</code> </p> <code>workflow</code> <p>The workflow context to apply to the data generator.</p> <p> TYPE: <code>[Workflow]</code> </p> <code>strategy</code> <p>The strategy object to construct requests based on the generated data.</p> <p> TYPE: <code>BaseStrategy</code> </p> <code>timeout</code> <p>The maximum time in seconds to wait for a response from the server. This parameter determines how long the client will wait before considering a request timed out.</p> <p> TYPE: <code>Optional[float], default=10.0) </code> DEFAULT: <code>10.0</code> </p> Source code in <code>healthchain/clients/ehrclient.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[..., Any],\n    workflow: Workflow,\n    strategy: BaseStrategy,\n    timeout: Optional[float] = 10.0,\n):\n    \"\"\"\n    Initializes the EHRClient with a data generator function and optional workflow and use case.\n    Should be a subclass of BaseUseCase. Example - ClinicalDecisionSupport()\n\n    Parameters:\n        func (Callable[..., Any]): A function to generate data for requests.\n        workflow ([Workflow]): The workflow context to apply to the data generator.\n        strategy (BaseStrategy): The strategy object to construct requests based on the generated data.\n        timeout (Optional[float], default=10.0) : The maximum time in seconds to wait for a response from the server. This parameter determines how long the client will wait before considering a request timed out.\n\n    \"\"\"\n    # TODO: Add option to pass in different provider options\n    self.data_generator_func: Callable[..., Any] = func\n    self.workflow: Workflow = workflow\n    self.strategy: BaseStrategy = strategy\n    self.vendor = None\n    self.request_data: List[CDSRequest] = []\n    self.timeout = timeout\n</code></pre>"},{"location":"api/clients/#healthchain.clients.ehrclient.EHRClient.generate_request","title":"<code>generate_request(*args, **kwargs)</code>","text":"<p>Generates a request using the data produced by the data generator function, and appends it to the internal request queue.</p> <pre><code>Parameters:\n    *args (Any): Positional arguments passed to the data generator function.\n    **kwargs (Any): Keyword arguments passed to the data generator function.\n\nRaises:\n    ValueError: If the use case is not configured.\n</code></pre> Source code in <code>healthchain/clients/ehrclient.py</code> <pre><code>def generate_request(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Generates a request using the data produced by the data generator function,\n    and appends it to the internal request queue.\n\n        Parameters:\n            *args (Any): Positional arguments passed to the data generator function.\n            **kwargs (Any): Keyword arguments passed to the data generator function.\n\n        Raises:\n            ValueError: If the use case is not configured.\n    \"\"\"\n    data = self.data_generator_func(*args, **kwargs)\n    self.request_data.append(self.strategy.construct_request(data, self.workflow))\n</code></pre>"},{"location":"api/clients/#healthchain.clients.ehrclient.EHRClient.send_request","title":"<code>send_request(url)</code>  <code>async</code>","text":"<p>Sends all queued requests to the specified URL and collects the responses.</p> <pre><code>Parameters:\n    url (str): The URL to which the requests will be sent.\nReturns:\n    List[dict]: A list of JSON responses from the server.\nNotes:\n    This method logs errors rather than raising them, to avoid interrupting the batch processing of requests.\n</code></pre> Source code in <code>healthchain/clients/ehrclient.py</code> <pre><code>async def send_request(self, url: str) -&gt; List[Dict]:\n    \"\"\"\n    Sends all queued requests to the specified URL and collects the responses.\n\n        Parameters:\n            url (str): The URL to which the requests will be sent.\n        Returns:\n            List[dict]: A list of JSON responses from the server.\n        Notes:\n            This method logs errors rather than raising them, to avoid interrupting the batch processing of requests.\n    \"\"\"\n    async with httpx.AsyncClient() as client:\n        responses: List[Dict] = []\n        timeout = httpx.Timeout(self.timeout, read=None)\n        for request in self.request_data:\n            try:\n                if self.strategy.api_protocol == ApiProtocol.soap:\n                    headers = {\"Content-Type\": \"text/xml; charset=utf-8\"}\n                    response = await client.post(\n                        url=url,\n                        data=request.document,\n                        headers=headers,\n                        timeout=timeout,\n                    )\n                    response.raise_for_status()\n                    response_model = CdaResponse(document=response.text)\n                    responses.append(response_model.model_dump_xml())\n                else:\n                    # TODO: use model_dump_json() once Pydantic V2 timezone serialization issue is resolved\n                    response = await client.post(\n                        url=url,\n                        json=request.model_dump(exclude_none=True),\n                        timeout=timeout,\n                    )\n                    response.raise_for_status()\n                    responses.append(response.json())\n            except httpx.HTTPStatusError as exc:\n                log.error(\n                    f\"Error response {exc.response.status_code} while requesting {exc.request.url!r}: {exc.response.json()}\"\n                )\n                responses.append({})\n            except httpx.TimeoutException as exc:\n                log.error(f\"Request to {exc.request.url!r} timed out!\")\n                responses.append({})\n            except httpx.RequestError as exc:\n                log.error(\n                    f\"An error occurred while requesting {exc.request.url!r}.\"\n                )\n                responses.append({})\n\n    return responses\n</code></pre>"},{"location":"api/clients/#healthchain.clients.ehrclient.ehr","title":"<code>ehr(func=None, *, workflow, num=1)</code>","text":"<p>A decorator that wraps around a data generator function and returns an EHRClient</p> PARAMETER DESCRIPTION <code>func</code> <p>The function to be decorated. If None, this allows the decorator to                        be used with arguments.</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>workflow</code> <p>The workflow identifier which should match an item in the Workflow enum.                       This specifies the context in which the EHR function will operate.</p> <p> TYPE: <code>[str]</code> </p> <code>num</code> <p>The number of requests to generate in the queue; defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A decorated callable that incorporates EHR functionality or the decorator itself       if 'func' is None, allowing it to be used as a parameterized decorator.</p> <p> TYPE: <code>Union[Callable[..., Any], Callable[[F], F]]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the workflow does not correspond to any defined enum or if use case is not configured.</p> <code>NotImplementedError</code> <p>If the use case class is not one of the supported types.</p> Example <p>@ehr(workflow='patient-view', num=2) def generate_data(self, config):     # Function implementation</p> Source code in <code>healthchain/clients/ehrclient.py</code> <pre><code>def ehr(\n    func: Optional[F] = None, *, workflow: Workflow, num: int = 1\n) -&gt; Union[Callable[..., Any], Callable[[F], F]]:\n    \"\"\"\n    A decorator that wraps around a data generator function and returns an EHRClient\n\n    Parameters:\n        func (Optional[Callable]): The function to be decorated. If None, this allows the decorator to\n                                   be used with arguments.\n        workflow ([str]): The workflow identifier which should match an item in the Workflow enum.\n                                  This specifies the context in which the EHR function will operate.\n        num (int): The number of requests to generate in the queue; defaults to 1.\n\n    Returns:\n        Callable: A decorated callable that incorporates EHR functionality or the decorator itself\n                  if 'func' is None, allowing it to be used as a parameterized decorator.\n\n    Raises:\n        ValueError: If the workflow does not correspond to any defined enum or if use case is not configured.\n        NotImplementedError: If the use case class is not one of the supported types.\n\n    Example:\n        @ehr(workflow='patient-view', num=2)\n        def generate_data(self, config):\n            # Function implementation\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        func.is_client = True\n\n        @wraps(func)\n        def wrapper(self, *args: Any, **kwargs: Any) -&gt; EHRClient:\n            # Validate function decorated is a use case base class\n            assert issubclass(\n                type(self), BaseUseCase\n            ), f\"{self.__class__.__name__} must be subclass of valid Use Case strategy!\"\n\n            # Validate workflow is a valid workflow\n            try:\n                workflow_enum = Workflow(workflow)\n            except ValueError as e:\n                raise ValueError(\n                    f\"{e}: please select from {[x.value for x in Workflow]}\"\n                )\n\n            # Set workflow in data generator if configured\n            data_generator_attributes = find_attributes_of_type(self, CdsDataGenerator)\n            for i in range(len(data_generator_attributes)):\n                attribute_name = data_generator_attributes[i]\n                try:\n                    assign_to_attribute(\n                        self, attribute_name, \"set_workflow\", workflow_enum\n                    )\n                except Exception as e:\n                    log.error(\n                        f\"Could not set workflow {workflow_enum.value} for data generator method {attribute_name}: {e}\"\n                    )\n                if i &gt; 1:\n                    log.warning(\"More than one DataGenerator instances found.\")\n\n            # Wrap the function in EHRClient with workflow and strategy passed in\n            if self.type in UseCaseType:\n                method = EHRClient(func, workflow=workflow_enum, strategy=self.strategy)\n                # Generate the number of requests specified with method\n                for _ in range(num):\n                    method.generate_request(self, *args, **kwargs)\n            else:\n                raise NotImplementedError(\n                    f\"Use case {self.type} not recognised, check if implemented.\"\n                )\n            return method\n\n        return wrapper\n\n    if func is None:\n        return decorator\n    else:\n        return decorator(func)\n</code></pre>"},{"location":"api/component/","title":"Component","text":""},{"location":"api/component/#healthchain.pipeline.components.base.BaseComponent","title":"<code>BaseComponent</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for all components in the pipeline.</p> <p>This class should be subclassed to create specific components. Subclasses must implement the call method.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>class BaseComponent(Generic[T], ABC):\n    \"\"\"\n    Abstract base class for all components in the pipeline.\n\n    This class should be subclassed to create specific components.\n    Subclasses must implement the __call__ method.\n    \"\"\"\n\n    @abstractmethod\n    def __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        \"\"\"\n        Process the input data and return the processed data.\n\n        Args:\n            data (DataContainer[T]): The input data to be processed.\n\n        Returns:\n            DataContainer[T]: The processed data.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.base.BaseComponent.__call__","title":"<code>__call__(data)</code>  <code>abstractmethod</code>","text":"<p>Process the input data and return the processed data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The input data to be processed.</p> <p> TYPE: <code>DataContainer[T]</code> </p> RETURNS DESCRIPTION <code>DataContainer[T]</code> <p>DataContainer[T]: The processed data.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>@abstractmethod\ndef __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n    \"\"\"\n    Process the input data and return the processed data.\n\n    Args:\n        data (DataContainer[T]): The input data to be processed.\n\n    Returns:\n        DataContainer[T]: The processed data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.base.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>BaseComponent[T]</code></p> <p>A concrete implementation of the BaseComponent class.</p> <p>This class can be used as a base for creating specific components that do not require any additional processing logic.</p> METHOD DESCRIPTION <code>__call__</code> <p>DataContainer[T]) -&gt; DataContainer[T]: Process the input data and return the processed data. In this implementation, the input data is returned unmodified.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>class Component(BaseComponent[T]):\n    \"\"\"\n    A concrete implementation of the BaseComponent class.\n\n    This class can be used as a base for creating specific components\n    that do not require any additional processing logic.\n\n    Methods:\n        __call__(data: DataContainer[T]) -&gt; DataContainer[T]:\n            Process the input data and return the processed data.\n            In this implementation, the input data is returned unmodified.\n    \"\"\"\n\n    def __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        return data\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer","title":"<code>HFTransformer</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <p>A component that integrates Hugging Face transformers models into the pipeline.</p> <p>This component allows using any Hugging Face model and task within the pipeline by wrapping the transformers.pipeline API. The model outputs are stored in the document's model_outputs container under the \"huggingface\" source key.</p> <p>Note that this component is only recommended for non-conversational language tasks. For chat-based tasks, consider using LangChainLLM instead.</p> PARAMETER DESCRIPTION <code>pipeline</code> <p>A pre-configured HuggingFace pipeline object to use for inference. Must be an instance of transformers.pipelines.base.Pipeline.</p> <p> TYPE: <code>Any</code> </p> ATTRIBUTE DESCRIPTION <code>task</code> <p>The task name of the underlying pipeline, e.g. \"sentiment-analysis\", \"ner\". Automatically extracted from the pipeline object.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ImportError</code> <p>If the transformers package is not installed</p> <code>TypeError</code> <p>If pipeline is not a valid HuggingFace Pipeline instance</p> Example Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>class HFTransformer(BaseComponent[str]):\n    \"\"\"\n    A component that integrates Hugging Face transformers models into the pipeline.\n\n    This component allows using any Hugging Face model and task within the pipeline\n    by wrapping the transformers.pipeline API. The model outputs are stored in the\n    document's model_outputs container under the \"huggingface\" source key.\n\n    Note that this component is only recommended for non-conversational language tasks.\n    For chat-based tasks, consider using LangChainLLM instead.\n\n    Args:\n        pipeline (Any): A pre-configured HuggingFace pipeline object to use for inference.\n            Must be an instance of transformers.pipelines.base.Pipeline.\n\n    Attributes:\n        task (str): The task name of the underlying pipeline, e.g. \"sentiment-analysis\", \"ner\".\n            Automatically extracted from the pipeline object.\n\n    Raises:\n        ImportError: If the transformers package is not installed\n        TypeError: If pipeline is not a valid HuggingFace Pipeline instance\n\n    Example:\n        &gt;&gt;&gt; # Initialize for sentiment analysis\n        &gt;&gt;&gt; from transformers import pipeline\n        &gt;&gt;&gt; nlp = pipeline(\"sentiment-analysis\", model=\"distilbert-base-uncased-finetuned-sst-2-english\")\n        &gt;&gt;&gt; component = HFTransformer(pipeline=nlp)\n        &gt;&gt;&gt; doc = component(doc)  # Analyzes sentiment of doc.data\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or use the factory method\n        &gt;&gt;&gt; component = HFTransformer.from_model_id(\n        ...     model=\"facebook/bart-large-cnn\",\n        ...     task=\"summarization\",\n        ...     max_length=130,\n        ...     min_length=30,\n        ...     do_sample=False\n        ... )\n        &gt;&gt;&gt; doc = component(doc)  # Generates summary of doc.data\n    \"\"\"\n\n    @requires_package(\"transformers\", \"transformers.pipelines\")\n    def __init__(self, pipeline: Any):\n        \"\"\"Initialize with a pre-configured HuggingFace pipeline.\n\n        Args:\n            pipeline: A pre-configured HuggingFace pipeline object from transformers.pipeline().\n                     Must be an instance of transformers.pipelines.base.Pipeline.\n\n        Raises:\n            ImportError: If transformers package is not installed\n            TypeError: If pipeline is not a valid HuggingFace Pipeline instance\n        \"\"\"\n        from transformers.pipelines.base import Pipeline\n\n        if not isinstance(pipeline, Pipeline):\n            raise TypeError(\n                f\"Expected HuggingFace Pipeline object, got {type(pipeline)}\"\n            )\n        self._pipe = pipeline\n        self.task = pipeline.task\n\n    @classmethod\n    @requires_package(\"transformers\", \"transformers.pipelines\")\n    def from_model_id(cls, model: str, task: str, **kwargs: Any) -&gt; \"HFTransformer\":\n        \"\"\"Create a transformer component from a model identifier.\n\n        Factory method that initializes a HuggingFace pipeline with the specified model and task,\n        then wraps it in a HFTransformer component.\n\n        Args:\n            model: The model identifier or path to load. Can be:\n                - A model ID from the HuggingFace Hub (e.g. \"bert-base-uncased\")\n                - A local path to a saved model\n            task: The task to run (e.g. \"text-classification\", \"token-classification\", \"summarization\")\n            **kwargs: Additional configuration options passed to transformers.pipeline()\n                Common options include:\n                - device: Device to run on (\"cpu\", \"cuda\", etc.)\n                - batch_size: Batch size for inference\n                - model_kwargs: Dict of model-specific args\n\n        Returns:\n            HFTransformer: Initialized transformer component wrapping the pipeline\n\n        Raises:\n            TypeError: If invalid kwargs are passed to pipeline initialization\n            ValueError: If pipeline initialization fails for any other reason\n            ImportError: If transformers package is not installed\n        \"\"\"\n        from transformers import pipeline\n\n        try:\n            pipe = pipeline(task=task, model=model, **kwargs)\n        except TypeError as e:\n            raise TypeError(f\"Invalid kwargs for transformers.pipeline: {str(e)}\")\n        except Exception as e:\n            raise ValueError(f\"Error initializing transformer pipeline: {str(e)}\")\n\n        return cls(pipeline=pipe)\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Process the document using the Hugging Face pipeline. Adds outputs to .model_outputs['huggingface'].\"\"\"\n        output = self._pipe(doc.data)\n        doc.models.add_output(\"huggingface\", self.task, output)\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer--initialize-for-sentiment-analysis","title":"Initialize for sentiment analysis","text":"<p>from transformers import pipeline nlp = pipeline(\"sentiment-analysis\", model=\"distilbert-base-uncased-finetuned-sst-2-english\") component = HFTransformer(pipeline=nlp) doc = component(doc)  # Analyzes sentiment of doc.data</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer--or-use-the-factory-method","title":"Or use the factory method","text":"<p>component = HFTransformer.from_model_id( ...     model=\"facebook/bart-large-cnn\", ...     task=\"summarization\", ...     max_length=130, ...     min_length=30, ...     do_sample=False ... ) doc = component(doc)  # Generates summary of doc.data</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process the document using the Hugging Face pipeline. Adds outputs to .model_outputs['huggingface'].</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"Process the document using the Hugging Face pipeline. Adds outputs to .model_outputs['huggingface'].\"\"\"\n    output = self._pipe(doc.data)\n    doc.models.add_output(\"huggingface\", self.task, output)\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer.__init__","title":"<code>__init__(pipeline)</code>","text":"<p>Initialize with a pre-configured HuggingFace pipeline.</p> PARAMETER DESCRIPTION <code>pipeline</code> <p>A pre-configured HuggingFace pipeline object from transformers.pipeline().      Must be an instance of transformers.pipelines.base.Pipeline.</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>ImportError</code> <p>If transformers package is not installed</p> <code>TypeError</code> <p>If pipeline is not a valid HuggingFace Pipeline instance</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@requires_package(\"transformers\", \"transformers.pipelines\")\ndef __init__(self, pipeline: Any):\n    \"\"\"Initialize with a pre-configured HuggingFace pipeline.\n\n    Args:\n        pipeline: A pre-configured HuggingFace pipeline object from transformers.pipeline().\n                 Must be an instance of transformers.pipelines.base.Pipeline.\n\n    Raises:\n        ImportError: If transformers package is not installed\n        TypeError: If pipeline is not a valid HuggingFace Pipeline instance\n    \"\"\"\n    from transformers.pipelines.base import Pipeline\n\n    if not isinstance(pipeline, Pipeline):\n        raise TypeError(\n            f\"Expected HuggingFace Pipeline object, got {type(pipeline)}\"\n        )\n    self._pipe = pipeline\n    self.task = pipeline.task\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer.from_model_id","title":"<code>from_model_id(model, task, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a transformer component from a model identifier.</p> <p>Factory method that initializes a HuggingFace pipeline with the specified model and task, then wraps it in a HFTransformer component.</p> PARAMETER DESCRIPTION <code>model</code> <p>The model identifier or path to load. Can be: - A model ID from the HuggingFace Hub (e.g. \"bert-base-uncased\") - A local path to a saved model</p> <p> TYPE: <code>str</code> </p> <code>task</code> <p>The task to run (e.g. \"text-classification\", \"token-classification\", \"summarization\")</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to transformers.pipeline() Common options include: - device: Device to run on (\"cpu\", \"cuda\", etc.) - batch_size: Batch size for inference - model_kwargs: Dict of model-specific args</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>HFTransformer</code> <p>Initialized transformer component wrapping the pipeline</p> <p> TYPE: <code>HFTransformer</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If invalid kwargs are passed to pipeline initialization</p> <code>ValueError</code> <p>If pipeline initialization fails for any other reason</p> <code>ImportError</code> <p>If transformers package is not installed</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@classmethod\n@requires_package(\"transformers\", \"transformers.pipelines\")\ndef from_model_id(cls, model: str, task: str, **kwargs: Any) -&gt; \"HFTransformer\":\n    \"\"\"Create a transformer component from a model identifier.\n\n    Factory method that initializes a HuggingFace pipeline with the specified model and task,\n    then wraps it in a HFTransformer component.\n\n    Args:\n        model: The model identifier or path to load. Can be:\n            - A model ID from the HuggingFace Hub (e.g. \"bert-base-uncased\")\n            - A local path to a saved model\n        task: The task to run (e.g. \"text-classification\", \"token-classification\", \"summarization\")\n        **kwargs: Additional configuration options passed to transformers.pipeline()\n            Common options include:\n            - device: Device to run on (\"cpu\", \"cuda\", etc.)\n            - batch_size: Batch size for inference\n            - model_kwargs: Dict of model-specific args\n\n    Returns:\n        HFTransformer: Initialized transformer component wrapping the pipeline\n\n    Raises:\n        TypeError: If invalid kwargs are passed to pipeline initialization\n        ValueError: If pipeline initialization fails for any other reason\n        ImportError: If transformers package is not installed\n    \"\"\"\n    from transformers import pipeline\n\n    try:\n        pipe = pipeline(task=task, model=model, **kwargs)\n    except TypeError as e:\n        raise TypeError(f\"Invalid kwargs for transformers.pipeline: {str(e)}\")\n    except Exception as e:\n        raise ValueError(f\"Error initializing transformer pipeline: {str(e)}\")\n\n    return cls(pipeline=pipe)\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.LangChainLLM","title":"<code>LangChainLLM</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <p>A component that integrates LangChain chains into the pipeline.</p> <p>This component allows using any LangChain chain within the pipeline by wrapping the chain's invoke method. The chain outputs are stored in the document's model_outputs container under the \"langchain\" source key.</p> PARAMETER DESCRIPTION <code>chain</code> <p>The LangChain chain to run on the document text. Must be a Runnable object from the LangChain library.</p> <p> TYPE: <code>Runnable</code> </p> <code>task</code> <p>The task name to use when storing outputs, e.g. \"summarization\", \"chat\". Used as key to organize model outputs in the document's model container.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Additional parameters to pass to the chain's invoke method. These are forwarded directly to the chain's invoke() call.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If chain is not a LangChain Runnable object or if invalid kwargs are passed</p> <code>ValueError</code> <p>If there is an error during chain invocation</p> <code>ImportError</code> <p>If langchain-core package is not installed</p> Example <p>from langchain_core.prompts import ChatPromptTemplate from langchain_openai import ChatOpenAI</p> <p>chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI() component = LangChainLLM(chain=chain, task=\"chat\") doc = component(doc)  # Runs the chain on doc.data and stores output</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>class LangChainLLM(BaseComponent[str]):\n    \"\"\"\n    A component that integrates LangChain chains into the pipeline.\n\n    This component allows using any LangChain chain within the pipeline by wrapping\n    the chain's invoke method. The chain outputs are stored in the document's\n    model_outputs container under the \"langchain\" source key.\n\n    Args:\n        chain (Runnable): The LangChain chain to run on the document text.\n            Must be a Runnable object from the LangChain library.\n        task (str): The task name to use when storing outputs, e.g. \"summarization\", \"chat\".\n            Used as key to organize model outputs in the document's model container.\n        **kwargs: Additional parameters to pass to the chain's invoke method.\n            These are forwarded directly to the chain's invoke() call.\n\n    Raises:\n        TypeError: If chain is not a LangChain Runnable object or if invalid kwargs are passed\n        ValueError: If there is an error during chain invocation\n        ImportError: If langchain-core package is not installed\n\n    Example:\n        &gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n        &gt;&gt;&gt; from langchain_openai import ChatOpenAI\n\n        &gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n        &gt;&gt;&gt; component = LangChainLLM(chain=chain, task=\"chat\")\n        &gt;&gt;&gt; doc = component(doc)  # Runs the chain on doc.data and stores output\n    \"\"\"\n\n    @requires_package(\"langchain-core\", \"langchain_core.runnables\")\n    def __init__(self, chain: Any, task: str, **kwargs: Any):\n        \"\"\"Initialize with a LangChain chain.\"\"\"\n        from langchain_core.runnables import Runnable\n\n        if not isinstance(chain, Runnable):\n            raise TypeError(f\"Expected LangChain Runnable object, got {type(chain)}\")\n\n        self.chain = chain\n        self.task = task\n        self.kwargs = kwargs\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Process the document using the LangChain chain. Adds outputs to .model_outputs['langchain'].\"\"\"\n        try:\n            output = self.chain.invoke(doc.data, **self.kwargs)\n        except TypeError as e:\n            raise TypeError(f\"Invalid kwargs for chain.invoke: {str(e)}\")\n        except Exception as e:\n            raise ValueError(f\"Error during chain invocation: {str(e)}\")\n\n        doc.models.add_output(\"langchain\", self.task, output)\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.LangChainLLM.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process the document using the LangChain chain. Adds outputs to .model_outputs['langchain'].</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"Process the document using the LangChain chain. Adds outputs to .model_outputs['langchain'].\"\"\"\n    try:\n        output = self.chain.invoke(doc.data, **self.kwargs)\n    except TypeError as e:\n        raise TypeError(f\"Invalid kwargs for chain.invoke: {str(e)}\")\n    except Exception as e:\n        raise ValueError(f\"Error during chain invocation: {str(e)}\")\n\n    doc.models.add_output(\"langchain\", self.task, output)\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.LangChainLLM.__init__","title":"<code>__init__(chain, task, **kwargs)</code>","text":"<p>Initialize with a LangChain chain.</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@requires_package(\"langchain-core\", \"langchain_core.runnables\")\ndef __init__(self, chain: Any, task: str, **kwargs: Any):\n    \"\"\"Initialize with a LangChain chain.\"\"\"\n    from langchain_core.runnables import Runnable\n\n    if not isinstance(chain, Runnable):\n        raise TypeError(f\"Expected LangChain Runnable object, got {type(chain)}\")\n\n    self.chain = chain\n    self.task = task\n    self.kwargs = kwargs\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP","title":"<code>SpacyNLP</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <p>A component that integrates spaCy models into the pipeline.</p> <p>This component allows using any spaCy model within the pipeline by loading and applying it to process text documents. The spaCy doc outputs are stored in the document's nlp annotations container under .spacy_docs.</p> PARAMETER DESCRIPTION <code>nlp</code> <p>A pre-configured spaCy Language object.</p> <p> TYPE: <code>Language</code> </p> Example Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>class SpacyNLP(BaseComponent[str]):\n    \"\"\"\n    A component that integrates spaCy models into the pipeline.\n\n    This component allows using any spaCy model within the pipeline by loading\n    and applying it to process text documents. The spaCy doc outputs are stored\n    in the document's nlp annotations container under .spacy_docs.\n\n    Args:\n        nlp: A pre-configured spaCy Language object.\n\n    Example:\n        &gt;&gt;&gt; # Using pre-configured pipeline\n        &gt;&gt;&gt; import spacy\n        &gt;&gt;&gt; nlp = spacy.load(\"en_core_web_sm\", disable=[\"parser\"])\n        &gt;&gt;&gt; component = SpacyNLP(nlp)\n        &gt;&gt;&gt; doc = component(doc)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using model name\n        &gt;&gt;&gt; component = SpacyNLP.from_model_id(\"en_core_web_sm\", disable=[\"parser\"])\n        &gt;&gt;&gt; doc = component(doc)\n    \"\"\"\n\n    def __init__(self, nlp: \"Language\"):\n        \"\"\"Initialize with a pre-configured spaCy Language object.\"\"\"\n        self._nlp = nlp\n\n    @classmethod\n    def from_model_id(cls, model: str, **kwargs: Any) -&gt; \"SpacyNLP\":\n        \"\"\"\n        Create a SpacyNLP component from a model identifier.\n\n        Args:\n            model (str): The name or path of the spaCy model to load.\n                Can be a model name like 'en_core_web_sm' or path to saved model.\n            **kwargs: Additional configuration options passed to spacy.load.\n                Common options include disable, exclude, enable.\n\n        Returns:\n            SpacyNLP: Initialized spaCy component\n\n        Raises:\n            ImportError: If spaCy or the specified model is not installed\n            TypeError: If invalid kwargs are passed to spacy.load\n        \"\"\"\n        try:\n            import spacy\n        except ImportError:\n            raise ImportError(\n                \"Could not import spacy. Please install it with: \" \"`pip install spacy`\"\n            )\n\n        try:\n            nlp = spacy.load(model, **kwargs)\n        except TypeError as e:\n            raise TypeError(f\"Invalid kwargs for spacy.load: {str(e)}\")\n        except Exception as e:\n            raise ImportError(\n                f\"Could not load spaCy model {model}! \"\n                \"Make sure you have installed it with: \"\n                f\"`python -m spacy download {model}`\"\n            ) from e\n\n        return cls(nlp)\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Process the document using the spaCy pipeline. Adds outputs to nlp.spacy_docs.\"\"\"\n        spacy_doc = self._nlp(doc.data)\n        doc.nlp.add_spacy_doc(spacy_doc)\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP--using-pre-configured-pipeline","title":"Using pre-configured pipeline","text":"<p>import spacy nlp = spacy.load(\"en_core_web_sm\", disable=[\"parser\"]) component = SpacyNLP(nlp) doc = component(doc)</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP--or-using-model-name","title":"Or using model name","text":"<p>component = SpacyNLP.from_model_id(\"en_core_web_sm\", disable=[\"parser\"]) doc = component(doc)</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process the document using the spaCy pipeline. Adds outputs to nlp.spacy_docs.</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"Process the document using the spaCy pipeline. Adds outputs to nlp.spacy_docs.\"\"\"\n    spacy_doc = self._nlp(doc.data)\n    doc.nlp.add_spacy_doc(spacy_doc)\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP.__init__","title":"<code>__init__(nlp)</code>","text":"<p>Initialize with a pre-configured spaCy Language object.</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __init__(self, nlp: \"Language\"):\n    \"\"\"Initialize with a pre-configured spaCy Language object.\"\"\"\n    self._nlp = nlp\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP.from_model_id","title":"<code>from_model_id(model, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a SpacyNLP component from a model identifier.</p> PARAMETER DESCRIPTION <code>model</code> <p>The name or path of the spaCy model to load. Can be a model name like 'en_core_web_sm' or path to saved model.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to spacy.load. Common options include disable, exclude, enable.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>SpacyNLP</code> <p>Initialized spaCy component</p> <p> TYPE: <code>SpacyNLP</code> </p> RAISES DESCRIPTION <code>ImportError</code> <p>If spaCy or the specified model is not installed</p> <code>TypeError</code> <p>If invalid kwargs are passed to spacy.load</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@classmethod\ndef from_model_id(cls, model: str, **kwargs: Any) -&gt; \"SpacyNLP\":\n    \"\"\"\n    Create a SpacyNLP component from a model identifier.\n\n    Args:\n        model (str): The name or path of the spaCy model to load.\n            Can be a model name like 'en_core_web_sm' or path to saved model.\n        **kwargs: Additional configuration options passed to spacy.load.\n            Common options include disable, exclude, enable.\n\n    Returns:\n        SpacyNLP: Initialized spaCy component\n\n    Raises:\n        ImportError: If spaCy or the specified model is not installed\n        TypeError: If invalid kwargs are passed to spacy.load\n    \"\"\"\n    try:\n        import spacy\n    except ImportError:\n        raise ImportError(\n            \"Could not import spacy. Please install it with: \" \"`pip install spacy`\"\n        )\n\n    try:\n        nlp = spacy.load(model, **kwargs)\n    except TypeError as e:\n        raise TypeError(f\"Invalid kwargs for spacy.load: {str(e)}\")\n    except Exception as e:\n        raise ImportError(\n            f\"Could not load spaCy model {model}! \"\n            \"Make sure you have installed it with: \"\n            f\"`python -m spacy download {model}`\"\n        ) from e\n\n    return cls(nlp)\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.requires_package","title":"<code>requires_package(package_name, import_path)</code>","text":"<p>Decorator to check if an optional package is available.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Name of the package to install (e.g., 'langchain-core')</p> <p> TYPE: <code>str</code> </p> <code>import_path</code> <p>Import path to check (e.g., 'langchain_core.runnables')</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def requires_package(package_name: str, import_path: str) -&gt; Callable:\n    \"\"\"Decorator to check if an optional package is available.\n\n    Args:\n        package_name: Name of the package to install (e.g., 'langchain-core')\n        import_path: Import path to check (e.g., 'langchain_core.runnables')\n    \"\"\"\n\n    def decorator(func: Callable[..., T]) -&gt; Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -&gt; T:\n            try:\n                __import__(import_path)\n            except ImportError:\n                raise ImportError(\n                    f\"This feature requires {package_name}. \"\n                    f\"Please install it with: `pip install {package_name}`\"\n                )\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor","title":"<code>TextPreProcessor</code>","text":"<p>               Bases: <code>BaseComponent[Document]</code></p> <p>A component for preprocessing text documents.</p> <p>This class applies various cleaning and tokenization steps to a Document object, based on the provided configuration.</p> ATTRIBUTE DESCRIPTION <code>tokenizer</code> <p>The tokenizer to use. Can be \"basic\" or a custom tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".</p> <p> TYPE: <code>Union[str, Callable[[str], List[str]]]</code> </p> <code>lowercase</code> <p>Whether to convert text to lowercase. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>remove_punctuation</code> <p>Whether to remove punctuation. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>standardize_spaces</code> <p>Whether to standardize spaces. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>regex</code> <p>List of regex patterns and replacements. Defaults to an empty list.</p> <p> TYPE: <code>List[Tuple[str, str]]</code> </p> <code>tokenizer_func</code> <p>The tokenization function.</p> <p> TYPE: <code>Callable[[str], List[str]]</code> </p> <code>cleaning_steps</code> <p>List of text cleaning functions.</p> <p> TYPE: <code>List[Callable[[str], str]]</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>class TextPreProcessor(BaseComponent[Document]):\n    \"\"\"\n    A component for preprocessing text documents.\n\n    This class applies various cleaning and tokenization steps to a Document object,\n    based on the provided configuration.\n\n    Attributes:\n        tokenizer (Union[str, Callable[[str], List[str]]]): The tokenizer to use. Can be \"basic\" or a custom\n            tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".\n        lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n        remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n        standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n        regex (List[Tuple[str, str]]): List of regex patterns and replacements. Defaults to an empty list.\n        tokenizer_func (Callable[[str], List[str]]): The tokenization function.\n        cleaning_steps (List[Callable[[str], str]]): List of text cleaning functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        tokenizer: Union[str, Callable[[str], List[str]]] = \"basic\",\n        lowercase: bool = False,\n        remove_punctuation: bool = False,\n        standardize_spaces: bool = False,\n        regex: List[Tuple[str, str]] = None,\n    ):\n        \"\"\"\n        Initialize the TextPreprocessor with the given configuration.\n\n        Args:\n            tokenizer (Union[str, Callable[[str], List[str]]]): The tokenizer to use. Can be \"basic\" or a custom\n                tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".\n            lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n            remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n            standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n            regex (List[Tuple[str, str]], optional): List of regex patterns and replacements. Defaults to None.\n        \"\"\"\n        self.lowercase = lowercase\n        self.remove_punctuation = remove_punctuation\n        self.standardize_spaces = standardize_spaces\n        self.regex = regex or []\n        self.tokenizer = self._get_tokenizer(tokenizer)\n        self.cleaning_steps = self._configure_cleaning_steps()\n\n    def _get_tokenizer(\n        self, tokenizer: Union[str, Callable[[str], List[str]]]\n    ) -&gt; Callable[[str], List[str]]:\n        \"\"\"\n        Get the tokenization function based on the specified tokenizer.\n\n        Args:\n            tokenizer: Either \"basic\" or a custom tokenization function.\n\n        Returns:\n            Callable[[str], List[str]]: The tokenization function.\n\n        Raises:\n            ValueError: If an unsupported tokenizer string is specified.\n        \"\"\"\n        if callable(tokenizer):\n            return tokenizer\n        elif tokenizer == \"basic\":\n            return lambda text: text.split()\n        else:\n            raise ValueError(\n                f\"Unsupported tokenizer: {tokenizer}. Use 'basic' or provide a custom tokenization function.\"\n            )\n\n    def _configure_cleaning_steps(self) -&gt; List[Callable[[str], str]]:\n        \"\"\"\n        Configure the text cleaning steps based on the preprocessor configuration.\n\n        Returns:\n            List[Callable[[str], str]]: List of text cleaning functions.\n        \"\"\"\n        steps = []\n        if self.lowercase:\n            steps.append(lambda text: text.lower())\n\n        regex_steps = []\n        if self.regex:\n            regex_steps.extend(self.regex)\n        else:\n            if self.remove_punctuation:\n                regex_steps.append((r\"[^\\w\\s]\", \"\"))\n            if self.standardize_spaces:\n                regex_steps.append((r\"\\s+\", \" \"))\n\n        for pattern, repl in regex_steps:\n            steps.append(self._create_regex_step(pattern, repl))\n\n        if self.standardize_spaces:\n            steps.append(str.strip)\n\n        return steps\n\n    @staticmethod\n    def _create_regex_step(pattern: str, repl: str) -&gt; Callable[[str], str]:\n        \"\"\"\n        Create a regex-based cleaning step. This can be used in place of other cleaning steps, if required.\n\n        Args:\n            pattern (str): The regex pattern to match.\n            repl (str): The replacement string.\n\n        Returns:\n            Callable[[str], str]: A function that applies the regex substitution.\n        \"\"\"\n        return lambda text: re.sub(pattern, repl, text)\n\n    def _clean_text(self, text: str) -&gt; str:\n        \"\"\"\n        Apply all cleaning steps to the input text.\n\n        Args:\n            text (str): The input text to clean.\n\n        Returns:\n            str: The cleaned text.\n        \"\"\"\n        for step in self.cleaning_steps:\n            text = step(text)\n        return text\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Preprocess the given Document.\n\n        This method applies the configured cleaning steps and tokenization to the document's text (in that order).\n\n        Args:\n            doc (Document): The document to preprocess.\n\n        Returns:\n            Document: The preprocessed document with updated tokens and preprocessed text.\n        \"\"\"\n        # Preprocess text\n        preprocessed_text = self._clean_text(doc.text)\n        doc.preprocessed_text = preprocessed_text\n\n        if self.tokenizer:\n            tokens = self.tokenizer(preprocessed_text)\n            doc.tokens = tokens\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor.__call__","title":"<code>__call__(doc)</code>","text":"<p>Preprocess the given Document.</p> <p>This method applies the configured cleaning steps and tokenization to the document's text (in that order).</p> PARAMETER DESCRIPTION <code>doc</code> <p>The document to preprocess.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The preprocessed document with updated tokens and preprocessed text.</p> <p> TYPE: <code>Document</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Preprocess the given Document.\n\n    This method applies the configured cleaning steps and tokenization to the document's text (in that order).\n\n    Args:\n        doc (Document): The document to preprocess.\n\n    Returns:\n        Document: The preprocessed document with updated tokens and preprocessed text.\n    \"\"\"\n    # Preprocess text\n    preprocessed_text = self._clean_text(doc.text)\n    doc.preprocessed_text = preprocessed_text\n\n    if self.tokenizer:\n        tokens = self.tokenizer(preprocessed_text)\n        doc.tokens = tokens\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor.__init__","title":"<code>__init__(tokenizer='basic', lowercase=False, remove_punctuation=False, standardize_spaces=False, regex=None)</code>","text":"<p>Initialize the TextPreprocessor with the given configuration.</p> PARAMETER DESCRIPTION <code>tokenizer</code> <p>The tokenizer to use. Can be \"basic\" or a custom tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".</p> <p> TYPE: <code>Union[str, Callable[[str], List[str]]]</code> DEFAULT: <code>'basic'</code> </p> <code>lowercase</code> <p>Whether to convert text to lowercase. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>remove_punctuation</code> <p>Whether to remove punctuation. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>standardize_spaces</code> <p>Whether to standardize spaces. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>regex</code> <p>List of regex patterns and replacements. Defaults to None.</p> <p> TYPE: <code>List[Tuple[str, str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: Union[str, Callable[[str], List[str]]] = \"basic\",\n    lowercase: bool = False,\n    remove_punctuation: bool = False,\n    standardize_spaces: bool = False,\n    regex: List[Tuple[str, str]] = None,\n):\n    \"\"\"\n    Initialize the TextPreprocessor with the given configuration.\n\n    Args:\n        tokenizer (Union[str, Callable[[str], List[str]]]): The tokenizer to use. Can be \"basic\" or a custom\n            tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".\n        lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n        remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n        standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n        regex (List[Tuple[str, str]], optional): List of regex patterns and replacements. Defaults to None.\n    \"\"\"\n    self.lowercase = lowercase\n    self.remove_punctuation = remove_punctuation\n    self.standardize_spaces = standardize_spaces\n    self.regex = regex or []\n    self.tokenizer = self._get_tokenizer(tokenizer)\n    self.cleaning_steps = self._configure_cleaning_steps()\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor","title":"<code>TextPostProcessor</code>","text":"<p>               Bases: <code>BaseComponent[Document]</code></p> <p>A component for post-processing text documents, specifically for refining entities.</p> <p>This class applies post-coordination rules to entities in a Document object, replacing entities with their refined versions based on a lookup dictionary.</p> ATTRIBUTE DESCRIPTION <code>entity_lookup</code> <p>A dictionary for entity refinement lookups.</p> <p> TYPE: <code>Dict[str, str]</code> </p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>class TextPostProcessor(BaseComponent[Document]):\n    \"\"\"\n    A component for post-processing text documents, specifically for refining entities.\n\n    This class applies post-coordination rules to entities in a Document object,\n    replacing entities with their refined versions based on a lookup dictionary.\n\n    Attributes:\n        entity_lookup (Dict[str, str]): A dictionary for entity refinement lookups.\n    \"\"\"\n\n    def __init__(self, postcoordination_lookup: Dict[str, str] = None):\n        \"\"\"\n        Initialize the TextPostProcessor with an optional postcoordination lookup.\n\n        Args:\n            postcoordination_lookup (Dict[str, str], optional): A dictionary for entity refinement lookups.\n                If not provided, an empty dictionary will be used.\n        \"\"\"\n        self.entity_lookup = postcoordination_lookup or {}\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Apply post-processing to the given Document.\n\n        This method refines the entities in the document based on the entity_lookup.\n        If an entity exists in the lookup, it is replaced with its refined version.\n\n        Args:\n            doc (Document): The document to be post-processed.\n\n        Returns:\n            Document: The post-processed document with refined entities.\n\n        Note:\n            If the entity_lookup is empty or the document has no 'entities' attribute,\n            the document is returned unchanged.\n        \"\"\"\n        if not self.entity_lookup or not hasattr(doc._nlp, \"_entities\"):\n            return doc\n\n        refined_entities = []\n        for entity in doc.nlp.get_entities():\n            entity_text = entity[\"text\"]\n            if entity_text in self.entity_lookup:\n                entity[\"text\"] = self.entity_lookup[entity_text]\n            refined_entities.append(entity)\n\n        doc.nlp.set_entities(refined_entities)\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor.__call__","title":"<code>__call__(doc)</code>","text":"<p>Apply post-processing to the given Document.</p> <p>This method refines the entities in the document based on the entity_lookup. If an entity exists in the lookup, it is replaced with its refined version.</p> PARAMETER DESCRIPTION <code>doc</code> <p>The document to be post-processed.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The post-processed document with refined entities.</p> <p> TYPE: <code>Document</code> </p> Note <p>If the entity_lookup is empty or the document has no 'entities' attribute, the document is returned unchanged.</p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Apply post-processing to the given Document.\n\n    This method refines the entities in the document based on the entity_lookup.\n    If an entity exists in the lookup, it is replaced with its refined version.\n\n    Args:\n        doc (Document): The document to be post-processed.\n\n    Returns:\n        Document: The post-processed document with refined entities.\n\n    Note:\n        If the entity_lookup is empty or the document has no 'entities' attribute,\n        the document is returned unchanged.\n    \"\"\"\n    if not self.entity_lookup or not hasattr(doc._nlp, \"_entities\"):\n        return doc\n\n    refined_entities = []\n    for entity in doc.nlp.get_entities():\n        entity_text = entity[\"text\"]\n        if entity_text in self.entity_lookup:\n            entity[\"text\"] = self.entity_lookup[entity_text]\n        refined_entities.append(entity)\n\n    doc.nlp.set_entities(refined_entities)\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor.__init__","title":"<code>__init__(postcoordination_lookup=None)</code>","text":"<p>Initialize the TextPostProcessor with an optional postcoordination lookup.</p> PARAMETER DESCRIPTION <code>postcoordination_lookup</code> <p>A dictionary for entity refinement lookups. If not provided, an empty dictionary will be used.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>def __init__(self, postcoordination_lookup: Dict[str, str] = None):\n    \"\"\"\n    Initialize the TextPostProcessor with an optional postcoordination lookup.\n\n    Args:\n        postcoordination_lookup (Dict[str, str], optional): A dictionary for entity refinement lookups.\n            If not provided, an empty dictionary will be used.\n    \"\"\"\n    self.entity_lookup = postcoordination_lookup or {}\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.cdscardcreator.CdsCardCreator","title":"<code>CdsCardCreator</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <pre><code>Component that creates CDS Hooks cards from model outputs or static content.\n\nThis component formats text into CDS Hooks cards that can be displayed in an EHR system.\nIt can create cards from either:\n1. Model-generated text stored in a document's model outputs container\n2. Static content provided during initialization\n\nThe component uses Jinja2 templates to format the text into valid CDS Hooks card JSON.\nThe generated cards are added to the document's CDS container.\n\nArgs:\n    template (str, optional): Jinja2 template string for card creation. If not provided,\n        uses a default template that creates an info card.\n    template_path (Union[str, Path], optional): Path to a Jinja2 template file.\n    static_content (str, optional): Static text to use instead of model output.\n    source (str, optional): Source framework to get model output from (e.g. \"huggingface\").\n    task (str, optional): Task name to get model output from (e.g. \"summarization\").\n    delimiter (str, optional): String to split model output into multiple cards.\n    default_source (Dict[str, Any], optional): Default source info for cards.\n        Defaults to {\"label\": \"Card Generated by HealthChain\"}.\n\nExample:\n    &gt;&gt;&gt; # Create cards from model output\n    &gt;&gt;&gt; creator = CdsCardCreator(source=\"huggingface\", task=\"summarization\")\n    &gt;&gt;&gt; doc = creator(doc)  # Creates cards from model output\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create cards with static content\n    &gt;&gt;&gt; creator = CdsCardCreator(static_content=\"Static card message\")\n    &gt;&gt;&gt; doc = creator(doc)  # Creates card with static content\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create cards with custom template\n    &gt;&gt;&gt; template = '''\n    ... {\n    ...     \"summary\": \"{{ model_output[:140] }}\",\n    ...     \"indicator\": \"info\",\n    ...     \"source\": {{ default_source | tojson }},\n    ...     \"detail\": \"{{ model_output }}\"\n    ... }\n    ... '''\n    &gt;&gt;&gt; creator = CdsCardCreator(\n    ...     template=template,\n    ...     source=\"langchain\",\n    ...     task=\"chat\",\n    ...     delimiter=\"\n</code></pre> <p>\"         ... )         &gt;&gt;&gt; doc = creator(doc)  # Creates cards split by newlines</p> Source code in <code>healthchain/pipeline/components/cdscardcreator.py</code> <pre><code>class CdsCardCreator(BaseComponent[str]):\n    \"\"\"\n    Component that creates CDS Hooks cards from model outputs or static content.\n\n    This component formats text into CDS Hooks cards that can be displayed in an EHR system.\n    It can create cards from either:\n    1. Model-generated text stored in a document's model outputs container\n    2. Static content provided during initialization\n\n    The component uses Jinja2 templates to format the text into valid CDS Hooks card JSON.\n    The generated cards are added to the document's CDS container.\n\n    Args:\n        template (str, optional): Jinja2 template string for card creation. If not provided,\n            uses a default template that creates an info card.\n        template_path (Union[str, Path], optional): Path to a Jinja2 template file.\n        static_content (str, optional): Static text to use instead of model output.\n        source (str, optional): Source framework to get model output from (e.g. \"huggingface\").\n        task (str, optional): Task name to get model output from (e.g. \"summarization\").\n        delimiter (str, optional): String to split model output into multiple cards.\n        default_source (Dict[str, Any], optional): Default source info for cards.\n            Defaults to {\"label\": \"Card Generated by HealthChain\"}.\n\n    Example:\n        &gt;&gt;&gt; # Create cards from model output\n        &gt;&gt;&gt; creator = CdsCardCreator(source=\"huggingface\", task=\"summarization\")\n        &gt;&gt;&gt; doc = creator(doc)  # Creates cards from model output\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create cards with static content\n        &gt;&gt;&gt; creator = CdsCardCreator(static_content=\"Static card message\")\n        &gt;&gt;&gt; doc = creator(doc)  # Creates card with static content\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create cards with custom template\n        &gt;&gt;&gt; template = '''\n        ... {\n        ...     \"summary\": \"{{ model_output[:140] }}\",\n        ...     \"indicator\": \"info\",\n        ...     \"source\": {{ default_source | tojson }},\n        ...     \"detail\": \"{{ model_output }}\"\n        ... }\n        ... '''\n        &gt;&gt;&gt; creator = CdsCardCreator(\n        ...     template=template,\n        ...     source=\"langchain\",\n        ...     task=\"chat\",\n        ...     delimiter=\"\\n\"\n        ... )\n        &gt;&gt;&gt; doc = creator(doc)  # Creates cards split by newlines\n    \"\"\"\n\n    # TODO: make source and other fields configurable from model too\n    DEFAULT_TEMPLATE = \"\"\"\n    {\n        \"summary\": \"{{ model_output[:140] }}\",\n        \"indicator\": \"info\",\n        \"source\": {{ default_source | tojson }},\n        \"detail\": \"{{ model_output }}\"\n    }\n    \"\"\"\n\n    def __init__(\n        self,\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        static_content: Optional[str] = None,\n        source: Optional[str] = None,\n        task: Optional[str] = None,\n        delimiter: Optional[str] = None,\n        default_source: Optional[Dict[str, Any]] = None,\n    ):\n        # Load template from file or use string template\n        if template_path:\n            try:\n                template_path = Path(template_path)\n                if not template_path.exists():\n                    raise FileNotFoundError(f\"Template file not found: {template_path}\")\n                with open(template_path) as f:\n                    template = f.read()\n            except Exception as e:\n                logger.error(f\"Error loading template from {template_path}: {str(e)}\")\n                template = self.DEFAULT_TEMPLATE\n\n        self.template = Template(\n            template if template is not None else self.DEFAULT_TEMPLATE\n        )\n        self.static_content = static_content\n        self.source = source\n        self.task = task\n        self.delimiter = delimiter\n        self.default_source = default_source or {\n            \"label\": \"Card Generated by HealthChain\"\n        }\n\n    def create_card(self, content: str) -&gt; Card:\n        \"\"\"Creates a CDS Card using the template and model output.\"\"\"\n        try:\n            # Clean and escape the content\n            # TODO: format to html that can be rendered in card\n            content = content.replace(\"\\n\", \" \").replace(\"\\r\", \" \").strip()\n            content = content.replace('\"', '\\\\\"')  # Escape double quotes\n\n            try:\n                card_json = self.template.render(\n                    model_output=content, default_source=self.default_source\n                )\n            except Exception as e:\n                raise ValueError(f\"Error rendering template: {str(e)}\")\n\n            # Parse the rendered JSON into card fields\n            card_fields = json.loads(card_json)\n\n            return Card(\n                summary=card_fields[\"summary\"][:140],  # Enforce max length\n                indicator=IndicatorEnum(card_fields[\"indicator\"]),\n                source=Source(**card_fields[\"source\"]),\n                detail=card_fields.get(\"detail\"),\n                suggestions=card_fields.get(\"suggestions\"),\n                selectionBehavior=card_fields.get(\"selectionBehavior\"),\n                overrideReasons=card_fields.get(\"overrideReasons\"),\n                links=card_fields.get(\"links\"),\n            )\n        except Exception as e:\n            raise ValueError(\n                f\"Error creating CDS card: Failed to render template or parse card fields: {str(e)}\"\n            )\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Process a document and create CDS Hooks cards from model outputs or static content.\n\n        Creates cards in one of two ways:\n        1. From model-generated text stored in the document's model outputs container,\n           accessed using the configured source and task\n        2. From static content provided during initialization\n\n        The generated text can optionally be split into multiple cards using a delimiter.\n        Each piece of text is formatted using the configured template into a CDS Hooks card\n        and added to the document's CDS container.\n\n        Args:\n            doc (Document): Document containing model outputs and CDS container\n\n        Returns:\n            Document: The input document with generated CDS cards added to its CDS container\n\n        Raises:\n            ValueError: If neither model configuration (source and task) nor static content\n                is provided for card creation\n        \"\"\"\n        if self.source and self.task:\n            generated_text = doc.models.get_generated_text(self.source, self.task)\n            if not generated_text:\n                logger.warning(\n                    f\"No generated text for {self.source}/{self.task} found for CDS card creation!\"\n                )\n                return doc\n        elif self.static_content:\n            generated_text = [self.static_content]\n        else:\n            raise ValueError(\n                \"Either model output (source and task) or content need to be provided for CDS card creation!\"\n            )\n\n        # Create card from model output\n        cards = []\n        for text in generated_text:\n            texts = [text] if not self.delimiter else text.split(self.delimiter)\n            for t in texts:\n                try:\n                    cards.append(self.create_card(t))\n                except Exception as e:\n                    logger.warning(f\"Error creating card: {str(e)}\")\n\n        if cards:\n            doc.cds.cards = cards\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.cdscardcreator.CdsCardCreator.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process a document and create CDS Hooks cards from model outputs or static content.</p> <p>Creates cards in one of two ways: 1. From model-generated text stored in the document's model outputs container,    accessed using the configured source and task 2. From static content provided during initialization</p> <p>The generated text can optionally be split into multiple cards using a delimiter. Each piece of text is formatted using the configured template into a CDS Hooks card and added to the document's CDS container.</p> PARAMETER DESCRIPTION <code>doc</code> <p>Document containing model outputs and CDS container</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The input document with generated CDS cards added to its CDS container</p> <p> TYPE: <code>Document</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither model configuration (source and task) nor static content is provided for card creation</p> Source code in <code>healthchain/pipeline/components/cdscardcreator.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Process a document and create CDS Hooks cards from model outputs or static content.\n\n    Creates cards in one of two ways:\n    1. From model-generated text stored in the document's model outputs container,\n       accessed using the configured source and task\n    2. From static content provided during initialization\n\n    The generated text can optionally be split into multiple cards using a delimiter.\n    Each piece of text is formatted using the configured template into a CDS Hooks card\n    and added to the document's CDS container.\n\n    Args:\n        doc (Document): Document containing model outputs and CDS container\n\n    Returns:\n        Document: The input document with generated CDS cards added to its CDS container\n\n    Raises:\n        ValueError: If neither model configuration (source and task) nor static content\n            is provided for card creation\n    \"\"\"\n    if self.source and self.task:\n        generated_text = doc.models.get_generated_text(self.source, self.task)\n        if not generated_text:\n            logger.warning(\n                f\"No generated text for {self.source}/{self.task} found for CDS card creation!\"\n            )\n            return doc\n    elif self.static_content:\n        generated_text = [self.static_content]\n    else:\n        raise ValueError(\n            \"Either model output (source and task) or content need to be provided for CDS card creation!\"\n        )\n\n    # Create card from model output\n    cards = []\n    for text in generated_text:\n        texts = [text] if not self.delimiter else text.split(self.delimiter)\n        for t in texts:\n            try:\n                cards.append(self.create_card(t))\n            except Exception as e:\n                logger.warning(f\"Error creating card: {str(e)}\")\n\n    if cards:\n        doc.cds.cards = cards\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.cdscardcreator.CdsCardCreator.create_card","title":"<code>create_card(content)</code>","text":"<p>Creates a CDS Card using the template and model output.</p> Source code in <code>healthchain/pipeline/components/cdscardcreator.py</code> <pre><code>def create_card(self, content: str) -&gt; Card:\n    \"\"\"Creates a CDS Card using the template and model output.\"\"\"\n    try:\n        # Clean and escape the content\n        # TODO: format to html that can be rendered in card\n        content = content.replace(\"\\n\", \" \").replace(\"\\r\", \" \").strip()\n        content = content.replace('\"', '\\\\\"')  # Escape double quotes\n\n        try:\n            card_json = self.template.render(\n                model_output=content, default_source=self.default_source\n            )\n        except Exception as e:\n            raise ValueError(f\"Error rendering template: {str(e)}\")\n\n        # Parse the rendered JSON into card fields\n        card_fields = json.loads(card_json)\n\n        return Card(\n            summary=card_fields[\"summary\"][:140],  # Enforce max length\n            indicator=IndicatorEnum(card_fields[\"indicator\"]),\n            source=Source(**card_fields[\"source\"]),\n            detail=card_fields.get(\"detail\"),\n            suggestions=card_fields.get(\"suggestions\"),\n            selectionBehavior=card_fields.get(\"selectionBehavior\"),\n            overrideReasons=card_fields.get(\"overrideReasons\"),\n            links=card_fields.get(\"links\"),\n        )\n    except Exception as e:\n        raise ValueError(\n            f\"Error creating CDS card: Failed to render template or parse card fields: {str(e)}\"\n        )\n</code></pre>"},{"location":"api/connectors/","title":"Connectors","text":""},{"location":"api/connectors/#healthchain.io.base.BaseConnector","title":"<code>BaseConnector</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for all connectors in the pipeline.</p> <p>This class should be subclassed to create specific connectors. Subclasses must implement the input and output methods.</p> Source code in <code>healthchain/io/base.py</code> <pre><code>class BaseConnector(Generic[T], ABC):\n    \"\"\"\n    Abstract base class for all connectors in the pipeline.\n\n    This class should be subclassed to create specific connectors.\n    Subclasses must implement the input and output methods.\n    \"\"\"\n\n    @abstractmethod\n    def input(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        \"\"\"\n        Convert input data to the pipeline's internal format.\n\n        Args:\n            data (DataContainer[T]): The input data to be converted.\n\n        Returns:\n            DataContainer[T]: The converted data.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def output(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        \"\"\"\n        Convert pipeline's internal format to output data.\n\n        Args:\n            data (DataContainer[T]): The data to be converted for output.\n\n        Returns:\n            DataContainer[T]: The converted output data.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/connectors/#healthchain.io.base.BaseConnector.input","title":"<code>input(data)</code>  <code>abstractmethod</code>","text":"<p>Convert input data to the pipeline's internal format.</p> PARAMETER DESCRIPTION <code>data</code> <p>The input data to be converted.</p> <p> TYPE: <code>DataContainer[T]</code> </p> RETURNS DESCRIPTION <code>DataContainer[T]</code> <p>DataContainer[T]: The converted data.</p> Source code in <code>healthchain/io/base.py</code> <pre><code>@abstractmethod\ndef input(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n    \"\"\"\n    Convert input data to the pipeline's internal format.\n\n    Args:\n        data (DataContainer[T]): The input data to be converted.\n\n    Returns:\n        DataContainer[T]: The converted data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/connectors/#healthchain.io.base.BaseConnector.output","title":"<code>output(data)</code>  <code>abstractmethod</code>","text":"<p>Convert pipeline's internal format to output data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be converted for output.</p> <p> TYPE: <code>DataContainer[T]</code> </p> RETURNS DESCRIPTION <code>DataContainer[T]</code> <p>DataContainer[T]: The converted output data.</p> Source code in <code>healthchain/io/base.py</code> <pre><code>@abstractmethod\ndef output(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n    \"\"\"\n    Convert pipeline's internal format to output data.\n\n    Args:\n        data (DataContainer[T]): The data to be converted for output.\n\n    Returns:\n        DataContainer[T]: The converted output data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdaconnector.CdaConnector","title":"<code>CdaConnector</code>","text":"<p>               Bases: <code>BaseConnector</code></p> <p>CDAConnector class for handling CDA (Clinical Document Architecture) documents.</p> <p>This connector is responsible for parsing CDA documents, extracting relevant clinical data, and updating the document with new information. It serves as both an input and output connector in the pipeline.</p> ATTRIBUTE DESCRIPTION <code>overwrite</code> <p>Flag to determine if existing data should be overwritten               when updating the CDA document.</p> <p> TYPE: <code>bool</code> </p> <code>cda_doc</code> <p>The parsed CDA document.</p> <p> TYPE: <code>CdaAnnotator</code> </p> METHOD DESCRIPTION <code>input</code> <p>Parses the input CDA document and extracts clinical data.</p> <code>output</code> <p>Updates the CDA document with new data and returns the response.</p> Source code in <code>healthchain/io/cdaconnector.py</code> <pre><code>class CdaConnector(BaseConnector):\n    \"\"\"\n    CDAConnector class for handling CDA (Clinical Document Architecture) documents.\n\n    This connector is responsible for parsing CDA documents, extracting relevant\n    clinical data, and updating the document with new information. It serves as\n    both an input and output connector in the pipeline.\n\n    Attributes:\n        overwrite (bool): Flag to determine if existing data should be overwritten\n                          when updating the CDA document.\n        cda_doc (CdaAnnotator): The parsed CDA document.\n\n    Methods:\n        input: Parses the input CDA document and extracts clinical data.\n        output: Updates the CDA document with new data and returns the response.\n    \"\"\"\n\n    def __init__(self, overwrite: bool = False):\n        self.overwrite = overwrite\n        self.cda_doc = None\n\n    def input(self, cda_request: CdaRequest) -&gt; Document:\n        \"\"\"\n        Parse the input CDA document and extract clinical data into a HealthChain Document object.\n\n        This method takes a CdaRequest object as input, parses it, and extracts clinical data into a\n        FHIR Bundle. It creates two DocumentReference resources:\n        1. The original CDA XML document\n        2. The extracted note text from the CDA document\n\n        The note text document is linked to the original CDA document through a relationship.\n        Continuity of Care Document data (problems, medications, allergies) are also extracted into FHIR resources\n        and added to the bundle.\n\n        Args:\n            cda_request (CdaRequest): Request object containing the CDA XML document to process.\n\n        Returns:\n            Document: A Document object containing:\n                - The extracted note text as the document data\n                - A FHIR Bundle with:\n                    - DocumentReference for the original CDA XML\n                    - DocumentReference for the extracted note text\n                    - Extracted clinical data as FHIR resources (Condition,\n                      MedicationStatement, AllergyIntolerance)\n\n        Note:\n            The note text is extracted from the CDA document's note section. If the note\n            is a dictionary of sections, they are joined with spaces. If no valid note\n            is found, an empty string is used.\n        \"\"\"\n        self.cda_doc = CdaAnnotator.from_xml(cda_request.document)\n\n        # Create a FHIR DocumentReference for the original CDA document\n        cda_document_reference = create_document_reference(\n            data=cda_request.document,\n            content_type=\"text/xml\",\n            description=\"Original CDA Document processed by HealthChain\",\n            attachment_title=\"Original CDA document in XML format\",\n        )\n\n        # TODO: Temporary fix for the note section, this might be more of a concern for the Annotator class\n        if isinstance(self.cda_doc.note, dict):\n            note_text = \" \".join(str(value) for value in self.cda_doc.note.values())\n        elif isinstance(self.cda_doc.note, str):\n            note_text = self.cda_doc.note\n        else:\n            log.warning(\"Note section is not a string or dictionary\")\n            note_text = \"\"\n\n        # Create a FHIR DocumentReference for the note text\n        note_document_reference = create_document_reference(\n            data=note_text,\n            content_type=\"text/plain\",\n            description=\"Text from note section of related CDA document extracted by HealthChain\",\n            attachment_title=\"Note text from the related CDA document\",\n        )\n\n        doc = Document(data=note_text)\n\n        # Create FHIR Bundle and add documents\n        doc.fhir.bundle = create_bundle()\n        doc.fhir.add_document_reference(cda_document_reference)\n        doc.fhir.add_document_reference(\n            note_document_reference, parent_id=cda_document_reference.id\n        )\n\n        # Set lists with the correct FHIR resources\n        doc.fhir.problem_list = self.cda_doc.problem_list\n        doc.fhir.medication_list = self.cda_doc.medication_list\n        doc.fhir.allergy_list = self.cda_doc.allergy_list\n\n        # Set the category for each problem in the problem list\n        for condition in doc.fhir.problem_list:\n            set_problem_list_item_category(condition)\n\n        return doc\n\n    def output(self, document: Document) -&gt; CdaResponse:\n        \"\"\"\n        Update the CDA document with new data and return the response.\n\n        This method takes a Document object containing updated clinical data,\n        updates the CDA document with this new information, and returns a\n        CdaResponse object with the updated CDA document.\n\n        Args:\n            document (Document): A Document object containing the updated\n                                 clinical data (problems, allergies, medications).\n\n        Returns:\n            CdaResponse: A response object containing the updated CDA document.\n\n        Note:\n            The method updates the CDA document with new problems, allergies,\n            and medications if they are present in the input Document object.\n            The update behavior (overwrite or append) is determined by the\n            `overwrite` attribute of the CdaConnector instance.\n        \"\"\"\n        # Update the CDA document with the results from FHIR Bundle\n        if document.fhir.problem_list:\n            log.debug(\n                f\"Updating CDA document with {len(document.fhir.problem_list)} problem(s).\"\n            )\n            self.cda_doc.add_to_problem_list(\n                document.fhir.problem_list, overwrite=self.overwrite\n            )\n\n        # Update allergies\n        if document.fhir.allergy_list:\n            log.debug(\n                f\"Updating CDA document with {len(document.fhir.allergy_list)} allergy(ies).\"\n            )\n            self.cda_doc.add_to_allergy_list(\n                document.fhir.allergy_list, overwrite=self.overwrite\n            )\n\n        # Update medications\n        if document.fhir.medication_list:\n            log.debug(\n                f\"Updating CDA document with {len(document.fhir.medication_list)} medication(s).\"\n            )\n            self.cda_doc.add_to_medication_list(\n                document.fhir.medication_list, overwrite=self.overwrite\n            )\n\n        # Export the updated CDA document\n        response_document = self.cda_doc.export()\n\n        return CdaResponse(document=response_document)\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdaconnector.CdaConnector.input","title":"<code>input(cda_request)</code>","text":"<p>Parse the input CDA document and extract clinical data into a HealthChain Document object.</p> <p>This method takes a CdaRequest object as input, parses it, and extracts clinical data into a FHIR Bundle. It creates two DocumentReference resources: 1. The original CDA XML document 2. The extracted note text from the CDA document</p> <p>The note text document is linked to the original CDA document through a relationship. Continuity of Care Document data (problems, medications, allergies) are also extracted into FHIR resources and added to the bundle.</p> PARAMETER DESCRIPTION <code>cda_request</code> <p>Request object containing the CDA XML document to process.</p> <p> TYPE: <code>CdaRequest</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>A Document object containing: - The extracted note text as the document data - A FHIR Bundle with:     - DocumentReference for the original CDA XML     - DocumentReference for the extracted note text     - Extracted clinical data as FHIR resources (Condition,       MedicationStatement, AllergyIntolerance)</p> <p> TYPE: <code>Document</code> </p> Note <p>The note text is extracted from the CDA document's note section. If the note is a dictionary of sections, they are joined with spaces. If no valid note is found, an empty string is used.</p> Source code in <code>healthchain/io/cdaconnector.py</code> <pre><code>def input(self, cda_request: CdaRequest) -&gt; Document:\n    \"\"\"\n    Parse the input CDA document and extract clinical data into a HealthChain Document object.\n\n    This method takes a CdaRequest object as input, parses it, and extracts clinical data into a\n    FHIR Bundle. It creates two DocumentReference resources:\n    1. The original CDA XML document\n    2. The extracted note text from the CDA document\n\n    The note text document is linked to the original CDA document through a relationship.\n    Continuity of Care Document data (problems, medications, allergies) are also extracted into FHIR resources\n    and added to the bundle.\n\n    Args:\n        cda_request (CdaRequest): Request object containing the CDA XML document to process.\n\n    Returns:\n        Document: A Document object containing:\n            - The extracted note text as the document data\n            - A FHIR Bundle with:\n                - DocumentReference for the original CDA XML\n                - DocumentReference for the extracted note text\n                - Extracted clinical data as FHIR resources (Condition,\n                  MedicationStatement, AllergyIntolerance)\n\n    Note:\n        The note text is extracted from the CDA document's note section. If the note\n        is a dictionary of sections, they are joined with spaces. If no valid note\n        is found, an empty string is used.\n    \"\"\"\n    self.cda_doc = CdaAnnotator.from_xml(cda_request.document)\n\n    # Create a FHIR DocumentReference for the original CDA document\n    cda_document_reference = create_document_reference(\n        data=cda_request.document,\n        content_type=\"text/xml\",\n        description=\"Original CDA Document processed by HealthChain\",\n        attachment_title=\"Original CDA document in XML format\",\n    )\n\n    # TODO: Temporary fix for the note section, this might be more of a concern for the Annotator class\n    if isinstance(self.cda_doc.note, dict):\n        note_text = \" \".join(str(value) for value in self.cda_doc.note.values())\n    elif isinstance(self.cda_doc.note, str):\n        note_text = self.cda_doc.note\n    else:\n        log.warning(\"Note section is not a string or dictionary\")\n        note_text = \"\"\n\n    # Create a FHIR DocumentReference for the note text\n    note_document_reference = create_document_reference(\n        data=note_text,\n        content_type=\"text/plain\",\n        description=\"Text from note section of related CDA document extracted by HealthChain\",\n        attachment_title=\"Note text from the related CDA document\",\n    )\n\n    doc = Document(data=note_text)\n\n    # Create FHIR Bundle and add documents\n    doc.fhir.bundle = create_bundle()\n    doc.fhir.add_document_reference(cda_document_reference)\n    doc.fhir.add_document_reference(\n        note_document_reference, parent_id=cda_document_reference.id\n    )\n\n    # Set lists with the correct FHIR resources\n    doc.fhir.problem_list = self.cda_doc.problem_list\n    doc.fhir.medication_list = self.cda_doc.medication_list\n    doc.fhir.allergy_list = self.cda_doc.allergy_list\n\n    # Set the category for each problem in the problem list\n    for condition in doc.fhir.problem_list:\n        set_problem_list_item_category(condition)\n\n    return doc\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdaconnector.CdaConnector.output","title":"<code>output(document)</code>","text":"<p>Update the CDA document with new data and return the response.</p> <p>This method takes a Document object containing updated clinical data, updates the CDA document with this new information, and returns a CdaResponse object with the updated CDA document.</p> PARAMETER DESCRIPTION <code>document</code> <p>A Document object containing the updated                  clinical data (problems, allergies, medications).</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>CdaResponse</code> <p>A response object containing the updated CDA document.</p> <p> TYPE: <code>CdaResponse</code> </p> Note <p>The method updates the CDA document with new problems, allergies, and medications if they are present in the input Document object. The update behavior (overwrite or append) is determined by the <code>overwrite</code> attribute of the CdaConnector instance.</p> Source code in <code>healthchain/io/cdaconnector.py</code> <pre><code>def output(self, document: Document) -&gt; CdaResponse:\n    \"\"\"\n    Update the CDA document with new data and return the response.\n\n    This method takes a Document object containing updated clinical data,\n    updates the CDA document with this new information, and returns a\n    CdaResponse object with the updated CDA document.\n\n    Args:\n        document (Document): A Document object containing the updated\n                             clinical data (problems, allergies, medications).\n\n    Returns:\n        CdaResponse: A response object containing the updated CDA document.\n\n    Note:\n        The method updates the CDA document with new problems, allergies,\n        and medications if they are present in the input Document object.\n        The update behavior (overwrite or append) is determined by the\n        `overwrite` attribute of the CdaConnector instance.\n    \"\"\"\n    # Update the CDA document with the results from FHIR Bundle\n    if document.fhir.problem_list:\n        log.debug(\n            f\"Updating CDA document with {len(document.fhir.problem_list)} problem(s).\"\n        )\n        self.cda_doc.add_to_problem_list(\n            document.fhir.problem_list, overwrite=self.overwrite\n        )\n\n    # Update allergies\n    if document.fhir.allergy_list:\n        log.debug(\n            f\"Updating CDA document with {len(document.fhir.allergy_list)} allergy(ies).\"\n        )\n        self.cda_doc.add_to_allergy_list(\n            document.fhir.allergy_list, overwrite=self.overwrite\n        )\n\n    # Update medications\n    if document.fhir.medication_list:\n        log.debug(\n            f\"Updating CDA document with {len(document.fhir.medication_list)} medication(s).\"\n        )\n        self.cda_doc.add_to_medication_list(\n            document.fhir.medication_list, overwrite=self.overwrite\n        )\n\n    # Export the updated CDA document\n    response_document = self.cda_doc.export()\n\n    return CdaResponse(document=response_document)\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdsfhirconnector.CdsFhirConnector","title":"<code>CdsFhirConnector</code>","text":"<p>               Bases: <code>BaseConnector</code></p> <p>CdsFhirConnector class for handling FHIR (Fast Healthcare Interoperability Resources) documents for CDS Hooks.</p> <p>This connector facilitates the conversion between CDSRequest objects and Document objects, as well as the creation of CDSResponse objects from processed Documents.</p> ATTRIBUTE DESCRIPTION <code>hook_name</code> <p>The name of the CDS Hook being used.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/io/cdsfhirconnector.py</code> <pre><code>class CdsFhirConnector(BaseConnector):\n    \"\"\"\n    CdsFhirConnector class for handling FHIR (Fast Healthcare Interoperability Resources) documents\n    for CDS Hooks.\n\n    This connector facilitates the conversion between CDSRequest objects and Document objects,\n    as well as the creation of CDSResponse objects from processed Documents.\n\n    Attributes:\n        hook_name (str): The name of the CDS Hook being used.\n    \"\"\"\n\n    def __init__(self, hook_name: str):\n        self.hook_name = hook_name\n\n    def input(\n        self, cds_request: CDSRequest, prefetch_document_key: Optional[str] = \"document\"\n    ) -&gt; Document:\n        \"\"\"\n        Converts a CDSRequest object into a Document object.\n\n        Takes a CDSRequest containing FHIR resources and extracts them into a Document object.\n        The Document will contain all prefetched FHIR resources in its fhir.prefetch_resources.\n        If a DocumentReference resource is provided via prefetch_document_key, its text content\n        will be extracted into Document.data. For multiple attachments, the text content will be\n        concatenated with newlines.\n\n        Args:\n            cds_request (CDSRequest): The CDSRequest containing FHIR resources in its prefetch\n                and/or a FHIR server URL.\n            prefetch_document_key (str, optional): Key in the prefetch data containing a\n                DocumentReference resource whose text content should be extracted.\n                Defaults to \"document\".\n\n        Returns:\n            Document: A Document object containing:\n                - All prefetched FHIR resources in fhir.prefetch_resources\n                - Any text content from the DocumentReference in data (empty string if none found)\n                - For multiple attachments, text content is concatenated with newlines\n\n        Raises:\n            ValueError: If neither prefetch nor fhirServer is provided in cds_request\n            ValueError: If the prefetch data is invalid or cannot be processed\n            NotImplementedError: If fhirServer is provided (FHIR server support not implemented)\n        \"\"\"\n        if cds_request.prefetch is None and cds_request.fhirServer is None:\n            raise ValueError(\n                \"Either prefetch or fhirServer must be provided to extract FHIR data!\"\n            )\n\n        if cds_request.fhirServer is not None:\n            raise NotImplementedError(\"FHIR server is not implemented yet!\")\n\n        # Create an empty Document object\n        doc = Document(data=\"\")\n\n        # Validate the prefetch data\n        validated_prefetch = Prefetch(prefetch=cds_request.prefetch)\n\n        # Set the prefetch resources\n        doc.fhir.prefetch_resources = validated_prefetch.prefetch\n\n        # Extract text content from DocumentReference resource if provided\n        document_resource = validated_prefetch.prefetch.get(prefetch_document_key)\n\n        if not document_resource:\n            log.warning(\n                f\"No DocumentReference resource found in prefetch data with key {prefetch_document_key}\"\n            )\n        elif isinstance(document_resource, DocumentReference):\n            try:\n                attachments = read_content_attachment(\n                    document_resource, include_data=True\n                )\n                for attachment in attachments:\n                    if len(attachments) &gt; 1:\n                        doc.data += attachment.get(\"data\", \"\") + \"\\n\"\n                    else:\n                        doc.data += attachment.get(\"data\", \"\")\n            except Exception as e:\n                log.warning(f\"Error extracting text from DocumentReference: {e}\")\n\n        return doc\n\n    def output(self, document: Document) -&gt; CDSResponse:\n        \"\"\"\n        Convert Document to CDSResponse.\n\n        This method takes a Document object containing CDS cards and actions,\n        and converts them into a CDSResponse object that follows the CDS Hooks\n        specification.\n\n        Args:\n            document (Document): The Document object containing CDS results.\n\n        Returns:\n            CDSResponse: A response object containing CDS cards and optional system actions.\n                         If no cards are found in the Document, an empty list of cards is returned.\n        \"\"\"\n        if document.cds.cards is None:\n            log.warning(\"No CDS cards found in Document, returning empty list of cards\")\n            return CDSResponse(cards=[])\n\n        return CDSResponse(cards=document.cds.cards, systemActions=document.cds.actions)\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdsfhirconnector.CdsFhirConnector.input","title":"<code>input(cds_request, prefetch_document_key='document')</code>","text":"<p>Converts a CDSRequest object into a Document object.</p> <p>Takes a CDSRequest containing FHIR resources and extracts them into a Document object. The Document will contain all prefetched FHIR resources in its fhir.prefetch_resources. If a DocumentReference resource is provided via prefetch_document_key, its text content will be extracted into Document.data. For multiple attachments, the text content will be concatenated with newlines.</p> PARAMETER DESCRIPTION <code>cds_request</code> <p>The CDSRequest containing FHIR resources in its prefetch and/or a FHIR server URL.</p> <p> TYPE: <code>CDSRequest</code> </p> <code>prefetch_document_key</code> <p>Key in the prefetch data containing a DocumentReference resource whose text content should be extracted. Defaults to \"document\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'document'</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>A Document object containing: - All prefetched FHIR resources in fhir.prefetch_resources - Any text content from the DocumentReference in data (empty string if none found) - For multiple attachments, text content is concatenated with newlines</p> <p> TYPE: <code>Document</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither prefetch nor fhirServer is provided in cds_request</p> <code>ValueError</code> <p>If the prefetch data is invalid or cannot be processed</p> <code>NotImplementedError</code> <p>If fhirServer is provided (FHIR server support not implemented)</p> Source code in <code>healthchain/io/cdsfhirconnector.py</code> <pre><code>def input(\n    self, cds_request: CDSRequest, prefetch_document_key: Optional[str] = \"document\"\n) -&gt; Document:\n    \"\"\"\n    Converts a CDSRequest object into a Document object.\n\n    Takes a CDSRequest containing FHIR resources and extracts them into a Document object.\n    The Document will contain all prefetched FHIR resources in its fhir.prefetch_resources.\n    If a DocumentReference resource is provided via prefetch_document_key, its text content\n    will be extracted into Document.data. For multiple attachments, the text content will be\n    concatenated with newlines.\n\n    Args:\n        cds_request (CDSRequest): The CDSRequest containing FHIR resources in its prefetch\n            and/or a FHIR server URL.\n        prefetch_document_key (str, optional): Key in the prefetch data containing a\n            DocumentReference resource whose text content should be extracted.\n            Defaults to \"document\".\n\n    Returns:\n        Document: A Document object containing:\n            - All prefetched FHIR resources in fhir.prefetch_resources\n            - Any text content from the DocumentReference in data (empty string if none found)\n            - For multiple attachments, text content is concatenated with newlines\n\n    Raises:\n        ValueError: If neither prefetch nor fhirServer is provided in cds_request\n        ValueError: If the prefetch data is invalid or cannot be processed\n        NotImplementedError: If fhirServer is provided (FHIR server support not implemented)\n    \"\"\"\n    if cds_request.prefetch is None and cds_request.fhirServer is None:\n        raise ValueError(\n            \"Either prefetch or fhirServer must be provided to extract FHIR data!\"\n        )\n\n    if cds_request.fhirServer is not None:\n        raise NotImplementedError(\"FHIR server is not implemented yet!\")\n\n    # Create an empty Document object\n    doc = Document(data=\"\")\n\n    # Validate the prefetch data\n    validated_prefetch = Prefetch(prefetch=cds_request.prefetch)\n\n    # Set the prefetch resources\n    doc.fhir.prefetch_resources = validated_prefetch.prefetch\n\n    # Extract text content from DocumentReference resource if provided\n    document_resource = validated_prefetch.prefetch.get(prefetch_document_key)\n\n    if not document_resource:\n        log.warning(\n            f\"No DocumentReference resource found in prefetch data with key {prefetch_document_key}\"\n        )\n    elif isinstance(document_resource, DocumentReference):\n        try:\n            attachments = read_content_attachment(\n                document_resource, include_data=True\n            )\n            for attachment in attachments:\n                if len(attachments) &gt; 1:\n                    doc.data += attachment.get(\"data\", \"\") + \"\\n\"\n                else:\n                    doc.data += attachment.get(\"data\", \"\")\n        except Exception as e:\n            log.warning(f\"Error extracting text from DocumentReference: {e}\")\n\n    return doc\n</code></pre>"},{"location":"api/connectors/#healthchain.io.cdsfhirconnector.CdsFhirConnector.output","title":"<code>output(document)</code>","text":"<p>Convert Document to CDSResponse.</p> <p>This method takes a Document object containing CDS cards and actions, and converts them into a CDSResponse object that follows the CDS Hooks specification.</p> PARAMETER DESCRIPTION <code>document</code> <p>The Document object containing CDS results.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>CDSResponse</code> <p>A response object containing CDS cards and optional system actions.          If no cards are found in the Document, an empty list of cards is returned.</p> <p> TYPE: <code>CDSResponse</code> </p> Source code in <code>healthchain/io/cdsfhirconnector.py</code> <pre><code>def output(self, document: Document) -&gt; CDSResponse:\n    \"\"\"\n    Convert Document to CDSResponse.\n\n    This method takes a Document object containing CDS cards and actions,\n    and converts them into a CDSResponse object that follows the CDS Hooks\n    specification.\n\n    Args:\n        document (Document): The Document object containing CDS results.\n\n    Returns:\n        CDSResponse: A response object containing CDS cards and optional system actions.\n                     If no cards are found in the Document, an empty list of cards is returned.\n    \"\"\"\n    if document.cds.cards is None:\n        log.warning(\"No CDS cards found in Document, returning empty list of cards\")\n        return CDSResponse(cards=[])\n\n    return CDSResponse(cards=document.cds.cards, systemActions=document.cds.actions)\n</code></pre>"},{"location":"api/containers/","title":"Containers","text":""},{"location":"api/containers/#healthchain.io.containers.BaseDocument","title":"<code>BaseDocument</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[str]</code></p> <p>Base document container for raw text content.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass BaseDocument(DataContainer[str]):\n    \"\"\"Base document container for raw text content.\"\"\"\n\n    data: str\n    text: str = field(init=False)\n\n    def __post_init__(self):\n        self.text = self.data\n\n    def char_count(self) -&gt; int:\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.DataContainer","title":"<code>DataContainer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A generic container for data.</p> <p>This class represents a container for data with a specific type T.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The data stored in the container.</p> <p> TYPE: <code>T</code> </p> METHOD DESCRIPTION <code>to_dict</code> <p>Converts the container's data to a dictionary.</p> <code>to_json</code> <p>Converts the container's data to a JSON string.</p> <code>from_dict</code> <p>Dict[str, Any]) -&gt; \"DataContainer\": Creates a DataContainer instance from a dictionary.</p> <code>from_json</code> <p>str) -&gt; \"DataContainer\": Creates a DataContainer instance from a JSON string.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass DataContainer(Generic[T]):\n    \"\"\"\n    A generic container for data.\n\n    This class represents a container for data with a specific type T.\n\n    Attributes:\n        data (T): The data stored in the container.\n\n    Methods:\n        to_dict() -&gt; Dict[str, Any]:\n            Converts the container's data to a dictionary.\n\n        to_json() -&gt; str:\n            Converts the container's data to a JSON string.\n\n        from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a dictionary.\n\n        from_json(cls, json_str: str) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a JSON string.\n    \"\"\"\n\n    data: T\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n    def to_json(self) -&gt; str:\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n        return cls(**data)\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; \"DataContainer\":\n        return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document","title":"<code>Document</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseDocument</code></p> <p>A document container that extends BaseDocument with rich annotation capabilities.</p> <p>This class extends BaseDocument to handle textual document data and annotations from various sources. It serves as the main data structure passed through processing pipelines, accumulating annotations and analysis results at each step.</p> <p>The Document class provides a comprehensive representation that can include: - Raw text and basic tokenization - NLP annotations (tokens, entities, embeddings, spaCy docs) - FHIR resources through the fhir property (problem list, medication list, allergy list) - Clinical decision support results through the cds property (cards, actions) - ML model outputs (Hugging Face, LangChain)</p> ATTRIBUTE DESCRIPTION <code>nlp</code> <p>Container for NLP-related annotations like tokens and entities</p> <p> TYPE: <code>NlpAnnotations</code> </p> <code>fhir</code> <p>Container for FHIR resources and CDS context</p> <p> TYPE: <code>FhirData</code> </p> <code>cds</code> <p>Container for clinical decision support results</p> <p> TYPE: <code>CdsAnnotations</code> </p> <code>models</code> <p>Container for ML model outputs</p> <p> TYPE: <code>ModelOutputs</code> </p> Example <p>doc = Document(data=\"Patient has hypertension\")</p> Inherits from <p>BaseDocument: Provides base document functionality and raw text storage</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass Document(BaseDocument):\n    \"\"\"\n    A document container that extends BaseDocument with rich annotation capabilities.\n\n    This class extends BaseDocument to handle textual document data and annotations from\n    various sources. It serves as the main data structure passed through processing pipelines,\n    accumulating annotations and analysis results at each step.\n\n    The Document class provides a comprehensive representation that can include:\n    - Raw text and basic tokenization\n    - NLP annotations (tokens, entities, embeddings, spaCy docs)\n    - FHIR resources through the fhir property (problem list, medication list, allergy list)\n    - Clinical decision support results through the cds property (cards, actions)\n    - ML model outputs (Hugging Face, LangChain)\n\n    Attributes:\n        nlp (NlpAnnotations): Container for NLP-related annotations like tokens and entities\n        fhir (FhirData): Container for FHIR resources and CDS context\n        cds (CdsAnnotations): Container for clinical decision support results\n        models (ModelOutputs): Container for ML model outputs\n\n    Example:\n        &gt;&gt;&gt; doc = Document(data=\"Patient has hypertension\")\n        &gt;&gt;&gt; # Add set continuity of care lists\n        &gt;&gt;&gt; doc.fhir.problem_list = [Condition(...)]\n        &gt;&gt;&gt; doc.fhir.medication_list = [MedicationStatement(...)]\n        &gt;&gt;&gt; # Add FHIR resources\n        &gt;&gt;&gt; doc.fhir.add_resources([Patient(...)], \"Patient\")\n        &gt;&gt;&gt; # Add a document with a parent\n        &gt;&gt;&gt; parent_id = doc.fhir.add_document(DocumentReference(...), parent_id=\"123\")\n        &gt;&gt;&gt; # Add CDS results\n        &gt;&gt;&gt; doc.cds.cards = [Card(...)]\n        &gt;&gt;&gt; doc.cds.actions = [Action(...)]\n\n    Inherits from:\n        BaseDocument: Provides base document functionality and raw text storage\n    \"\"\"\n\n    _nlp: NlpAnnotations = field(default_factory=NlpAnnotations)\n    _fhir: FhirData = field(default_factory=FhirData)\n    _cds: CdsAnnotations = field(default_factory=CdsAnnotations)\n    _models: ModelOutputs = field(default_factory=ModelOutputs)\n\n    @property\n    def nlp(self) -&gt; NlpAnnotations:\n        return self._nlp\n\n    @property\n    def fhir(self) -&gt; FhirData:\n        return self._fhir\n\n    @property\n    def cds(self) -&gt; CdsAnnotations:\n        return self._cds\n\n    @property\n    def models(self) -&gt; ModelOutputs:\n        return self._models\n\n    def __post_init__(self):\n        \"\"\"Initialize the document with basic tokenization if needed.\"\"\"\n        super().__post_init__()\n        self.text = self.data\n        if not self._nlp._tokens:\n            self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n\n    def word_count(self) -&gt; int:\n        \"\"\"\n        Get the word count from the document's text.\n        \"\"\"\n        return len(self._nlp._tokens)\n\n    def update_problem_list_from_nlp(self):\n        \"\"\"\n        Updates the document's problem list by extracting medical entities from the spaCy annotations.\n\n        This method looks for entities in the document's spaCy annotations that have associated\n        SNOMED CT concept IDs (CUIs). For each valid entity found, it creates a new FHIR Condition\n        resource and adds it to the document's problem list.\n\n        The method requires that:\n        1. A spaCy doc has been added to the document's NLP annotations\n        2. The entities in the spaCy doc have the 'cui' extension attribute set\n\n        Note:\n            - Currently defaults to using SNOMED CT coding system\n            - Uses a hardcoded patient reference \"Patient/123\"\n            - Preserves any existing conditions in the problem list\n        \"\"\"\n        conditions = self.fhir.problem_list\n        # TODO: Make this configurable\n        for ent in self.nlp._spacy_doc.ents:\n            if not Span.has_extension(\"cui\") or ent._.cui is None:\n                logger.debug(f\"No CUI found for entity {ent.text}\")\n                continue\n            condition = create_condition(\n                subject=\"Patient/123\",\n                code=ent._.cui,\n                display=ent.text,\n                system=\"http://snomed.info/sct\",\n            )\n            logger.debug(f\"Adding condition {condition.model_dump()}\")\n            conditions.append(condition)\n\n        # Add to document concepts\n        self.fhir.problem_list = conditions\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self._nlp._tokens)\n\n    def __len__(self) -&gt; int:\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document--add-set-continuity-of-care-lists","title":"Add set continuity of care lists","text":"<p>doc.fhir.problem_list = [Condition(...)] doc.fhir.medication_list = [MedicationStatement(...)]</p>"},{"location":"api/containers/#healthchain.io.containers.Document--add-fhir-resources","title":"Add FHIR resources","text":"<p>doc.fhir.add_resources([Patient(...)], \"Patient\")</p>"},{"location":"api/containers/#healthchain.io.containers.Document--add-a-document-with-a-parent","title":"Add a document with a parent","text":"<p>parent_id = doc.fhir.add_document(DocumentReference(...), parent_id=\"123\")</p>"},{"location":"api/containers/#healthchain.io.containers.Document--add-cds-results","title":"Add CDS results","text":"<p>doc.cds.cards = [Card(...)] doc.cds.actions = [Action(...)]</p>"},{"location":"api/containers/#healthchain.io.containers.Document.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the document with basic tokenization if needed.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the document with basic tokenization if needed.\"\"\"\n    super().__post_init__()\n    self.text = self.data\n    if not self._nlp._tokens:\n        self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.update_problem_list_from_nlp","title":"<code>update_problem_list_from_nlp()</code>","text":"<p>Updates the document's problem list by extracting medical entities from the spaCy annotations.</p> <p>This method looks for entities in the document's spaCy annotations that have associated SNOMED CT concept IDs (CUIs). For each valid entity found, it creates a new FHIR Condition resource and adds it to the document's problem list.</p> <p>The method requires that: 1. A spaCy doc has been added to the document's NLP annotations 2. The entities in the spaCy doc have the 'cui' extension attribute set</p> Note <ul> <li>Currently defaults to using SNOMED CT coding system</li> <li>Uses a hardcoded patient reference \"Patient/123\"</li> <li>Preserves any existing conditions in the problem list</li> </ul> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def update_problem_list_from_nlp(self):\n    \"\"\"\n    Updates the document's problem list by extracting medical entities from the spaCy annotations.\n\n    This method looks for entities in the document's spaCy annotations that have associated\n    SNOMED CT concept IDs (CUIs). For each valid entity found, it creates a new FHIR Condition\n    resource and adds it to the document's problem list.\n\n    The method requires that:\n    1. A spaCy doc has been added to the document's NLP annotations\n    2. The entities in the spaCy doc have the 'cui' extension attribute set\n\n    Note:\n        - Currently defaults to using SNOMED CT coding system\n        - Uses a hardcoded patient reference \"Patient/123\"\n        - Preserves any existing conditions in the problem list\n    \"\"\"\n    conditions = self.fhir.problem_list\n    # TODO: Make this configurable\n    for ent in self.nlp._spacy_doc.ents:\n        if not Span.has_extension(\"cui\") or ent._.cui is None:\n            logger.debug(f\"No CUI found for entity {ent.text}\")\n            continue\n        condition = create_condition(\n            subject=\"Patient/123\",\n            code=ent._.cui,\n            display=ent.text,\n            system=\"http://snomed.info/sct\",\n        )\n        logger.debug(f\"Adding condition {condition.model_dump()}\")\n        conditions.append(condition)\n\n    # Add to document concepts\n    self.fhir.problem_list = conditions\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.word_count","title":"<code>word_count()</code>","text":"<p>Get the word count from the document's text.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def word_count(self) -&gt; int:\n    \"\"\"\n    Get the word count from the document's text.\n    \"\"\"\n    return len(self._nlp._tokens)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Tabular","title":"<code>Tabular</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[DataFrame]</code></p> <p>A container for tabular data, wrapping a pandas DataFrame.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The pandas DataFrame containing the tabular data.</p> <p> TYPE: <code>DataFrame</code> </p> METHOD DESCRIPTION <code>__post_init__</code> <p>Validates that the data is a pandas DataFrame.</p> <code>columns</code> <p>Property that returns a list of column names.</p> <code>index</code> <p>Property that returns the DataFrame's index.</p> <code>dtypes</code> <p>Property that returns a dictionary of column names and their data types.</p> <code>column_count</code> <p>Returns the number of columns in the DataFrame.</p> <code>row_count</code> <p>Returns the number of rows in the DataFrame.</p> <code>get_dtype</code> <p>str): Returns the data type of a specific column.</p> <code>__iter__</code> <p>Returns an iterator over the column names.</p> <code>__len__</code> <p>Returns the number of rows in the DataFrame.</p> <code>describe</code> <p>Returns a string description of the tabular data.</p> <code>remove_column</code> <p>str): Removes a column from the DataFrame.</p> <code>from_csv</code> <p>str, **kwargs): Class method to create a Tabular object from a CSV file.</p> <code>from_dict</code> <p>Dict[str, Any]): Class method to create a Tabular object from a dictionary.</p> <code>to_csv</code> <p>str, **kwargs): Saves the DataFrame to a CSV file.</p> Source code in <code>healthchain/io/containers/tabular.py</code> <pre><code>@dataclass\nclass Tabular(DataContainer[pd.DataFrame]):\n    \"\"\"\n    A container for tabular data, wrapping a pandas DataFrame.\n\n    Attributes:\n        data (pd.DataFrame): The pandas DataFrame containing the tabular data.\n\n    Methods:\n        __post_init__(): Validates that the data is a pandas DataFrame.\n        columns: Property that returns a list of column names.\n        index: Property that returns the DataFrame's index.\n        dtypes: Property that returns a dictionary of column names and their data types.\n        column_count(): Returns the number of columns in the DataFrame.\n        row_count(): Returns the number of rows in the DataFrame.\n        get_dtype(column: str): Returns the data type of a specific column.\n        __iter__(): Returns an iterator over the column names.\n        __len__(): Returns the number of rows in the DataFrame.\n        describe(): Returns a string description of the tabular data.\n        remove_column(name: str): Removes a column from the DataFrame.\n        from_csv(path: str, **kwargs): Class method to create a Tabular object from a CSV file.\n        from_dict(data: Dict[str, Any]): Class method to create a Tabular object from a dictionary.\n        to_csv(path: str, **kwargs): Saves the DataFrame to a CSV file.\n    \"\"\"\n\n    def __post_init__(self):\n        if not isinstance(self.data, pd.DataFrame):\n            raise TypeError(\"data must be a pandas DataFrame\")\n\n    @property\n    def columns(self) -&gt; List[str]:\n        return list(self.data.columns)\n\n    @property\n    def index(self) -&gt; pd.Index:\n        return self.data.index\n\n    @property\n    def dtypes(self) -&gt; Dict[str, str]:\n        return {col: str(dtype) for col, dtype in self.data.dtypes.items()}\n\n    def column_count(self) -&gt; int:\n        return len(self.columns)\n\n    def row_count(self) -&gt; int:\n        return len(self.data)\n\n    def get_dtype(self, column: str) -&gt; str:\n        return str(self.data[column].dtype)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.columns)\n\n    def __len__(self) -&gt; int:\n        return self.row_count()\n\n    def describe(self) -&gt; str:\n        return f\"Tabular data with {self.column_count()} columns and {self.row_count()} rows\"\n\n    def remove_column(self, name: str) -&gt; None:\n        self.data.drop(columns=[name], inplace=True)\n\n    @classmethod\n    def from_csv(cls, path: str, **kwargs) -&gt; \"Tabular\":\n        return cls(pd.read_csv(path, **kwargs))\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Tabular\":\n        df = pd.DataFrame(**data[\"data\"])\n        return cls(df)\n\n    def to_csv(self, path: str, **kwargs) -&gt; None:\n        self.data.to_csv(path, **kwargs)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.base","title":"<code>base</code>","text":""},{"location":"api/containers/#healthchain.io.containers.base.BaseDocument","title":"<code>BaseDocument</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[str]</code></p> <p>Base document container for raw text content.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass BaseDocument(DataContainer[str]):\n    \"\"\"Base document container for raw text content.\"\"\"\n\n    data: str\n    text: str = field(init=False)\n\n    def __post_init__(self):\n        self.text = self.data\n\n    def char_count(self) -&gt; int:\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.base.DataContainer","title":"<code>DataContainer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A generic container for data.</p> <p>This class represents a container for data with a specific type T.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The data stored in the container.</p> <p> TYPE: <code>T</code> </p> METHOD DESCRIPTION <code>to_dict</code> <p>Converts the container's data to a dictionary.</p> <code>to_json</code> <p>Converts the container's data to a JSON string.</p> <code>from_dict</code> <p>Dict[str, Any]) -&gt; \"DataContainer\": Creates a DataContainer instance from a dictionary.</p> <code>from_json</code> <p>str) -&gt; \"DataContainer\": Creates a DataContainer instance from a JSON string.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass DataContainer(Generic[T]):\n    \"\"\"\n    A generic container for data.\n\n    This class represents a container for data with a specific type T.\n\n    Attributes:\n        data (T): The data stored in the container.\n\n    Methods:\n        to_dict() -&gt; Dict[str, Any]:\n            Converts the container's data to a dictionary.\n\n        to_json() -&gt; str:\n            Converts the container's data to a JSON string.\n\n        from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a dictionary.\n\n        from_json(cls, json_str: str) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a JSON string.\n    \"\"\"\n\n    data: T\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n    def to_json(self) -&gt; str:\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n        return cls(**data)\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; \"DataContainer\":\n        return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document","title":"<code>document</code>","text":""},{"location":"api/containers/#healthchain.io.containers.document.CdsAnnotations","title":"<code>CdsAnnotations</code>  <code>dataclass</code>","text":"<p>Container for Clinical Decision Support (CDS) results.</p> <p>This class stores and manages outputs from clinical decision support systems, including CDS Hooks cards and suggested clinical actions. The cards contain recommendations, warnings, and other decision support content that can be displayed to clinicians. Actions represent specific clinical tasks or interventions that are suggested based on the analysis.</p> ATTRIBUTE DESCRIPTION <code>_cards</code> <p>CDS Hooks cards containing clinical recommendations, warnings, or other decision support content.</p> <p> TYPE: <code>Optional[List[Card]]</code> </p> <code>_actions</code> <p>Suggested clinical actions that could be taken based on the CDS analysis.</p> <p> TYPE: <code>Optional[List[Action]]</code> </p> Example <p>cds = CdsAnnotations() cds.cards = [Card(summary=\"Consider aspirin\")] cds.actions = [Action(type=\"create\", description=\"Order aspirin\")]</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass CdsAnnotations:\n    \"\"\"\n    Container for Clinical Decision Support (CDS) results.\n\n    This class stores and manages outputs from clinical decision support systems,\n    including CDS Hooks cards and suggested clinical actions. The cards contain\n    recommendations, warnings, and other decision support content that can be\n    displayed to clinicians. Actions represent specific clinical tasks or\n    interventions that are suggested based on the analysis.\n\n    Attributes:\n        _cards (Optional[List[Card]]): CDS Hooks cards containing clinical\n            recommendations, warnings, or other decision support content.\n        _actions (Optional[List[Action]]): Suggested clinical actions that\n            could be taken based on the CDS analysis.\n\n    Example:\n        &gt;&gt;&gt; cds = CdsAnnotations()\n        &gt;&gt;&gt; cds.cards = [Card(summary=\"Consider aspirin\")]\n        &gt;&gt;&gt; cds.actions = [Action(type=\"create\", description=\"Order aspirin\")]\n    \"\"\"\n\n    _cards: Optional[List[Card]] = None\n    _actions: Optional[List[Action]] = None\n\n    @property\n    def cards(self) -&gt; Optional[List[Card]]:\n        \"\"\"Get the current list of CDS Hooks cards.\"\"\"\n        return self._cards\n\n    @cards.setter\n    def cards(self, cards: Union[List[Card], List[Dict[str, Any]]]) -&gt; None:\n        \"\"\"\n        Set CDS Hooks cards, converting from dictionaries if needed.\n\n        Args:\n            cards: List of Card objects or dictionaries that can be converted to Cards.\n\n        Raises:\n            ValueError: If cards list is empty or has invalid format.\n            TypeError: If cards are neither Card objects nor dictionaries.\n        \"\"\"\n        if not cards:\n            raise ValueError(\"Cards must be provided as a list!\")\n\n        try:\n            if isinstance(cards[0], dict):\n                self._cards = [Card(**card) for card in cards]\n            elif isinstance(cards[0], Card):\n                self._cards = cards\n            else:\n                raise TypeError(\"Cards must be either Card objects or dictionaries\")\n        except (IndexError, KeyError) as e:\n            raise ValueError(\"Invalid card format\") from e\n\n    @property\n    def actions(self) -&gt; Optional[List[Action]]:\n        \"\"\"Get the current list of suggested clinical actions.\"\"\"\n        return self._actions\n\n    @actions.setter\n    def actions(self, actions: Union[List[Action], List[Dict[str, Any]]]) -&gt; None:\n        \"\"\"\n        Set suggested clinical actions, converting from dictionaries if needed.\n\n        Args:\n            actions: List of Action objects or dictionaries that can be converted to Actions.\n\n        Raises:\n            ValueError: If actions list is empty or has invalid format.\n            TypeError: If actions are neither Action objects nor dictionaries.\n        \"\"\"\n        if not actions:\n            raise ValueError(\"Actions must be provided as a list!\")\n\n        try:\n            if isinstance(actions[0], dict):\n                self._actions = [Action(**action) for action in actions]\n            elif isinstance(actions[0], Action):\n                self._actions = actions\n            else:\n                raise TypeError(\"Actions must be either Action objects or dictionaries\")\n        except (IndexError, KeyError) as e:\n            raise ValueError(\"Invalid action format\") from e\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.CdsAnnotations.actions","title":"<code>actions</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current list of suggested clinical actions.</p>"},{"location":"api/containers/#healthchain.io.containers.document.CdsAnnotations.cards","title":"<code>cards</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current list of CDS Hooks cards.</p>"},{"location":"api/containers/#healthchain.io.containers.document.Document","title":"<code>Document</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseDocument</code></p> <p>A document container that extends BaseDocument with rich annotation capabilities.</p> <p>This class extends BaseDocument to handle textual document data and annotations from various sources. It serves as the main data structure passed through processing pipelines, accumulating annotations and analysis results at each step.</p> <p>The Document class provides a comprehensive representation that can include: - Raw text and basic tokenization - NLP annotations (tokens, entities, embeddings, spaCy docs) - FHIR resources through the fhir property (problem list, medication list, allergy list) - Clinical decision support results through the cds property (cards, actions) - ML model outputs (Hugging Face, LangChain)</p> ATTRIBUTE DESCRIPTION <code>nlp</code> <p>Container for NLP-related annotations like tokens and entities</p> <p> TYPE: <code>NlpAnnotations</code> </p> <code>fhir</code> <p>Container for FHIR resources and CDS context</p> <p> TYPE: <code>FhirData</code> </p> <code>cds</code> <p>Container for clinical decision support results</p> <p> TYPE: <code>CdsAnnotations</code> </p> <code>models</code> <p>Container for ML model outputs</p> <p> TYPE: <code>ModelOutputs</code> </p> Example <p>doc = Document(data=\"Patient has hypertension\")</p> Inherits from <p>BaseDocument: Provides base document functionality and raw text storage</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass Document(BaseDocument):\n    \"\"\"\n    A document container that extends BaseDocument with rich annotation capabilities.\n\n    This class extends BaseDocument to handle textual document data and annotations from\n    various sources. It serves as the main data structure passed through processing pipelines,\n    accumulating annotations and analysis results at each step.\n\n    The Document class provides a comprehensive representation that can include:\n    - Raw text and basic tokenization\n    - NLP annotations (tokens, entities, embeddings, spaCy docs)\n    - FHIR resources through the fhir property (problem list, medication list, allergy list)\n    - Clinical decision support results through the cds property (cards, actions)\n    - ML model outputs (Hugging Face, LangChain)\n\n    Attributes:\n        nlp (NlpAnnotations): Container for NLP-related annotations like tokens and entities\n        fhir (FhirData): Container for FHIR resources and CDS context\n        cds (CdsAnnotations): Container for clinical decision support results\n        models (ModelOutputs): Container for ML model outputs\n\n    Example:\n        &gt;&gt;&gt; doc = Document(data=\"Patient has hypertension\")\n        &gt;&gt;&gt; # Add set continuity of care lists\n        &gt;&gt;&gt; doc.fhir.problem_list = [Condition(...)]\n        &gt;&gt;&gt; doc.fhir.medication_list = [MedicationStatement(...)]\n        &gt;&gt;&gt; # Add FHIR resources\n        &gt;&gt;&gt; doc.fhir.add_resources([Patient(...)], \"Patient\")\n        &gt;&gt;&gt; # Add a document with a parent\n        &gt;&gt;&gt; parent_id = doc.fhir.add_document(DocumentReference(...), parent_id=\"123\")\n        &gt;&gt;&gt; # Add CDS results\n        &gt;&gt;&gt; doc.cds.cards = [Card(...)]\n        &gt;&gt;&gt; doc.cds.actions = [Action(...)]\n\n    Inherits from:\n        BaseDocument: Provides base document functionality and raw text storage\n    \"\"\"\n\n    _nlp: NlpAnnotations = field(default_factory=NlpAnnotations)\n    _fhir: FhirData = field(default_factory=FhirData)\n    _cds: CdsAnnotations = field(default_factory=CdsAnnotations)\n    _models: ModelOutputs = field(default_factory=ModelOutputs)\n\n    @property\n    def nlp(self) -&gt; NlpAnnotations:\n        return self._nlp\n\n    @property\n    def fhir(self) -&gt; FhirData:\n        return self._fhir\n\n    @property\n    def cds(self) -&gt; CdsAnnotations:\n        return self._cds\n\n    @property\n    def models(self) -&gt; ModelOutputs:\n        return self._models\n\n    def __post_init__(self):\n        \"\"\"Initialize the document with basic tokenization if needed.\"\"\"\n        super().__post_init__()\n        self.text = self.data\n        if not self._nlp._tokens:\n            self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n\n    def word_count(self) -&gt; int:\n        \"\"\"\n        Get the word count from the document's text.\n        \"\"\"\n        return len(self._nlp._tokens)\n\n    def update_problem_list_from_nlp(self):\n        \"\"\"\n        Updates the document's problem list by extracting medical entities from the spaCy annotations.\n\n        This method looks for entities in the document's spaCy annotations that have associated\n        SNOMED CT concept IDs (CUIs). For each valid entity found, it creates a new FHIR Condition\n        resource and adds it to the document's problem list.\n\n        The method requires that:\n        1. A spaCy doc has been added to the document's NLP annotations\n        2. The entities in the spaCy doc have the 'cui' extension attribute set\n\n        Note:\n            - Currently defaults to using SNOMED CT coding system\n            - Uses a hardcoded patient reference \"Patient/123\"\n            - Preserves any existing conditions in the problem list\n        \"\"\"\n        conditions = self.fhir.problem_list\n        # TODO: Make this configurable\n        for ent in self.nlp._spacy_doc.ents:\n            if not Span.has_extension(\"cui\") or ent._.cui is None:\n                logger.debug(f\"No CUI found for entity {ent.text}\")\n                continue\n            condition = create_condition(\n                subject=\"Patient/123\",\n                code=ent._.cui,\n                display=ent.text,\n                system=\"http://snomed.info/sct\",\n            )\n            logger.debug(f\"Adding condition {condition.model_dump()}\")\n            conditions.append(condition)\n\n        # Add to document concepts\n        self.fhir.problem_list = conditions\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self._nlp._tokens)\n\n    def __len__(self) -&gt; int:\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document--add-set-continuity-of-care-lists","title":"Add set continuity of care lists","text":"<p>doc.fhir.problem_list = [Condition(...)] doc.fhir.medication_list = [MedicationStatement(...)]</p>"},{"location":"api/containers/#healthchain.io.containers.document.Document--add-fhir-resources","title":"Add FHIR resources","text":"<p>doc.fhir.add_resources([Patient(...)], \"Patient\")</p>"},{"location":"api/containers/#healthchain.io.containers.document.Document--add-a-document-with-a-parent","title":"Add a document with a parent","text":"<p>parent_id = doc.fhir.add_document(DocumentReference(...), parent_id=\"123\")</p>"},{"location":"api/containers/#healthchain.io.containers.document.Document--add-cds-results","title":"Add CDS results","text":"<p>doc.cds.cards = [Card(...)] doc.cds.actions = [Action(...)]</p>"},{"location":"api/containers/#healthchain.io.containers.document.Document.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the document with basic tokenization if needed.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the document with basic tokenization if needed.\"\"\"\n    super().__post_init__()\n    self.text = self.data\n    if not self._nlp._tokens:\n        self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.update_problem_list_from_nlp","title":"<code>update_problem_list_from_nlp()</code>","text":"<p>Updates the document's problem list by extracting medical entities from the spaCy annotations.</p> <p>This method looks for entities in the document's spaCy annotations that have associated SNOMED CT concept IDs (CUIs). For each valid entity found, it creates a new FHIR Condition resource and adds it to the document's problem list.</p> <p>The method requires that: 1. A spaCy doc has been added to the document's NLP annotations 2. The entities in the spaCy doc have the 'cui' extension attribute set</p> Note <ul> <li>Currently defaults to using SNOMED CT coding system</li> <li>Uses a hardcoded patient reference \"Patient/123\"</li> <li>Preserves any existing conditions in the problem list</li> </ul> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def update_problem_list_from_nlp(self):\n    \"\"\"\n    Updates the document's problem list by extracting medical entities from the spaCy annotations.\n\n    This method looks for entities in the document's spaCy annotations that have associated\n    SNOMED CT concept IDs (CUIs). For each valid entity found, it creates a new FHIR Condition\n    resource and adds it to the document's problem list.\n\n    The method requires that:\n    1. A spaCy doc has been added to the document's NLP annotations\n    2. The entities in the spaCy doc have the 'cui' extension attribute set\n\n    Note:\n        - Currently defaults to using SNOMED CT coding system\n        - Uses a hardcoded patient reference \"Patient/123\"\n        - Preserves any existing conditions in the problem list\n    \"\"\"\n    conditions = self.fhir.problem_list\n    # TODO: Make this configurable\n    for ent in self.nlp._spacy_doc.ents:\n        if not Span.has_extension(\"cui\") or ent._.cui is None:\n            logger.debug(f\"No CUI found for entity {ent.text}\")\n            continue\n        condition = create_condition(\n            subject=\"Patient/123\",\n            code=ent._.cui,\n            display=ent.text,\n            system=\"http://snomed.info/sct\",\n        )\n        logger.debug(f\"Adding condition {condition.model_dump()}\")\n        conditions.append(condition)\n\n    # Add to document concepts\n    self.fhir.problem_list = conditions\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.word_count","title":"<code>word_count()</code>","text":"<p>Get the word count from the document's text.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def word_count(self) -&gt; int:\n    \"\"\"\n    Get the word count from the document's text.\n    \"\"\"\n    return len(self._nlp._tokens)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData","title":"<code>FhirData</code>  <code>dataclass</code>","text":"<p>Container for FHIR resource data and its context.</p> <p>Stores and manages clinical data in FHIR format. Access document references within resources easily through convenience functions.</p> <p>Also allows you to set common continuity of care lists, such as a problem list, medication list, and allergy list. These collections are accessible as properties of the class instance.</p> Properties <p>bundle: The FHIR bundle containing resources prefetch_resources: Dictionary of CDS Hooks prefetch resources problem_list: List of Condition resources medication_list: List of MedicationStatement resources allergy_list: List of AllergyIntolerance resources</p> Example <p>fhir = FhirData()</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass FhirData:\n    \"\"\"\n    Container for FHIR resource data and its context.\n\n    Stores and manages clinical data in FHIR format.\n    Access document references within resources easily through convenience functions.\n\n    Also allows you to set common continuity of care lists,\n    such as a problem list, medication list, and allergy list.\n    These collections are accessible as properties of the class instance.\n\n    Properties:\n        bundle: The FHIR bundle containing resources\n        prefetch_resources: Dictionary of CDS Hooks prefetch resources\n        problem_list: List of Condition resources\n        medication_list: List of MedicationStatement resources\n        allergy_list: List of AllergyIntolerance resources\n\n    Example:\n        &gt;&gt;&gt; fhir = FhirData()\n        &gt;&gt;&gt; # Add prefetch resources from CDS request\n        &gt;&gt;&gt; fhir.prefetch_resources = {\"patient\": patient_resource}\n        &gt;&gt;&gt; # Add document to bundle\n        &gt;&gt;&gt; doc_id = fhir.add_document_reference(document)\n        &gt;&gt;&gt; # Get document with relationships\n        &gt;&gt;&gt; doc_family = fhir.get_document_reference_family(doc_id)\n        &gt;&gt;&gt; # Access clinical lists\n        &gt;&gt;&gt; conditions = fhir.problem_list\n    \"\"\"\n\n    _prefetch_resources: Optional[Dict[str, Resource]] = None\n    _bundle: Optional[Bundle] = None\n\n    @property\n    def bundle(self) -&gt; Optional[Bundle]:\n        \"\"\"Returns the FHIR Bundle if it exists.\"\"\"\n        return self._bundle\n\n    @bundle.setter\n    def bundle(self, bundle: Bundle):\n        \"\"\"Sets the FHIR Bundle.\n        The bundle is a collection of FHIR resources.\n        See: https://www.hl7.org/fhir/bundle.html\n        \"\"\"\n        self._bundle = bundle\n\n    @property\n    def prefetch_resources(self) -&gt; Optional[Dict[str, Resource]]:\n        \"\"\"Returns the prefetch FHIR resources.\"\"\"\n        return self._prefetch_resources\n\n    @prefetch_resources.setter\n    def prefetch_resources(self, resources: Dict[str, Resource]):\n        \"\"\"Sets the prefetch FHIR resources from CDS service requests.\"\"\"\n        self._prefetch_resources = resources\n\n    @property\n    def problem_list(self) -&gt; List[Condition]:\n        \"\"\"Get problem list from the bundle.\n        Problem list items are stored as Condition resources in the bundle.\n        See: https://www.hl7.org/fhir/condition.html\n        \"\"\"\n        return self.get_resources(\"Condition\")\n\n    @problem_list.setter\n    def problem_list(self, conditions: List[Condition]) -&gt; None:\n        \"\"\"Set problem list in the bundle.\"\"\"\n        self.add_resources(conditions, \"Condition\")\n\n    @property\n    def medication_list(self) -&gt; List[MedicationStatement]:\n        \"\"\"Get medication list from the bundle.\"\"\"\n        return self.get_resources(\"MedicationStatement\")\n\n    @medication_list.setter\n    def medication_list(self, medications: List[MedicationStatement]) -&gt; None:\n        \"\"\"Set medication list in the bundle.\n        Medication statements are stored as MedicationStatement resources in the bundle.\n        See: https://www.hl7.org/fhir/medicationstatement.html\n        \"\"\"\n        self.add_resources(medications, \"MedicationStatement\")\n\n    @property\n    def allergy_list(self) -&gt; List[AllergyIntolerance]:\n        \"\"\"Get allergy list from the bundle.\"\"\"\n        return self.get_resources(\"AllergyIntolerance\")\n\n    @allergy_list.setter\n    def allergy_list(self, allergies: List[AllergyIntolerance]) -&gt; None:\n        \"\"\"Set allergy list in the bundle.\n        Allergy intolerances are stored as AllergyIntolerance resources in the bundle.\n        See: https://www.hl7.org/fhir/allergyintolerance.html\n        \"\"\"\n        self.add_resources(allergies, \"AllergyIntolerance\")\n\n    def get_prefetch_resources(self, key: str) -&gt; List[Any]:\n        \"\"\"Get resources of a specific type from the prefetch bundle.\"\"\"\n        if not self._prefetch_resources:\n            return []\n        return self._prefetch_resources.get(key, [])\n\n    def get_resources(self, resource_type: str) -&gt; List[Any]:\n        \"\"\"Get resources of a specific type from the working bundle.\"\"\"\n        if not self._bundle:\n            return []\n        return get_resources(self._bundle, resource_type)\n\n    def add_resources(\n        self, resources: List[Any], resource_type: str, replace: bool = False\n    ):\n        \"\"\"Add resources to the working bundle.\"\"\"\n        if not self._bundle:\n            self._bundle = create_bundle()\n        set_resources(self._bundle, resources, resource_type, replace=replace)\n\n    def add_document_reference(\n        self,\n        document: DocumentReference,\n        parent_id: Optional[str] = None,\n        relationship_type: Optional[str] = \"transforms\",\n    ) -&gt; str:\n        \"\"\"\n        Adds a DocumentReference resource to the FHIR bundle and establishes\n        relationships between documents if a parent_id is provided. The relationship is\n        tracked using the FHIR relatesTo element with a specified relationship type.\n        See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n        Args:\n            document: The DocumentReference to add to the bundle\n            parent_id: Optional ID of the parent document. If provided, establishes a\n                relationship between this document and its parent.\n            relationship_type: The type of relationship to establish with the parent\n                document. Defaults to \"transforms\". This is used in the FHIR relatesTo\n                element's code. See: http://hl7.org/fhir/valueset-document-relationship-type\n\n        Returns:\n            str: The ID of the added document. If the document had no ID, a new UUID-based\n                ID is generated.\n        \"\"\"\n        # Generate a consistent ID if not present\n        if not document.id:\n            document.id = f\"doc-{uuid4()}\"\n\n        # Add relationship metadata if there's a parent\n        if parent_id:\n            if not hasattr(document, \"relatesTo\") or not document.relatesTo:\n                document.relatesTo = []\n            document.relatesTo.append(\n                {\n                    \"target\": {\"reference\": f\"DocumentReference/{parent_id}\"},\n                    \"code\": create_single_codeable_concept(\n                        code=relationship_type,\n                        display=relationship_type.capitalize(),\n                        system=\"http://hl7.org/fhir/ValueSet/document-relationship-type\",\n                    ),\n                }\n            )\n\n        self.add_resources([document], \"DocumentReference\", replace=False)\n\n        return document.id\n\n    def get_document_references_readable(\n        self, include_data: bool = True, include_relationships: bool = True\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get DocumentReferences resources with their content and optional relationship data\n        in a human-readable dictionary format.\n\n        Args:\n            include_data: If True, decode and include the document data (default: True)\n            include_relationships: If True, include related document information (default: True)\n\n        Returns:\n            List of documents with metadata and optionally their content and relationships\n        \"\"\"\n        documents = []\n        for doc in self.get_resources(\"DocumentReference\"):\n            doc_data = {\n                \"id\": doc.id,\n                \"description\": doc.description,\n                \"status\": doc.status,\n            }\n\n            attachments = read_content_attachment(doc, include_data=include_data)\n            if attachments:\n                doc_data[\"attachments\"] = []\n                for attachment in attachments:\n                    if include_data:\n                        doc_data[\"attachments\"].append(\n                            {\n                                \"data\": attachment.get(\"data\"),\n                                \"metadata\": attachment.get(\"metadata\"),\n                            }\n                        )\n                    else:\n                        doc_data[\"attachments\"].append(\n                            {\"metadata\": attachment.get(\"metadata\")}\n                        )\n\n            if include_relationships:\n                family = self.get_document_reference_family(doc.id)\n                doc_data[\"relationships\"] = {\n                    \"parents\": [\n                        {\"id\": p.id, \"description\": p.description}\n                        for p in family[\"parents\"]\n                    ],\n                    \"children\": [\n                        {\"id\": c.id, \"description\": c.description}\n                        for c in family[\"children\"]\n                    ],\n                    \"siblings\": [\n                        {\"id\": s.id, \"description\": s.description}\n                        for s in family[\"siblings\"]\n                    ],\n                }\n\n            documents.append(doc_data)\n\n        return documents\n\n    def get_document_reference_family(self, document_id: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get a DocumentReference resource and all its related resources\n        based on the relatesTo element in the FHIR standard.\n        See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n        Args:\n            document_id: ID of the DocumentReference resource to find relationships for\n\n        Returns:\n            Dict containing:\n                'document': The requested DocumentReference resource\n                'parents': List of parent DocumentReference resources\n                'children': List of child DocumentReference resources\n                'siblings': List of DocumentReference resources sharing the same parent\n        \"\"\"\n        documents = self.get_resources(\"DocumentReference\")\n        family = {\"document\": None, \"parents\": [], \"children\": [], \"siblings\": []}\n\n        # Find the requested document\n        target_doc = next((doc for doc in documents if doc.id == document_id), None)\n        if not target_doc:\n            return family\n\n        family[\"document\"] = target_doc\n\n        # Find direct relationships\n        if hasattr(target_doc, \"relatesTo\") and target_doc.relatesTo:\n            # Find parents from target's relationships\n            for relation in target_doc.relatesTo:\n                parent_ref = relation.get(\"target\", {}).get(\"reference\")\n                parent_id = parent_ref.split(\"/\")[-1]\n                parent = next((doc for doc in documents if doc.id == parent_id), None)\n                if parent:\n                    family[\"parents\"].append(parent)\n\n        # Find children and siblings\n        for doc in documents:\n            if not hasattr(doc, \"relatesTo\") or not doc.relatesTo:\n                continue\n\n            for relation in doc.relatesTo:\n                target_ref = relation.get(\"target\", {}).get(\"reference\")\n                related_id = target_ref.split(\"/\")[-1]\n\n                # Check if this doc is a child of our target\n                if related_id == document_id:\n                    family[\"children\"].append(doc)\n\n                # For siblings, check if they share the same parent\n                elif family[\"parents\"] and related_id == family[\"parents\"][0].id:\n                    if doc.id != document_id:  # Don't include self as sibling\n                        family[\"siblings\"].append(doc)\n\n        return family\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--add-prefetch-resources-from-cds-request","title":"Add prefetch resources from CDS request","text":"<p>fhir.prefetch_resources = {\"patient\": patient_resource}</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--add-document-to-bundle","title":"Add document to bundle","text":"<p>doc_id = fhir.add_document_reference(document)</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--get-document-with-relationships","title":"Get document with relationships","text":"<p>doc_family = fhir.get_document_reference_family(doc_id)</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--access-clinical-lists","title":"Access clinical lists","text":"<p>conditions = fhir.problem_list</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.allergy_list","title":"<code>allergy_list</code>  <code>property</code> <code>writable</code>","text":"<p>Get allergy list from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.bundle","title":"<code>bundle</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the FHIR Bundle if it exists.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.medication_list","title":"<code>medication_list</code>  <code>property</code> <code>writable</code>","text":"<p>Get medication list from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.prefetch_resources","title":"<code>prefetch_resources</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the prefetch FHIR resources.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.problem_list","title":"<code>problem_list</code>  <code>property</code> <code>writable</code>","text":"<p>Get problem list from the bundle. Problem list items are stored as Condition resources in the bundle. See: https://www.hl7.org/fhir/condition.html</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.add_document_reference","title":"<code>add_document_reference(document, parent_id=None, relationship_type='transforms')</code>","text":"<p>Adds a DocumentReference resource to the FHIR bundle and establishes relationships between documents if a parent_id is provided. The relationship is tracked using the FHIR relatesTo element with a specified relationship type. See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo</p> PARAMETER DESCRIPTION <code>document</code> <p>The DocumentReference to add to the bundle</p> <p> TYPE: <code>DocumentReference</code> </p> <code>parent_id</code> <p>Optional ID of the parent document. If provided, establishes a relationship between this document and its parent.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>relationship_type</code> <p>The type of relationship to establish with the parent document. Defaults to \"transforms\". This is used in the FHIR relatesTo element's code. See: http://hl7.org/fhir/valueset-document-relationship-type</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'transforms'</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The ID of the added document. If the document had no ID, a new UUID-based ID is generated.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def add_document_reference(\n    self,\n    document: DocumentReference,\n    parent_id: Optional[str] = None,\n    relationship_type: Optional[str] = \"transforms\",\n) -&gt; str:\n    \"\"\"\n    Adds a DocumentReference resource to the FHIR bundle and establishes\n    relationships between documents if a parent_id is provided. The relationship is\n    tracked using the FHIR relatesTo element with a specified relationship type.\n    See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n    Args:\n        document: The DocumentReference to add to the bundle\n        parent_id: Optional ID of the parent document. If provided, establishes a\n            relationship between this document and its parent.\n        relationship_type: The type of relationship to establish with the parent\n            document. Defaults to \"transforms\". This is used in the FHIR relatesTo\n            element's code. See: http://hl7.org/fhir/valueset-document-relationship-type\n\n    Returns:\n        str: The ID of the added document. If the document had no ID, a new UUID-based\n            ID is generated.\n    \"\"\"\n    # Generate a consistent ID if not present\n    if not document.id:\n        document.id = f\"doc-{uuid4()}\"\n\n    # Add relationship metadata if there's a parent\n    if parent_id:\n        if not hasattr(document, \"relatesTo\") or not document.relatesTo:\n            document.relatesTo = []\n        document.relatesTo.append(\n            {\n                \"target\": {\"reference\": f\"DocumentReference/{parent_id}\"},\n                \"code\": create_single_codeable_concept(\n                    code=relationship_type,\n                    display=relationship_type.capitalize(),\n                    system=\"http://hl7.org/fhir/ValueSet/document-relationship-type\",\n                ),\n            }\n        )\n\n    self.add_resources([document], \"DocumentReference\", replace=False)\n\n    return document.id\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.add_resources","title":"<code>add_resources(resources, resource_type, replace=False)</code>","text":"<p>Add resources to the working bundle.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def add_resources(\n    self, resources: List[Any], resource_type: str, replace: bool = False\n):\n    \"\"\"Add resources to the working bundle.\"\"\"\n    if not self._bundle:\n        self._bundle = create_bundle()\n    set_resources(self._bundle, resources, resource_type, replace=replace)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_document_reference_family","title":"<code>get_document_reference_family(document_id)</code>","text":"<p>Get a DocumentReference resource and all its related resources based on the relatesTo element in the FHIR standard. See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo</p> PARAMETER DESCRIPTION <code>document_id</code> <p>ID of the DocumentReference resource to find relationships for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict containing: 'document': The requested DocumentReference resource 'parents': List of parent DocumentReference resources 'children': List of child DocumentReference resources 'siblings': List of DocumentReference resources sharing the same parent</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_document_reference_family(self, document_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get a DocumentReference resource and all its related resources\n    based on the relatesTo element in the FHIR standard.\n    See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n    Args:\n        document_id: ID of the DocumentReference resource to find relationships for\n\n    Returns:\n        Dict containing:\n            'document': The requested DocumentReference resource\n            'parents': List of parent DocumentReference resources\n            'children': List of child DocumentReference resources\n            'siblings': List of DocumentReference resources sharing the same parent\n    \"\"\"\n    documents = self.get_resources(\"DocumentReference\")\n    family = {\"document\": None, \"parents\": [], \"children\": [], \"siblings\": []}\n\n    # Find the requested document\n    target_doc = next((doc for doc in documents if doc.id == document_id), None)\n    if not target_doc:\n        return family\n\n    family[\"document\"] = target_doc\n\n    # Find direct relationships\n    if hasattr(target_doc, \"relatesTo\") and target_doc.relatesTo:\n        # Find parents from target's relationships\n        for relation in target_doc.relatesTo:\n            parent_ref = relation.get(\"target\", {}).get(\"reference\")\n            parent_id = parent_ref.split(\"/\")[-1]\n            parent = next((doc for doc in documents if doc.id == parent_id), None)\n            if parent:\n                family[\"parents\"].append(parent)\n\n    # Find children and siblings\n    for doc in documents:\n        if not hasattr(doc, \"relatesTo\") or not doc.relatesTo:\n            continue\n\n        for relation in doc.relatesTo:\n            target_ref = relation.get(\"target\", {}).get(\"reference\")\n            related_id = target_ref.split(\"/\")[-1]\n\n            # Check if this doc is a child of our target\n            if related_id == document_id:\n                family[\"children\"].append(doc)\n\n            # For siblings, check if they share the same parent\n            elif family[\"parents\"] and related_id == family[\"parents\"][0].id:\n                if doc.id != document_id:  # Don't include self as sibling\n                    family[\"siblings\"].append(doc)\n\n    return family\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_document_references_readable","title":"<code>get_document_references_readable(include_data=True, include_relationships=True)</code>","text":"<p>Get DocumentReferences resources with their content and optional relationship data in a human-readable dictionary format.</p> PARAMETER DESCRIPTION <code>include_data</code> <p>If True, decode and include the document data (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>include_relationships</code> <p>If True, include related document information (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List of documents with metadata and optionally their content and relationships</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_document_references_readable(\n    self, include_data: bool = True, include_relationships: bool = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get DocumentReferences resources with their content and optional relationship data\n    in a human-readable dictionary format.\n\n    Args:\n        include_data: If True, decode and include the document data (default: True)\n        include_relationships: If True, include related document information (default: True)\n\n    Returns:\n        List of documents with metadata and optionally their content and relationships\n    \"\"\"\n    documents = []\n    for doc in self.get_resources(\"DocumentReference\"):\n        doc_data = {\n            \"id\": doc.id,\n            \"description\": doc.description,\n            \"status\": doc.status,\n        }\n\n        attachments = read_content_attachment(doc, include_data=include_data)\n        if attachments:\n            doc_data[\"attachments\"] = []\n            for attachment in attachments:\n                if include_data:\n                    doc_data[\"attachments\"].append(\n                        {\n                            \"data\": attachment.get(\"data\"),\n                            \"metadata\": attachment.get(\"metadata\"),\n                        }\n                    )\n                else:\n                    doc_data[\"attachments\"].append(\n                        {\"metadata\": attachment.get(\"metadata\")}\n                    )\n\n        if include_relationships:\n            family = self.get_document_reference_family(doc.id)\n            doc_data[\"relationships\"] = {\n                \"parents\": [\n                    {\"id\": p.id, \"description\": p.description}\n                    for p in family[\"parents\"]\n                ],\n                \"children\": [\n                    {\"id\": c.id, \"description\": c.description}\n                    for c in family[\"children\"]\n                ],\n                \"siblings\": [\n                    {\"id\": s.id, \"description\": s.description}\n                    for s in family[\"siblings\"]\n                ],\n            }\n\n        documents.append(doc_data)\n\n    return documents\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_prefetch_resources","title":"<code>get_prefetch_resources(key)</code>","text":"<p>Get resources of a specific type from the prefetch bundle.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_prefetch_resources(self, key: str) -&gt; List[Any]:\n    \"\"\"Get resources of a specific type from the prefetch bundle.\"\"\"\n    if not self._prefetch_resources:\n        return []\n    return self._prefetch_resources.get(key, [])\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_resources","title":"<code>get_resources(resource_type)</code>","text":"<p>Get resources of a specific type from the working bundle.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_resources(self, resource_type: str) -&gt; List[Any]:\n    \"\"\"Get resources of a specific type from the working bundle.\"\"\"\n    if not self._bundle:\n        return []\n    return get_resources(self._bundle, resource_type)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.ModelOutputs","title":"<code>ModelOutputs</code>  <code>dataclass</code>","text":"<p>Container for storing and managing third-party integration model outputs.</p> <p>This class stores outputs from different NLP/ML frameworks like Hugging Face and LangChain, organizing them by task type. It also maintains a list of generated text outputs across frameworks.</p> ATTRIBUTE DESCRIPTION <code>_huggingface_results</code> <p>Dictionary storing Hugging Face model outputs, keyed by task name.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>_langchain_results</code> <p>Dictionary storing LangChain outputs, keyed by task name.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> METHOD DESCRIPTION <code>add_output</code> <p>str, task: str, output: Any): Adds a model output for a specific source and task. For text generation tasks, also extracts and stores the generated text.</p> <code>get_output</code> <p>str, task: str, default: Any = None) -&gt; Any: Gets the model output for a specific source and task. Returns default if not found.</p> <code>get_generated_text</code> <p>Returns the list of generated text outputs</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass ModelOutputs:\n    \"\"\"\n    Container for storing and managing third-party integration model outputs.\n\n    This class stores outputs from different NLP/ML frameworks like Hugging Face\n    and LangChain, organizing them by task type. It also maintains a list of\n    generated text outputs across frameworks.\n\n    Attributes:\n        _huggingface_results (Dict[str, Any]): Dictionary storing Hugging Face model\n            outputs, keyed by task name.\n        _langchain_results (Dict[str, Any]): Dictionary storing LangChain outputs,\n            keyed by task name.\n\n    Methods:\n        add_output(source: str, task: str, output: Any): Adds a model output for a\n            specific source and task. For text generation tasks, also extracts and\n            stores the generated text.\n        get_output(source: str, task: str, default: Any = None) -&gt; Any: Gets the model\n            output for a specific source and task. Returns default if not found.\n        get_generated_text() -&gt; List[str]: Returns the list of generated text outputs\n    \"\"\"\n\n    _huggingface_results: Dict[str, Any] = field(default_factory=dict)\n    _langchain_results: Dict[str, Any] = field(default_factory=dict)\n\n    def add_output(self, source: str, task: str, output: Any):\n        if source == \"huggingface\":\n            self._huggingface_results[task] = output\n        elif source == \"langchain\":\n            self._langchain_results[task] = output\n        else:\n            raise ValueError(f\"Unknown source: {source}\")\n\n    def get_output(self, source: str, task: str) -&gt; Any:\n        if source == \"huggingface\":\n            return self._huggingface_results.get(task, {})\n        elif source == \"langchain\":\n            return self._langchain_results.get(task, {})\n        raise ValueError(f\"Unknown source: {source}\")\n\n    def get_generated_text(self, source: str, task: str) -&gt; List[str]:\n        \"\"\"\n        Returns generated text outputs for a given source and task.\n\n        Handles different output formats for Hugging Face and LangChain. For\n        Hugging Face, it extracts the last message content from chat-style\n        outputs and common keys like \"generated_text\", \"summary_text\", and\n        \"translation\". For LangChain, it converts JSON outputs to strings, and returns\n        the output as is if it is already a string.\n\n        Args:\n            source (str): Framework name (e.g., \"huggingface\", \"langchain\").\n            task (str): Task name for retrieving generated text.\n\n        Returns:\n            List[str]: List of generated text outputs, or an empty list if none.\n        \"\"\"\n        generated_text = []\n\n        if source == \"huggingface\":\n            # Handle chat-style output format\n            output = self._huggingface_results.get(task)\n            if isinstance(output, list):\n                for entry in output:\n                    text = entry.get(\"generated_text\")\n                    if isinstance(text, list):\n                        last_msg = text[-1]\n                        if isinstance(last_msg, dict) and \"content\" in last_msg:\n                            generated_text.append(last_msg[\"content\"])\n                    # Otherwise get common huggingface output keys\n                    elif any(\n                        key in entry\n                        for key in [\"generated_text\", \"summary_text\", \"translation\"]\n                    ):\n                        generated_text.append(\n                            text\n                            or entry.get(\"summary_text\")\n                            or entry.get(\"translation\")\n                        )\n            else:\n                logger.warning(\"HuggingFace output is not a list of dictionaries. \")\n        elif source == \"langchain\":\n            output = self._langchain_results.get(task)\n            # Check if output is a string\n            if isinstance(output, str):\n                generated_text.append(output)\n            # Try to convert JSON to string\n            elif isinstance(output, dict):\n                try:\n                    import json\n\n                    output_str = json.dumps(output)\n                    generated_text.append(output_str)\n                except Exception:\n                    logger.warning(\n                        \"LangChain output is not a string and could not be converted to JSON string. \"\n                        \"Chains should output either a string or a JSON object.\"\n                    )\n            else:\n                logger.warning(\n                    \"LangChain output is not a string. Chains should output either a string or a JSON object.\"\n                )\n\n        return generated_text\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.ModelOutputs.get_generated_text","title":"<code>get_generated_text(source, task)</code>","text":"<p>Returns generated text outputs for a given source and task.</p> <p>Handles different output formats for Hugging Face and LangChain. For Hugging Face, it extracts the last message content from chat-style outputs and common keys like \"generated_text\", \"summary_text\", and \"translation\". For LangChain, it converts JSON outputs to strings, and returns the output as is if it is already a string.</p> PARAMETER DESCRIPTION <code>source</code> <p>Framework name (e.g., \"huggingface\", \"langchain\").</p> <p> TYPE: <code>str</code> </p> <code>task</code> <p>Task name for retrieving generated text.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: List of generated text outputs, or an empty list if none.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_generated_text(self, source: str, task: str) -&gt; List[str]:\n    \"\"\"\n    Returns generated text outputs for a given source and task.\n\n    Handles different output formats for Hugging Face and LangChain. For\n    Hugging Face, it extracts the last message content from chat-style\n    outputs and common keys like \"generated_text\", \"summary_text\", and\n    \"translation\". For LangChain, it converts JSON outputs to strings, and returns\n    the output as is if it is already a string.\n\n    Args:\n        source (str): Framework name (e.g., \"huggingface\", \"langchain\").\n        task (str): Task name for retrieving generated text.\n\n    Returns:\n        List[str]: List of generated text outputs, or an empty list if none.\n    \"\"\"\n    generated_text = []\n\n    if source == \"huggingface\":\n        # Handle chat-style output format\n        output = self._huggingface_results.get(task)\n        if isinstance(output, list):\n            for entry in output:\n                text = entry.get(\"generated_text\")\n                if isinstance(text, list):\n                    last_msg = text[-1]\n                    if isinstance(last_msg, dict) and \"content\" in last_msg:\n                        generated_text.append(last_msg[\"content\"])\n                # Otherwise get common huggingface output keys\n                elif any(\n                    key in entry\n                    for key in [\"generated_text\", \"summary_text\", \"translation\"]\n                ):\n                    generated_text.append(\n                        text\n                        or entry.get(\"summary_text\")\n                        or entry.get(\"translation\")\n                    )\n        else:\n            logger.warning(\"HuggingFace output is not a list of dictionaries. \")\n    elif source == \"langchain\":\n        output = self._langchain_results.get(task)\n        # Check if output is a string\n        if isinstance(output, str):\n            generated_text.append(output)\n        # Try to convert JSON to string\n        elif isinstance(output, dict):\n            try:\n                import json\n\n                output_str = json.dumps(output)\n                generated_text.append(output_str)\n            except Exception:\n                logger.warning(\n                    \"LangChain output is not a string and could not be converted to JSON string. \"\n                    \"Chains should output either a string or a JSON object.\"\n                )\n        else:\n            logger.warning(\n                \"LangChain output is not a string. Chains should output either a string or a JSON object.\"\n            )\n\n    return generated_text\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.NlpAnnotations","title":"<code>NlpAnnotations</code>  <code>dataclass</code>","text":"<p>Container for NLP-specific annotations and results.</p> <p>This class stores various NLP annotations and processing results from text analysis, including preprocessed text, tokens, named entities, embeddings and spaCy documents.</p> ATTRIBUTE DESCRIPTION <code>_preprocessed_text</code> <p>The preprocessed version of the input text.</p> <p> TYPE: <code>str</code> </p> <code>_tokens</code> <p>List of tokenized words from the text.</p> <p> TYPE: <code>List[str]</code> </p> <code>_entities</code> <p>Named entities extracted from the text, with their labels and positions.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>_embeddings</code> <p>Vector embeddings generated from the text.</p> <p> TYPE: <code>Optional[List[float]]</code> </p> <code>_spacy_doc</code> <p>The processed spaCy Doc object.</p> <p> TYPE: <code>Optional[Doc]</code> </p> METHOD DESCRIPTION <code>add_spacy_doc</code> <p>SpacyDoc): Processes a spaCy Doc to extract tokens and entities.</p> <code>get_spacy_doc</code> <p>Returns the stored spaCy Doc object.</p> <code>get_tokens</code> <p>Returns the list of tokens.</p> <code>set_tokens</code> <p>List[str]): Sets the token list.</p> <code>set_entities</code> <p>List[Dict[str, Any]]): Sets the named entities list.</p> <code>get_entities</code> <p>Returns the list of named entities.</p> <code>get_embeddings</code> <p>Returns the vector embeddings.</p> <code>set_embeddings</code> <p>List[float]): Sets the vector embeddings.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass NlpAnnotations:\n    \"\"\"\n    Container for NLP-specific annotations and results.\n\n    This class stores various NLP annotations and processing results from text analysis,\n    including preprocessed text, tokens, named entities, embeddings and spaCy documents.\n\n    Attributes:\n        _preprocessed_text (str): The preprocessed version of the input text.\n        _tokens (List[str]): List of tokenized words from the text.\n        _entities (List[Dict[str, Any]]): Named entities extracted from the text, with their labels and positions.\n        _embeddings (Optional[List[float]]): Vector embeddings generated from the text.\n        _spacy_doc (Optional[SpacyDoc]): The processed spaCy Doc object.\n\n    Methods:\n        add_spacy_doc(doc: SpacyDoc): Processes a spaCy Doc to extract tokens and entities.\n        get_spacy_doc() -&gt; Optional[SpacyDoc]: Returns the stored spaCy Doc object.\n        get_tokens() -&gt; List[str]: Returns the list of tokens.\n        set_tokens(tokens: List[str]): Sets the token list.\n        set_entities(entities: List[Dict[str, Any]]): Sets the named entities list.\n        get_entities() -&gt; List[Dict[str, Any]]: Returns the list of named entities.\n        get_embeddings() -&gt; Optional[List[float]]: Returns the vector embeddings.\n        set_embeddings(embeddings: List[float]): Sets the vector embeddings.\n    \"\"\"\n\n    _preprocessed_text: str = \"\"\n    _tokens: List[str] = field(default_factory=list)\n    _entities: List[Dict[str, Any]] = field(default_factory=list)\n    _embeddings: Optional[List[float]] = None\n    _spacy_doc: Optional[SpacyDoc] = None\n\n    def add_spacy_doc(self, doc: SpacyDoc):\n        self._spacy_doc = doc\n        self._tokens = [token.text for token in doc]\n        self._entities = [\n            {\n                \"text\": ent.text,\n                \"label\": ent.label_,\n                \"start\": ent.start_char,\n                \"end\": ent.end_char,\n            }\n            for ent in doc.ents\n        ]\n\n    def get_spacy_doc(self) -&gt; Optional[SpacyDoc]:\n        return self._spacy_doc\n\n    def get_tokens(self) -&gt; List[str]:\n        return self._tokens\n\n    def set_tokens(self, tokens: List[str]):\n        self._tokens = tokens\n\n    def set_entities(self, entities: List[Dict[str, Any]]):\n        self._entities = entities\n\n    def get_entities(self) -&gt; List[Dict[str, Any]]:\n        return self._entities\n\n    def get_embeddings(self) -&gt; Optional[List[float]]:\n        return self._embeddings\n\n    def set_embeddings(self, embeddings: List[float]):\n        self._embeddings = embeddings\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.tabular","title":"<code>tabular</code>","text":""},{"location":"api/containers/#healthchain.io.containers.tabular.Tabular","title":"<code>Tabular</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[DataFrame]</code></p> <p>A container for tabular data, wrapping a pandas DataFrame.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The pandas DataFrame containing the tabular data.</p> <p> TYPE: <code>DataFrame</code> </p> METHOD DESCRIPTION <code>__post_init__</code> <p>Validates that the data is a pandas DataFrame.</p> <code>columns</code> <p>Property that returns a list of column names.</p> <code>index</code> <p>Property that returns the DataFrame's index.</p> <code>dtypes</code> <p>Property that returns a dictionary of column names and their data types.</p> <code>column_count</code> <p>Returns the number of columns in the DataFrame.</p> <code>row_count</code> <p>Returns the number of rows in the DataFrame.</p> <code>get_dtype</code> <p>str): Returns the data type of a specific column.</p> <code>__iter__</code> <p>Returns an iterator over the column names.</p> <code>__len__</code> <p>Returns the number of rows in the DataFrame.</p> <code>describe</code> <p>Returns a string description of the tabular data.</p> <code>remove_column</code> <p>str): Removes a column from the DataFrame.</p> <code>from_csv</code> <p>str, **kwargs): Class method to create a Tabular object from a CSV file.</p> <code>from_dict</code> <p>Dict[str, Any]): Class method to create a Tabular object from a dictionary.</p> <code>to_csv</code> <p>str, **kwargs): Saves the DataFrame to a CSV file.</p> Source code in <code>healthchain/io/containers/tabular.py</code> <pre><code>@dataclass\nclass Tabular(DataContainer[pd.DataFrame]):\n    \"\"\"\n    A container for tabular data, wrapping a pandas DataFrame.\n\n    Attributes:\n        data (pd.DataFrame): The pandas DataFrame containing the tabular data.\n\n    Methods:\n        __post_init__(): Validates that the data is a pandas DataFrame.\n        columns: Property that returns a list of column names.\n        index: Property that returns the DataFrame's index.\n        dtypes: Property that returns a dictionary of column names and their data types.\n        column_count(): Returns the number of columns in the DataFrame.\n        row_count(): Returns the number of rows in the DataFrame.\n        get_dtype(column: str): Returns the data type of a specific column.\n        __iter__(): Returns an iterator over the column names.\n        __len__(): Returns the number of rows in the DataFrame.\n        describe(): Returns a string description of the tabular data.\n        remove_column(name: str): Removes a column from the DataFrame.\n        from_csv(path: str, **kwargs): Class method to create a Tabular object from a CSV file.\n        from_dict(data: Dict[str, Any]): Class method to create a Tabular object from a dictionary.\n        to_csv(path: str, **kwargs): Saves the DataFrame to a CSV file.\n    \"\"\"\n\n    def __post_init__(self):\n        if not isinstance(self.data, pd.DataFrame):\n            raise TypeError(\"data must be a pandas DataFrame\")\n\n    @property\n    def columns(self) -&gt; List[str]:\n        return list(self.data.columns)\n\n    @property\n    def index(self) -&gt; pd.Index:\n        return self.data.index\n\n    @property\n    def dtypes(self) -&gt; Dict[str, str]:\n        return {col: str(dtype) for col, dtype in self.data.dtypes.items()}\n\n    def column_count(self) -&gt; int:\n        return len(self.columns)\n\n    def row_count(self) -&gt; int:\n        return len(self.data)\n\n    def get_dtype(self, column: str) -&gt; str:\n        return str(self.data[column].dtype)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.columns)\n\n    def __len__(self) -&gt; int:\n        return self.row_count()\n\n    def describe(self) -&gt; str:\n        return f\"Tabular data with {self.column_count()} columns and {self.row_count()} rows\"\n\n    def remove_column(self, name: str) -&gt; None:\n        self.data.drop(columns=[name], inplace=True)\n\n    @classmethod\n    def from_csv(cls, path: str, **kwargs) -&gt; \"Tabular\":\n        return cls(pd.read_csv(path, **kwargs))\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Tabular\":\n        df = pd.DataFrame(**data[\"data\"])\n        return cls(df)\n\n    def to_csv(self, path: str, **kwargs) -&gt; None:\n        self.data.to_csv(path, **kwargs)\n</code></pre>"},{"location":"api/data_generators/","title":"Data Generators","text":""},{"location":"api/data_generators/#healthchain.data_generators.cdsdatagenerator.CdsDataGenerator","title":"<code>CdsDataGenerator</code>","text":"<p>A class to generate CDS (Clinical Decision Support) data based on specified workflows and constraints.</p> <p>This class provides functionality to generate synthetic FHIR resources for testing CDS systems. It uses registered data generators to create resources like Patients, Encounters, Conditions etc. based on configured workflows. It can also incorporate free text data from CSV files.</p> ATTRIBUTE DESCRIPTION <code>registry</code> <p>A registry mapping generator names to generator classes.</p> <p> TYPE: <code>dict</code> </p> <code>mappings</code> <p>A mapping of workflow names to lists of required generators.</p> <p> TYPE: <code>dict</code> </p> <code>generated_data</code> <p>The most recently generated FHIR resources.</p> <p> TYPE: <code>Dict[str, Resource]</code> </p> <code>workflow</code> <p>The currently active workflow.</p> <p> TYPE: <code>str</code> </p> Example <p>generator = CdsDataGenerator() generator.set_workflow(\"encounter_discharge\") data = generator.generate_prefetch( ...     random_seed=42 ... )</p> Source code in <code>healthchain/data_generators/cdsdatagenerator.py</code> <pre><code>class CdsDataGenerator:\n    \"\"\"\n    A class to generate CDS (Clinical Decision Support) data based on specified workflows and constraints.\n\n    This class provides functionality to generate synthetic FHIR resources for testing CDS systems.\n    It uses registered data generators to create resources like Patients, Encounters, Conditions etc.\n    based on configured workflows. It can also incorporate free text data from CSV files.\n\n    Attributes:\n        registry (dict): A registry mapping generator names to generator classes.\n        mappings (dict): A mapping of workflow names to lists of required generators.\n        generated_data (Dict[str, Resource]): The most recently generated FHIR resources.\n        workflow (str): The currently active workflow.\n\n    Example:\n        &gt;&gt;&gt; generator = CdsDataGenerator()\n        &gt;&gt;&gt; generator.set_workflow(\"encounter_discharge\")\n        &gt;&gt;&gt; data = generator.generate_prefetch(\n        ...     random_seed=42\n        ... )\n    \"\"\"\n\n    # TODO: Add ordering and logic so that patient/encounter IDs are passed to subsequent generators\n    # TODO: Some of the resources should be allowed to be multiplied\n\n    default_workflow_mappings = {\n        Workflow.encounter_discharge: [\n            {\"generator\": \"EncounterGenerator\"},\n            {\"generator\": \"ConditionGenerator\"},\n            {\"generator\": \"ProcedureGenerator\"},\n            {\"generator\": \"MedicationRequestGenerator\"},\n        ],\n        Workflow.patient_view: [\n            {\"generator\": \"PatientGenerator\"},\n            {\"generator\": \"EncounterGenerator\"},\n            {\"generator\": \"ConditionGenerator\"},\n        ],\n    }\n\n    def __init__(self):\n        self.registry = generator_registry\n        self.mappings = self.default_workflow_mappings\n        self.generated_data: Dict[str, Resource] = {}\n\n    def fetch_generator(self, generator_name: str) -&gt; Callable:\n        \"\"\"\n        Fetches a data generator class by its name from the registry.\n\n        Args:\n            generator_name (str): The name of the data generator to fetch (e.g. \"PatientGenerator\", \"EncounterGenerator\")\n\n        Returns:\n            Callable: The data generator class that can be used to generate FHIR resources. Returns None if generator not found.\n\n        Example:\n            &gt;&gt;&gt; generator = CdsDataGenerator()\n            &gt;&gt;&gt; patient_gen = generator.fetch_generator(\"PatientGenerator\")\n            &gt;&gt;&gt; patient = patient_gen.generate()\n        \"\"\"\n        return self.registry.get(generator_name)\n\n    def set_workflow(self, workflow: str) -&gt; None:\n        \"\"\"\n        Sets the current workflow to be used for data generation.\n\n        Parameters:\n            workflow (str): The name of the workflow to set.\n        \"\"\"\n        self.workflow = workflow\n\n    def generate_prefetch(\n        self,\n        constraints: Optional[list] = None,\n        free_text_path: Optional[str] = None,\n        column_name: Optional[str] = None,\n        random_seed: Optional[int] = None,\n    ) -&gt; Prefetch:\n        \"\"\"\n        Generates CDS data based on the current workflow, constraints, and optional free text data.\n\n        This method generates FHIR resources according to the configured workflow mapping. For each\n        resource type in the workflow, it uses the corresponding generator to create a FHIR resource.\n        If free text data is provided via CSV, it will also generate a DocumentReference containing\n        randomly selected text from the CSV.\n\n        Args:\n            constraints (Optional[list]): A list of constraints to apply to the data generation.\n                Each constraint should match the format expected by the individual generators.\n            free_text_path (Optional[str]): Path to a CSV file containing free text data to be\n                included as DocumentReferences. If provided, column_name must also be specified.\n            column_name (Optional[str]): The name of the column in the CSV file containing the\n                free text data to use. Required if free_text_path is provided.\n            random_seed (Optional[int]): Seed value for random number generation to ensure\n                reproducible results. If not provided, generation will be truly random.\n\n        Returns:\n            Prefetch: A dictionary mapping resource types to generated FHIR resources.\n                The keys are lowercase resource type names (e.g. \"patient\", \"encounter\").\n                If free text is provided, includes a \"document\" key with a DocumentReference.\n\n        Raises:\n            ValueError: If the configured workflow is not found in the mappings\n            FileNotFoundError: If the free_text_path is provided but file not found\n            ValueError: If free_text_path provided without column_name\n        \"\"\"\n        prefetch = Prefetch(prefetch={})\n\n        if self.workflow not in self.mappings.keys():\n            raise ValueError(f\"Workflow {self.workflow} not found in mappings\")\n\n        for resource in self.mappings[self.workflow]:\n            generator_name = resource[\"generator\"]\n            generator = self.fetch_generator(generator_name)\n            resource = generator.generate(\n                constraints=constraints, random_seed=random_seed\n            )\n\n            prefetch.prefetch[resource.__resource_type__.lower()] = resource\n\n        parsed_free_text = (\n            self.free_text_parser(free_text_path, column_name)\n            if free_text_path\n            else None\n        )\n        if parsed_free_text:\n            prefetch.prefetch[\"document\"] = create_document_reference(\n                data=random.choice(parsed_free_text),\n                content_type=\"text/plain\",\n                status=\"current\",\n                description=\"Free text created by HealthChain CdsDataGenerator\",\n                attachment_title=\"Free text created by HealthChain CdsDataGenerator\",\n            )\n\n        self.generated_data = prefetch\n\n        return self.generated_data\n\n    def free_text_parser(self, path_to_csv: str, column_name: str) -&gt; List[str]:\n        \"\"\"\n        Parse free text data from a CSV file.\n\n        This method reads a CSV file and extracts text data from a specified column. The text data\n        can later be used to create DocumentReference resources.\n\n        Args:\n            path_to_csv (str): Path to the CSV file containing the free text data.\n            column_name (str): Name of the column in the CSV file to extract text from.\n\n        Returns:\n            List[str]: List of text strings extracted from the specified column.\n\n        Raises:\n            FileNotFoundError: If the specified CSV file does not exist or is not a file.\n            ValueError: If column_name is not provided.\n            Exception: If any other error occurs while reading/parsing the CSV file.\n        \"\"\"\n        text_data = []\n\n        # Check that path_to_csv is a valid path with pathlib\n        path = Path(path_to_csv)\n        if not path.is_file():\n            raise FileNotFoundError(\n                f\"The file {path_to_csv} does not exist or is not a file.\"\n            )\n\n        try:\n            with path.open(mode=\"r\", newline=\"\") as file:\n                reader = csv.DictReader(file)\n                if column_name is not None:\n                    for row in reader:\n                        text_data.append(row[column_name])\n                else:\n                    raise ValueError(\n                        \"Column name must be provided when header is True.\"\n                    )\n        except Exception as ex:\n            logger.error(f\"An error occurred: {ex}\")\n\n        return text_data\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.cdsdatagenerator.CdsDataGenerator.fetch_generator","title":"<code>fetch_generator(generator_name)</code>","text":"<p>Fetches a data generator class by its name from the registry.</p> PARAMETER DESCRIPTION <code>generator_name</code> <p>The name of the data generator to fetch (e.g. \"PatientGenerator\", \"EncounterGenerator\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>The data generator class that can be used to generate FHIR resources. Returns None if generator not found.</p> <p> TYPE: <code>Callable</code> </p> Example <p>generator = CdsDataGenerator() patient_gen = generator.fetch_generator(\"PatientGenerator\") patient = patient_gen.generate()</p> Source code in <code>healthchain/data_generators/cdsdatagenerator.py</code> <pre><code>def fetch_generator(self, generator_name: str) -&gt; Callable:\n    \"\"\"\n    Fetches a data generator class by its name from the registry.\n\n    Args:\n        generator_name (str): The name of the data generator to fetch (e.g. \"PatientGenerator\", \"EncounterGenerator\")\n\n    Returns:\n        Callable: The data generator class that can be used to generate FHIR resources. Returns None if generator not found.\n\n    Example:\n        &gt;&gt;&gt; generator = CdsDataGenerator()\n        &gt;&gt;&gt; patient_gen = generator.fetch_generator(\"PatientGenerator\")\n        &gt;&gt;&gt; patient = patient_gen.generate()\n    \"\"\"\n    return self.registry.get(generator_name)\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.cdsdatagenerator.CdsDataGenerator.free_text_parser","title":"<code>free_text_parser(path_to_csv, column_name)</code>","text":"<p>Parse free text data from a CSV file.</p> <p>This method reads a CSV file and extracts text data from a specified column. The text data can later be used to create DocumentReference resources.</p> PARAMETER DESCRIPTION <code>path_to_csv</code> <p>Path to the CSV file containing the free text data.</p> <p> TYPE: <code>str</code> </p> <code>column_name</code> <p>Name of the column in the CSV file to extract text from.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: List of text strings extracted from the specified column.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the specified CSV file does not exist or is not a file.</p> <code>ValueError</code> <p>If column_name is not provided.</p> <code>Exception</code> <p>If any other error occurs while reading/parsing the CSV file.</p> Source code in <code>healthchain/data_generators/cdsdatagenerator.py</code> <pre><code>def free_text_parser(self, path_to_csv: str, column_name: str) -&gt; List[str]:\n    \"\"\"\n    Parse free text data from a CSV file.\n\n    This method reads a CSV file and extracts text data from a specified column. The text data\n    can later be used to create DocumentReference resources.\n\n    Args:\n        path_to_csv (str): Path to the CSV file containing the free text data.\n        column_name (str): Name of the column in the CSV file to extract text from.\n\n    Returns:\n        List[str]: List of text strings extracted from the specified column.\n\n    Raises:\n        FileNotFoundError: If the specified CSV file does not exist or is not a file.\n        ValueError: If column_name is not provided.\n        Exception: If any other error occurs while reading/parsing the CSV file.\n    \"\"\"\n    text_data = []\n\n    # Check that path_to_csv is a valid path with pathlib\n    path = Path(path_to_csv)\n    if not path.is_file():\n        raise FileNotFoundError(\n            f\"The file {path_to_csv} does not exist or is not a file.\"\n        )\n\n    try:\n        with path.open(mode=\"r\", newline=\"\") as file:\n            reader = csv.DictReader(file)\n            if column_name is not None:\n                for row in reader:\n                    text_data.append(row[column_name])\n            else:\n                raise ValueError(\n                    \"Column name must be provided when header is True.\"\n                )\n    except Exception as ex:\n        logger.error(f\"An error occurred: {ex}\")\n\n    return text_data\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.cdsdatagenerator.CdsDataGenerator.generate_prefetch","title":"<code>generate_prefetch(constraints=None, free_text_path=None, column_name=None, random_seed=None)</code>","text":"<p>Generates CDS data based on the current workflow, constraints, and optional free text data.</p> <p>This method generates FHIR resources according to the configured workflow mapping. For each resource type in the workflow, it uses the corresponding generator to create a FHIR resource. If free text data is provided via CSV, it will also generate a DocumentReference containing randomly selected text from the CSV.</p> PARAMETER DESCRIPTION <code>constraints</code> <p>A list of constraints to apply to the data generation. Each constraint should match the format expected by the individual generators.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>free_text_path</code> <p>Path to a CSV file containing free text data to be included as DocumentReferences. If provided, column_name must also be specified.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>column_name</code> <p>The name of the column in the CSV file containing the free text data to use. Required if free_text_path is provided.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>random_seed</code> <p>Seed value for random number generation to ensure reproducible results. If not provided, generation will be truly random.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Prefetch</code> <p>A dictionary mapping resource types to generated FHIR resources. The keys are lowercase resource type names (e.g. \"patient\", \"encounter\"). If free text is provided, includes a \"document\" key with a DocumentReference.</p> <p> TYPE: <code>Prefetch</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the configured workflow is not found in the mappings</p> <code>FileNotFoundError</code> <p>If the free_text_path is provided but file not found</p> <code>ValueError</code> <p>If free_text_path provided without column_name</p> Source code in <code>healthchain/data_generators/cdsdatagenerator.py</code> <pre><code>def generate_prefetch(\n    self,\n    constraints: Optional[list] = None,\n    free_text_path: Optional[str] = None,\n    column_name: Optional[str] = None,\n    random_seed: Optional[int] = None,\n) -&gt; Prefetch:\n    \"\"\"\n    Generates CDS data based on the current workflow, constraints, and optional free text data.\n\n    This method generates FHIR resources according to the configured workflow mapping. For each\n    resource type in the workflow, it uses the corresponding generator to create a FHIR resource.\n    If free text data is provided via CSV, it will also generate a DocumentReference containing\n    randomly selected text from the CSV.\n\n    Args:\n        constraints (Optional[list]): A list of constraints to apply to the data generation.\n            Each constraint should match the format expected by the individual generators.\n        free_text_path (Optional[str]): Path to a CSV file containing free text data to be\n            included as DocumentReferences. If provided, column_name must also be specified.\n        column_name (Optional[str]): The name of the column in the CSV file containing the\n            free text data to use. Required if free_text_path is provided.\n        random_seed (Optional[int]): Seed value for random number generation to ensure\n            reproducible results. If not provided, generation will be truly random.\n\n    Returns:\n        Prefetch: A dictionary mapping resource types to generated FHIR resources.\n            The keys are lowercase resource type names (e.g. \"patient\", \"encounter\").\n            If free text is provided, includes a \"document\" key with a DocumentReference.\n\n    Raises:\n        ValueError: If the configured workflow is not found in the mappings\n        FileNotFoundError: If the free_text_path is provided but file not found\n        ValueError: If free_text_path provided without column_name\n    \"\"\"\n    prefetch = Prefetch(prefetch={})\n\n    if self.workflow not in self.mappings.keys():\n        raise ValueError(f\"Workflow {self.workflow} not found in mappings\")\n\n    for resource in self.mappings[self.workflow]:\n        generator_name = resource[\"generator\"]\n        generator = self.fetch_generator(generator_name)\n        resource = generator.generate(\n            constraints=constraints, random_seed=random_seed\n        )\n\n        prefetch.prefetch[resource.__resource_type__.lower()] = resource\n\n    parsed_free_text = (\n        self.free_text_parser(free_text_path, column_name)\n        if free_text_path\n        else None\n    )\n    if parsed_free_text:\n        prefetch.prefetch[\"document\"] = create_document_reference(\n            data=random.choice(parsed_free_text),\n            content_type=\"text/plain\",\n            status=\"current\",\n            description=\"Free text created by HealthChain CdsDataGenerator\",\n            attachment_title=\"Free text created by HealthChain CdsDataGenerator\",\n        )\n\n    self.generated_data = prefetch\n\n    return self.generated_data\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.cdsdatagenerator.CdsDataGenerator.set_workflow","title":"<code>set_workflow(workflow)</code>","text":"<p>Sets the current workflow to be used for data generation.</p> PARAMETER DESCRIPTION <code>workflow</code> <p>The name of the workflow to set.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/data_generators/cdsdatagenerator.py</code> <pre><code>def set_workflow(self, workflow: str) -&gt; None:\n    \"\"\"\n    Sets the current workflow to be used for data generation.\n\n    Parameters:\n        workflow (str): The name of the workflow to set.\n    \"\"\"\n    self.workflow = workflow\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.ClassGenerator","title":"<code>ClassGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR Class resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Generates a FHIR Class resource.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass ClassGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR Class resources.\n\n    Methods:\n        generate() -&gt; CodeableConcept:\n            Generates a FHIR Class resource.\n    \"\"\"\n\n    @staticmethod\n    def generate() -&gt; CodeableConcept:\n        patient_class_mapping = {\"IMP\": \"inpatient\", \"AMB\": \"ambulatory\"}\n        patient_class = faker.random_element(elements=(\"IMP\", \"AMB\"))\n        return CodeableConcept(\n            coding=[\n                Coding(\n                    system=\"http://terminology.hl7.org/CodeSystem/v3-ActCode\",\n                    code=patient_class,\n                    display=patient_class_mapping.get(patient_class),\n                )\n            ]\n        )\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.EncounterGenerator","title":"<code>EncounterGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR Encounter resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Optional[list] = None, random_seed: Optional[int] = None) -&gt; Encounter: Generates a FHIR Encounter resource with optional constraints and random_seed.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass EncounterGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR Encounter resources.\n\n    Methods:\n        generate(constraints: Optional[list] = None, random_seed: Optional[int] = None) -&gt; Encounter:\n            Generates a FHIR Encounter resource with optional constraints and random_seed.\n    \"\"\"\n\n    @staticmethod\n    def generate(\n        constraints: Optional[list] = None,\n        random_seed: Optional[int] = None,\n    ) -&gt; Encounter:\n        Faker.seed(random_seed)\n        patient_reference = \"Patient/123\"\n        return Encounter(\n            id=generator_registry.get(\"IdGenerator\").generate(),\n            status=faker.random_element(\n                elements=(\n                    \"planned\",\n                    \"in-progress\",\n                    \"on-hold\",\n                    \"discharged\",\n                    \"cancelled\",\n                )\n            ),\n            class_fhir=[generator_registry.get(\"ClassGenerator\").generate()],\n            priority=generator_registry.get(\"EncounterPriorityGenerator\").generate(),\n            type=[generator_registry.get(\"EncounterTypeGenerator\").generate()],\n            subject={\"reference\": patient_reference, \"display\": patient_reference},\n            actualPeriod=generator_registry.get(\"PeriodGenerator\").generate(),\n            location=[generator_registry.get(\"EncounterLocationGenerator\").generate()],\n        )\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.EncounterLocationGenerator","title":"<code>EncounterLocationGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR EncounterLocation resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Generates a FHIR EncounterLocation resource.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass EncounterLocationGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR EncounterLocation resources.\n\n    Methods:\n        generate() -&gt; EncounterLocation:\n            Generates a FHIR EncounterLocation resource.\n    \"\"\"\n\n    @staticmethod\n    def generate() -&gt; EncounterLocation:\n        return EncounterLocation(\n            location=Reference(reference=\"Location/123\"),\n            status=faker.random_element(elements=(\"active\", \"completed\")),\n            period=generator_registry.get(\"PeriodGenerator\").generate(),\n        )\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.EncounterPriorityGenerator","title":"<code>EncounterPriorityGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR EncounterPriority resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Generates a FHIR EncounterPriority resource.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass EncounterPriorityGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR EncounterPriority resources.\n\n    Methods:\n        generate() -&gt; CodeableConcept:\n            Generates a FHIR EncounterPriority resource.\n    \"\"\"\n\n    @staticmethod\n    def generate() -&gt; CodeableConcept:\n        encounter_priority_mapping = {\"17621005\": \"normal\", \"24484000\": \"critical\"}\n        encounter_priority = faker.random_element(elements=(\"17621005\", \"24484000\"))\n        return CodeableConcept(\n            coding=[\n                Coding(\n                    system=\"http://snomed.info/sct\",\n                    code=encounter_priority,\n                    display=encounter_priority_mapping.get(encounter_priority),\n                )\n            ]\n        )\n</code></pre>"},{"location":"api/data_generators/#healthchain.data_generators.encountergenerators.EncounterTypeGenerator","title":"<code>EncounterTypeGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>A generator class for creating FHIR EncounterType resources.</p> METHOD DESCRIPTION <code>generate</code> <p>Generates a FHIR EncounterType resource.</p> Source code in <code>healthchain/data_generators/encountergenerators.py</code> <pre><code>@register_generator\nclass EncounterTypeGenerator(BaseGenerator):\n    \"\"\"\n    A generator class for creating FHIR EncounterType resources.\n\n    Methods:\n        generate() -&gt; CodeableConcept:\n            Generates a FHIR EncounterType resource.\n    \"\"\"\n\n    @staticmethod\n    def generate() -&gt; CodeableConcept:\n        encounter_type_mapping = {\"11429006\": \"consultation\", \"50849002\": \"emergency\"}\n        encounter_type = faker.random_element(elements=(\"11429006\", \"50849002\"))\n        return CodeableConcept(\n            coding=[\n                Coding(\n                    system=\"http://snomed.info/sct\",\n                    code=encounter_type,\n                    display=encounter_type_mapping.get(encounter_type),\n                )\n            ]\n        )\n</code></pre>"},{"location":"api/fhir_helpers/","title":"FHIR Helpers","text":"<p>FHIR utilities for HealthChain.</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.add_resource","title":"<code>add_resource(bundle, resource, full_url=None)</code>","text":"<p>Add a resource to a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to add to</p> <p> TYPE: <code>Bundle</code> </p> <code>resource</code> <p>The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance</p> <p> TYPE: <code>Resource</code> </p> <code>full_url</code> <p>Optional full URL for the resource</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def add_resource(\n    bundle: Bundle, resource: Resource, full_url: Optional[str] = None\n) -&gt; None:\n    \"\"\"Add a resource to a bundle.\n\n    Args:\n        bundle: The bundle to add to\n        resource: The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance\n        full_url: Optional full URL for the resource\n    \"\"\"\n    entry = BundleEntry(resource=resource)\n    if full_url:\n        entry.fullUrl = full_url\n    bundle.entry = (bundle.entry or []) + [entry]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_allergy_intolerance","title":"<code>create_allergy_intolerance(patient, code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal active FHIR AllergyIntolerance. If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly. https://build.fhir.org/allergyintolerance.html</p> PARAMETER DESCRIPTION <code>patient</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>code</code> <p>The allergen code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the allergen</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>AllergyIntolerance</code> <p>A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>AllergyIntolerance</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_allergy_intolerance(\n    patient: str,\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; AllergyIntolerance:\n    \"\"\"\n    Create a minimal active FHIR AllergyIntolerance.\n    If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly.\n    https://build.fhir.org/allergyintolerance.html\n\n    Args:\n        patient: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        code: The allergen code\n        display: The display name for the allergen\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        AllergyIntolerance: A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        allergy_code = create_single_codeable_concept(code, display, system)\n    else:\n        allergy_code = None\n\n    allergy = AllergyIntolerance(\n        id=_generate_id(),\n        patient={\"reference\": patient},\n        code=allergy_code,\n    )\n\n    return allergy\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_bundle","title":"<code>create_bundle(bundle_type='collection')</code>","text":"<p>Create an empty FHIR Bundle. https://www.hl7.org/fhir/bundle.html</p> PARAMETER DESCRIPTION <code>bundle_type</code> <p>The type of bundle (default: collection) Valid types: document, message, transaction, transaction-response, batch, batch-response, history, searchset, collection</p> <p> TYPE: <code>str</code> DEFAULT: <code>'collection'</code> </p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def create_bundle(bundle_type: str = \"collection\") -&gt; Bundle:\n    \"\"\"Create an empty FHIR Bundle.\n    https://www.hl7.org/fhir/bundle.html\n\n    Args:\n        bundle_type: The type of bundle (default: collection)\n            Valid types: document, message, transaction, transaction-response,\n            batch, batch-response, history, searchset, collection\n    \"\"\"\n    return Bundle(type=bundle_type, entry=[])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_condition","title":"<code>create_condition(subject, clinical_status='active', code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal active FHIR Condition. If you need to create a more complex condition, use the FHIR Condition resource directly. https://build.fhir.org/condition.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>clinical_status</code> <p>REQUIRED. Clinical status (default: active)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'active'</code> </p> <code>code</code> <p>The condition code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the condition</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Condition</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_condition(\n    subject: str,\n    clinical_status: str = \"active\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; Condition:\n    \"\"\"\n    Create a minimal active FHIR Condition.\n    If you need to create a more complex condition, use the FHIR Condition resource directly.\n    https://build.fhir.org/condition.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        clinical_status: REQUIRED. Clinical status (default: active)\n        code: The condition code\n        display: The display name for the condition\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        Condition: A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        condition_code = create_single_codeable_concept(code, display, system)\n    else:\n        condition_code = None\n\n    condition = Condition(\n        id=_generate_id(),\n        subject={\"reference\": subject},\n        clinicalStatus=create_single_codeable_concept(\n            code=clinical_status,\n            display=clinical_status.capitalize(),\n            system=\"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n        ),\n        code=condition_code,\n    )\n\n    return condition\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_document_reference","title":"<code>create_document_reference(data=None, url=None, content_type=None, status='current', description='DocumentReference created by HealthChain', attachment_title='Attachment created by HealthChain')</code>","text":"<p>Create a minimal FHIR DocumentReference. If you need to create a more complex document reference, use the FHIR DocumentReference resource directly. https://build.fhir.org/documentreference.html</p> PARAMETER DESCRIPTION <code>data</code> <p>The data content of the document attachment</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>URL where the document can be accessed</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content_type</code> <p>MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>REQUIRED. Status of the document reference (default: current)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>description</code> <p>Description of the document reference</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'DocumentReference created by HealthChain'</code> </p> <code>attachment_title</code> <p>Title for the document attachment</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> RETURNS DESCRIPTION <code>DocumentReference</code> <p>A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>DocumentReference</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_document_reference(\n    data: Optional[Any] = None,\n    url: Optional[str] = None,\n    content_type: Optional[str] = None,\n    status: str = \"current\",\n    description: Optional[str] = \"DocumentReference created by HealthChain\",\n    attachment_title: Optional[str] = \"Attachment created by HealthChain\",\n) -&gt; DocumentReference:\n    \"\"\"\n    Create a minimal FHIR DocumentReference.\n    If you need to create a more complex document reference, use the FHIR DocumentReference resource directly.\n    https://build.fhir.org/documentreference.html\n\n    Args:\n        data: The data content of the document attachment\n        url: URL where the document can be accessed\n        content_type: MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")\n        status: REQUIRED. Status of the document reference (default: current)\n        description: Description of the document reference\n        attachment_title: Title for the document attachment\n\n    Returns:\n        DocumentReference: A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    document_reference = DocumentReference(\n        id=_generate_id(),\n        status=status,\n        date=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n        description=description,\n        content=[\n            {\n                \"attachment\": create_single_attachment(\n                    content_type=content_type,\n                    data=data,\n                    url=url,\n                    title=attachment_title,\n                )\n            }\n        ],\n    )\n\n    return document_reference\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_medication_statement","title":"<code>create_medication_statement(subject, status='recorded', code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal recorded FHIR MedicationStatement. If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly. https://build.fhir.org/medicationstatement.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>status</code> <p>REQUIRED. Status of the medication (default: recorded)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'recorded'</code> </p> <code>code</code> <p>The medication code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the medication</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>MedicationStatement</code> <p>A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>MedicationStatement</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_medication_statement(\n    subject: str,\n    status: Optional[str] = \"recorded\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; MedicationStatement:\n    \"\"\"\n    Create a minimal recorded FHIR MedicationStatement.\n    If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly.\n    https://build.fhir.org/medicationstatement.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        status: REQUIRED. Status of the medication (default: recorded)\n        code: The medication code\n        display: The display name for the medication\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        MedicationStatement: A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        medication_concept = create_single_codeable_concept(code, display, system)\n    else:\n        medication_concept = None\n\n    medication = MedicationStatement(\n        id=_generate_id(),\n        subject={\"reference\": subject},\n        status=status,\n        medication={\"concept\": medication_concept},\n    )\n\n    return medication\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_single_attachment","title":"<code>create_single_attachment(content_type=None, data=None, url=None, title='Attachment created by HealthChain')</code>","text":"<p>Create a minimal FHIR Attachment.</p> <p>Creates a FHIR Attachment resource with basic fields. Either data or url should be provided. If data is provided, it will be base64 encoded.</p> PARAMETER DESCRIPTION <code>content_type</code> <p>The MIME type of the content</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>data</code> <p>The actual data content to be base64 encoded</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>The URL where the data can be found</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>A title for the attachment (default: \"Attachment created by HealthChain\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> RETURNS DESCRIPTION <code>Attachment</code> <p>A FHIR Attachment resource with basic metadata and content</p> <p> TYPE: <code>Attachment</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_attachment(\n    content_type: Optional[str] = None,\n    data: Optional[str] = None,\n    url: Optional[str] = None,\n    title: Optional[str] = \"Attachment created by HealthChain\",\n) -&gt; Attachment:\n    \"\"\"Create a minimal FHIR Attachment.\n\n    Creates a FHIR Attachment resource with basic fields. Either data or url should be provided.\n    If data is provided, it will be base64 encoded.\n\n    Args:\n        content_type: The MIME type of the content\n        data: The actual data content to be base64 encoded\n        url: The URL where the data can be found\n        title: A title for the attachment (default: \"Attachment created by HealthChain\")\n\n    Returns:\n        Attachment: A FHIR Attachment resource with basic metadata and content\n    \"\"\"\n\n    if not data and not url:\n        logger.warning(\"No data or url provided for attachment\")\n\n    if data:\n        data = base64.b64encode(data.encode(\"utf-8\")).decode(\"utf-8\")\n\n    return Attachment(\n        contentType=content_type,\n        data=data,\n        url=url,\n        title=title,\n        creation=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n    )\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_single_codeable_concept","title":"<code>create_single_codeable_concept(code, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal FHIR CodeableConcept with a single coding.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>CodeableConcept</code> <p>A FHIR CodeableConcept resource with a single coding</p> <p> TYPE: <code>CodeableConcept</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_codeable_concept(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; CodeableConcept:\n    \"\"\"\n    Create a minimal FHIR CodeableConcept with a single coding.\n\n    Args:\n        code: REQUIRED. The code value from the code system\n        display: The display name for the code\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        CodeableConcept: A FHIR CodeableConcept resource with a single coding\n    \"\"\"\n    return CodeableConcept(coding=[Coding(system=system, code=code, display=display)])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_single_reaction","title":"<code>create_single_reaction(code, display=None, system='http://snomed.info/sct', severity=None)</code>","text":"<p>Create a minimal FHIR Reaction with a single coding.</p> <p>Creates a FHIR Reaction object with a single manifestation coding. The manifestation describes the clinical reaction that was observed. The severity indicates how severe the reaction was.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system representing the reaction manifestation</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the manifestation code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system for the manifestation code (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>severity</code> <p>The severity of the reaction (mild, moderate, severe)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>A list containing a single FHIR Reaction dictionary with manifestation and severity fields</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_reaction(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    severity: Optional[str] = None,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create a minimal FHIR Reaction with a single coding.\n\n    Creates a FHIR Reaction object with a single manifestation coding. The manifestation\n    describes the clinical reaction that was observed. The severity indicates how severe\n    the reaction was.\n\n    Args:\n        code: REQUIRED. The code value from the code system representing the reaction manifestation\n        display: The display name for the manifestation code\n        system: The code system for the manifestation code (default: SNOMED CT)\n        severity: The severity of the reaction (mild, moderate, severe)\n\n    Returns:\n        A list containing a single FHIR Reaction dictionary with manifestation and severity fields\n    \"\"\"\n    return [\n        {\n            \"manifestation\": [\n                CodeableReference(\n                    concept=CodeableConcept(\n                        coding=[Coding(system=system, code=code, display=display)]\n                    )\n                )\n            ],\n            \"severity\": severity,\n        }\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resources","title":"<code>get_resources(bundle, resource_type)</code>","text":"<p>Get all resources of a specific type from a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to search</p> <p> TYPE: <code>Bundle</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List of resources of the specified type</p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def get_resources(\n    bundle: Bundle, resource_type: Union[str, Type[Resource]]\n) -&gt; List[Resource]:\n    \"\"\"Get all resources of a specific type from a bundle.\n\n    Args:\n        bundle: The bundle to search\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n\n    Returns:\n        List of resources of the specified type\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Using string identifier\n        &gt;&gt;&gt; conditions = get_resources(bundle, \"Condition\")\n        &gt;&gt;&gt; medications = get_resources(bundle, \"MedicationStatement\")\n        &gt;&gt;&gt; allergies = get_resources(bundle, \"AllergyIntolerance\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; conditions = get_resources(bundle, Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n    return [\n        entry.resource\n        for entry in (bundle.entry or [])\n        if isinstance(entry.resource, type_class)\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resources--using-string-identifier","title":"Using string identifier","text":"<p>conditions = get_resources(bundle, \"Condition\") medications = get_resources(bundle, \"MedicationStatement\") allergies = get_resources(bundle, \"AllergyIntolerance\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition conditions = get_resources(bundle, Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.read_content_attachment","title":"<code>read_content_attachment(document_reference, include_data=True)</code>","text":"<p>Read the attachments in a human readable format from a FHIR DocumentReference content field.</p> PARAMETER DESCRIPTION <code>document_reference</code> <p>The FHIR DocumentReference resource</p> <p> TYPE: <code>DocumentReference</code> </p> <code>include_data</code> <p>Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Optional[List[Dict[str, Any]]]</code> <p>Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata, or None if no attachments are found: [     {         \"data\": str,         \"metadata\": Dict[str, Any]     } ]</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def read_content_attachment(\n    document_reference: DocumentReference,\n    include_data: bool = True,\n) -&gt; Optional[List[Dict[str, Any]]]:\n    \"\"\"Read the attachments in a human readable format from a FHIR DocumentReference content field.\n\n    Args:\n        document_reference: The FHIR DocumentReference resource\n        include_data: Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)\n\n    Returns:\n        Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata,\n            or None if no attachments are found:\n            [\n                {\n                    \"data\": str,\n                    \"metadata\": Dict[str, Any]\n                }\n            ]\n    \"\"\"\n    if not document_reference.content:\n        return None\n\n    attachments = []\n    for content in document_reference.content:\n        attachment = content.attachment\n        result = {}\n\n        if include_data:\n            result[\"data\"] = (\n                attachment.url if attachment.url else attachment.data.decode(\"utf-8\")\n            )\n\n        result[\"metadata\"] = {\n            \"content_type\": attachment.contentType,\n            \"title\": attachment.title,\n            \"creation\": attachment.creation,\n        }\n\n        attachments.append(result)\n\n    return attachments\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_problem_list_item_category","title":"<code>set_problem_list_item_category(condition)</code>","text":"<p>Set the category of a FHIR Condition to problem-list-item.</p> <p>Sets the category field of a FHIR Condition resource to indicate it is a problem list item. This is commonly used to distinguish conditions that are part of the patient's active problem list from other types of conditions (e.g. encounter-diagnosis).</p> PARAMETER DESCRIPTION <code>condition</code> <p>The FHIR Condition resource to modify</p> <p> TYPE: <code>Condition</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>The modified FHIR Condition resource with problem-list-item category set</p> <p> TYPE: <code>Condition</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def set_problem_list_item_category(condition: Condition) -&gt; Condition:\n    \"\"\"Set the category of a FHIR Condition to problem-list-item.\n\n    Sets the category field of a FHIR Condition resource to indicate it is a problem list item.\n    This is commonly used to distinguish conditions that are part of the patient's active\n    problem list from other types of conditions (e.g. encounter-diagnosis).\n\n    Args:\n        condition: The FHIR Condition resource to modify\n\n    Returns:\n        Condition: The modified FHIR Condition resource with problem-list-item category set\n    \"\"\"\n    condition.category = [\n        create_single_codeable_concept(\n            code=\"problem-list-item\",\n            display=\"Problem List Item\",\n            system=\"http://terminology.hl7.org/CodeSystem/condition-category\",\n        )\n    ]\n    return condition\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources","title":"<code>set_resources(bundle, resources, resource_type, replace=True)</code>","text":"<p>Set resources of a specific type in the bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to modify</p> <p> TYPE: <code>Bundle</code> </p> <code>resources</code> <p>The new resources to add</p> <p> TYPE: <code>List[Resource]</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> <code>replace</code> <p>If True, remove existing resources of this type before adding new ones.     If False, append new resources to existing ones. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def set_resources(\n    bundle: Bundle,\n    resources: List[Resource],\n    resource_type: Union[str, Type[Resource]],\n    replace: bool = True,\n) -&gt; None:\n    \"\"\"Set resources of a specific type in the bundle.\n\n    Args:\n        bundle: The bundle to modify\n        resources: The new resources to add\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n        replace: If True, remove existing resources of this type before adding new ones.\n                If False, append new resources to existing ones. Defaults to True.\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Append to existing resources (default behavior)\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], \"Condition\")\n        &gt;&gt;&gt; set_resources(bundle, [medication1], \"MedicationStatement\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Replace existing resources\n        &gt;&gt;&gt; set_resources(bundle, [condition3], \"Condition\", replace=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n\n    # Remove existing resources of this type if replace=True\n    if replace:\n        bundle.entry = [\n            entry\n            for entry in (bundle.entry or [])\n            if not isinstance(entry.resource, type_class)\n        ]\n\n    # Add new resources\n    for resource in resources:\n        if not isinstance(resource, type_class):\n            raise ValueError(\n                f\"Resource must be of type {type_class.__name__}, \"\n                f\"got {type(resource).__name__}\"\n            )\n        add_resource(bundle, resource)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources--append-to-existing-resources-default-behavior","title":"Append to existing resources (default behavior)","text":"<p>set_resources(bundle, [condition1, condition2], \"Condition\") set_resources(bundle, [medication1], \"MedicationStatement\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources--replace-existing-resources","title":"Replace existing resources","text":"<p>set_resources(bundle, [condition3], \"Condition\", replace=True)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition set_resources(bundle, [condition1, condition2], Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers","title":"<code>bundle_helpers</code>","text":"<p>Helper functions for working with FHIR Bundles.</p> Example usage <p>from healthchain.fhir import create_bundle, get_resources, set_resources</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers--create-a-bundle","title":"Create a bundle","text":"<p>bundle = create_bundle()</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers--add-and-retrieve-conditions","title":"Add and retrieve conditions","text":"<p>conditions = get_resources(bundle, \"Condition\") set_resources(bundle, [new_condition], \"Condition\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers--add-and-retrieve-medications","title":"Add and retrieve medications","text":"<p>medications = get_resources(bundle, \"MedicationStatement\") set_resources(bundle, [new_medication], \"MedicationStatement\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers--add-and-retrieve-allergies","title":"Add and retrieve allergies","text":"<p>allergies = get_resources(bundle, \"AllergyIntolerance\") set_resources(bundle, [new_allergy], \"AllergyIntolerance\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.add_resource","title":"<code>add_resource(bundle, resource, full_url=None)</code>","text":"<p>Add a resource to a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to add to</p> <p> TYPE: <code>Bundle</code> </p> <code>resource</code> <p>The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance</p> <p> TYPE: <code>Resource</code> </p> <code>full_url</code> <p>Optional full URL for the resource</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def add_resource(\n    bundle: Bundle, resource: Resource, full_url: Optional[str] = None\n) -&gt; None:\n    \"\"\"Add a resource to a bundle.\n\n    Args:\n        bundle: The bundle to add to\n        resource: The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance\n        full_url: Optional full URL for the resource\n    \"\"\"\n    entry = BundleEntry(resource=resource)\n    if full_url:\n        entry.fullUrl = full_url\n    bundle.entry = (bundle.entry or []) + [entry]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.create_bundle","title":"<code>create_bundle(bundle_type='collection')</code>","text":"<p>Create an empty FHIR Bundle. https://www.hl7.org/fhir/bundle.html</p> PARAMETER DESCRIPTION <code>bundle_type</code> <p>The type of bundle (default: collection) Valid types: document, message, transaction, transaction-response, batch, batch-response, history, searchset, collection</p> <p> TYPE: <code>str</code> DEFAULT: <code>'collection'</code> </p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def create_bundle(bundle_type: str = \"collection\") -&gt; Bundle:\n    \"\"\"Create an empty FHIR Bundle.\n    https://www.hl7.org/fhir/bundle.html\n\n    Args:\n        bundle_type: The type of bundle (default: collection)\n            Valid types: document, message, transaction, transaction-response,\n            batch, batch-response, history, searchset, collection\n    \"\"\"\n    return Bundle(type=bundle_type, entry=[])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.get_resource_type","title":"<code>get_resource_type(resource_type)</code>","text":"<p>Get the resource type class from string or type.</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>Type[Resource]</code> <p>The resource type class</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the resource type is not supported or cannot be imported</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def get_resource_type(resource_type: Union[str, Type[Resource]]) -&gt; Type[Resource]:\n    \"\"\"Get the resource type class from string or type.\n\n    Args:\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n\n    Returns:\n        The resource type class\n\n    Raises:\n        ValueError: If the resource type is not supported or cannot be imported\n    \"\"\"\n    if isinstance(resource_type, type) and issubclass(resource_type, Resource):\n        return resource_type\n\n    if not isinstance(resource_type, str):\n        raise ValueError(\n            f\"Resource type must be a string or Resource class, got {type(resource_type)}\"\n        )\n\n    try:\n        # Try to import the resource type dynamically from fhir.resources\n        module = __import__(\n            f\"fhir.resources.{resource_type.lower()}\", fromlist=[resource_type]\n        )\n        return getattr(module, resource_type)\n    except (ImportError, AttributeError) as e:\n        raise ValueError(\n            f\"Could not import resource type: {resource_type}. \"\n            \"Make sure it is a valid FHIR resource type.\"\n        ) from e\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.get_resources","title":"<code>get_resources(bundle, resource_type)</code>","text":"<p>Get all resources of a specific type from a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to search</p> <p> TYPE: <code>Bundle</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List of resources of the specified type</p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def get_resources(\n    bundle: Bundle, resource_type: Union[str, Type[Resource]]\n) -&gt; List[Resource]:\n    \"\"\"Get all resources of a specific type from a bundle.\n\n    Args:\n        bundle: The bundle to search\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n\n    Returns:\n        List of resources of the specified type\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Using string identifier\n        &gt;&gt;&gt; conditions = get_resources(bundle, \"Condition\")\n        &gt;&gt;&gt; medications = get_resources(bundle, \"MedicationStatement\")\n        &gt;&gt;&gt; allergies = get_resources(bundle, \"AllergyIntolerance\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; conditions = get_resources(bundle, Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n    return [\n        entry.resource\n        for entry in (bundle.entry or [])\n        if isinstance(entry.resource, type_class)\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.get_resources--using-string-identifier","title":"Using string identifier","text":"<p>conditions = get_resources(bundle, \"Condition\") medications = get_resources(bundle, \"MedicationStatement\") allergies = get_resources(bundle, \"AllergyIntolerance\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.get_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition conditions = get_resources(bundle, Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.set_resources","title":"<code>set_resources(bundle, resources, resource_type, replace=True)</code>","text":"<p>Set resources of a specific type in the bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to modify</p> <p> TYPE: <code>Bundle</code> </p> <code>resources</code> <p>The new resources to add</p> <p> TYPE: <code>List[Resource]</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> <code>replace</code> <p>If True, remove existing resources of this type before adding new ones.     If False, append new resources to existing ones. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def set_resources(\n    bundle: Bundle,\n    resources: List[Resource],\n    resource_type: Union[str, Type[Resource]],\n    replace: bool = True,\n) -&gt; None:\n    \"\"\"Set resources of a specific type in the bundle.\n\n    Args:\n        bundle: The bundle to modify\n        resources: The new resources to add\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n        replace: If True, remove existing resources of this type before adding new ones.\n                If False, append new resources to existing ones. Defaults to True.\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Append to existing resources (default behavior)\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], \"Condition\")\n        &gt;&gt;&gt; set_resources(bundle, [medication1], \"MedicationStatement\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Replace existing resources\n        &gt;&gt;&gt; set_resources(bundle, [condition3], \"Condition\", replace=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n\n    # Remove existing resources of this type if replace=True\n    if replace:\n        bundle.entry = [\n            entry\n            for entry in (bundle.entry or [])\n            if not isinstance(entry.resource, type_class)\n        ]\n\n    # Add new resources\n    for resource in resources:\n        if not isinstance(resource, type_class):\n            raise ValueError(\n                f\"Resource must be of type {type_class.__name__}, \"\n                f\"got {type(resource).__name__}\"\n            )\n        add_resource(bundle, resource)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.set_resources--append-to-existing-resources-default-behavior","title":"Append to existing resources (default behavior)","text":"<p>set_resources(bundle, [condition1, condition2], \"Condition\") set_resources(bundle, [medication1], \"MedicationStatement\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.set_resources--replace-existing-resources","title":"Replace existing resources","text":"<p>set_resources(bundle, [condition3], \"Condition\", replace=True)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.set_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition set_resources(bundle, [condition1, condition2], Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers","title":"<code>helpers</code>","text":"<p>Convenience functions for creating minimal FHIR resources.</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_allergy_intolerance","title":"<code>create_allergy_intolerance(patient, code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal active FHIR AllergyIntolerance. If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly. https://build.fhir.org/allergyintolerance.html</p> PARAMETER DESCRIPTION <code>patient</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>code</code> <p>The allergen code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the allergen</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>AllergyIntolerance</code> <p>A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>AllergyIntolerance</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_allergy_intolerance(\n    patient: str,\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; AllergyIntolerance:\n    \"\"\"\n    Create a minimal active FHIR AllergyIntolerance.\n    If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly.\n    https://build.fhir.org/allergyintolerance.html\n\n    Args:\n        patient: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        code: The allergen code\n        display: The display name for the allergen\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        AllergyIntolerance: A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        allergy_code = create_single_codeable_concept(code, display, system)\n    else:\n        allergy_code = None\n\n    allergy = AllergyIntolerance(\n        id=_generate_id(),\n        patient={\"reference\": patient},\n        code=allergy_code,\n    )\n\n    return allergy\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_condition","title":"<code>create_condition(subject, clinical_status='active', code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal active FHIR Condition. If you need to create a more complex condition, use the FHIR Condition resource directly. https://build.fhir.org/condition.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>clinical_status</code> <p>REQUIRED. Clinical status (default: active)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'active'</code> </p> <code>code</code> <p>The condition code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the condition</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Condition</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_condition(\n    subject: str,\n    clinical_status: str = \"active\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; Condition:\n    \"\"\"\n    Create a minimal active FHIR Condition.\n    If you need to create a more complex condition, use the FHIR Condition resource directly.\n    https://build.fhir.org/condition.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        clinical_status: REQUIRED. Clinical status (default: active)\n        code: The condition code\n        display: The display name for the condition\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        Condition: A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        condition_code = create_single_codeable_concept(code, display, system)\n    else:\n        condition_code = None\n\n    condition = Condition(\n        id=_generate_id(),\n        subject={\"reference\": subject},\n        clinicalStatus=create_single_codeable_concept(\n            code=clinical_status,\n            display=clinical_status.capitalize(),\n            system=\"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n        ),\n        code=condition_code,\n    )\n\n    return condition\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_document_reference","title":"<code>create_document_reference(data=None, url=None, content_type=None, status='current', description='DocumentReference created by HealthChain', attachment_title='Attachment created by HealthChain')</code>","text":"<p>Create a minimal FHIR DocumentReference. If you need to create a more complex document reference, use the FHIR DocumentReference resource directly. https://build.fhir.org/documentreference.html</p> PARAMETER DESCRIPTION <code>data</code> <p>The data content of the document attachment</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>URL where the document can be accessed</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content_type</code> <p>MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>REQUIRED. Status of the document reference (default: current)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>description</code> <p>Description of the document reference</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'DocumentReference created by HealthChain'</code> </p> <code>attachment_title</code> <p>Title for the document attachment</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> RETURNS DESCRIPTION <code>DocumentReference</code> <p>A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>DocumentReference</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_document_reference(\n    data: Optional[Any] = None,\n    url: Optional[str] = None,\n    content_type: Optional[str] = None,\n    status: str = \"current\",\n    description: Optional[str] = \"DocumentReference created by HealthChain\",\n    attachment_title: Optional[str] = \"Attachment created by HealthChain\",\n) -&gt; DocumentReference:\n    \"\"\"\n    Create a minimal FHIR DocumentReference.\n    If you need to create a more complex document reference, use the FHIR DocumentReference resource directly.\n    https://build.fhir.org/documentreference.html\n\n    Args:\n        data: The data content of the document attachment\n        url: URL where the document can be accessed\n        content_type: MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")\n        status: REQUIRED. Status of the document reference (default: current)\n        description: Description of the document reference\n        attachment_title: Title for the document attachment\n\n    Returns:\n        DocumentReference: A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    document_reference = DocumentReference(\n        id=_generate_id(),\n        status=status,\n        date=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n        description=description,\n        content=[\n            {\n                \"attachment\": create_single_attachment(\n                    content_type=content_type,\n                    data=data,\n                    url=url,\n                    title=attachment_title,\n                )\n            }\n        ],\n    )\n\n    return document_reference\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_medication_statement","title":"<code>create_medication_statement(subject, status='recorded', code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal recorded FHIR MedicationStatement. If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly. https://build.fhir.org/medicationstatement.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>status</code> <p>REQUIRED. Status of the medication (default: recorded)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'recorded'</code> </p> <code>code</code> <p>The medication code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the medication</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>MedicationStatement</code> <p>A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>MedicationStatement</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_medication_statement(\n    subject: str,\n    status: Optional[str] = \"recorded\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; MedicationStatement:\n    \"\"\"\n    Create a minimal recorded FHIR MedicationStatement.\n    If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly.\n    https://build.fhir.org/medicationstatement.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        status: REQUIRED. Status of the medication (default: recorded)\n        code: The medication code\n        display: The display name for the medication\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        MedicationStatement: A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        medication_concept = create_single_codeable_concept(code, display, system)\n    else:\n        medication_concept = None\n\n    medication = MedicationStatement(\n        id=_generate_id(),\n        subject={\"reference\": subject},\n        status=status,\n        medication={\"concept\": medication_concept},\n    )\n\n    return medication\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_single_attachment","title":"<code>create_single_attachment(content_type=None, data=None, url=None, title='Attachment created by HealthChain')</code>","text":"<p>Create a minimal FHIR Attachment.</p> <p>Creates a FHIR Attachment resource with basic fields. Either data or url should be provided. If data is provided, it will be base64 encoded.</p> PARAMETER DESCRIPTION <code>content_type</code> <p>The MIME type of the content</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>data</code> <p>The actual data content to be base64 encoded</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>The URL where the data can be found</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>A title for the attachment (default: \"Attachment created by HealthChain\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> RETURNS DESCRIPTION <code>Attachment</code> <p>A FHIR Attachment resource with basic metadata and content</p> <p> TYPE: <code>Attachment</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_attachment(\n    content_type: Optional[str] = None,\n    data: Optional[str] = None,\n    url: Optional[str] = None,\n    title: Optional[str] = \"Attachment created by HealthChain\",\n) -&gt; Attachment:\n    \"\"\"Create a minimal FHIR Attachment.\n\n    Creates a FHIR Attachment resource with basic fields. Either data or url should be provided.\n    If data is provided, it will be base64 encoded.\n\n    Args:\n        content_type: The MIME type of the content\n        data: The actual data content to be base64 encoded\n        url: The URL where the data can be found\n        title: A title for the attachment (default: \"Attachment created by HealthChain\")\n\n    Returns:\n        Attachment: A FHIR Attachment resource with basic metadata and content\n    \"\"\"\n\n    if not data and not url:\n        logger.warning(\"No data or url provided for attachment\")\n\n    if data:\n        data = base64.b64encode(data.encode(\"utf-8\")).decode(\"utf-8\")\n\n    return Attachment(\n        contentType=content_type,\n        data=data,\n        url=url,\n        title=title,\n        creation=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n    )\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_single_codeable_concept","title":"<code>create_single_codeable_concept(code, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal FHIR CodeableConcept with a single coding.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>CodeableConcept</code> <p>A FHIR CodeableConcept resource with a single coding</p> <p> TYPE: <code>CodeableConcept</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_codeable_concept(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; CodeableConcept:\n    \"\"\"\n    Create a minimal FHIR CodeableConcept with a single coding.\n\n    Args:\n        code: REQUIRED. The code value from the code system\n        display: The display name for the code\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        CodeableConcept: A FHIR CodeableConcept resource with a single coding\n    \"\"\"\n    return CodeableConcept(coding=[Coding(system=system, code=code, display=display)])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_single_reaction","title":"<code>create_single_reaction(code, display=None, system='http://snomed.info/sct', severity=None)</code>","text":"<p>Create a minimal FHIR Reaction with a single coding.</p> <p>Creates a FHIR Reaction object with a single manifestation coding. The manifestation describes the clinical reaction that was observed. The severity indicates how severe the reaction was.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system representing the reaction manifestation</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the manifestation code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system for the manifestation code (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>severity</code> <p>The severity of the reaction (mild, moderate, severe)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>A list containing a single FHIR Reaction dictionary with manifestation and severity fields</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_reaction(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    severity: Optional[str] = None,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create a minimal FHIR Reaction with a single coding.\n\n    Creates a FHIR Reaction object with a single manifestation coding. The manifestation\n    describes the clinical reaction that was observed. The severity indicates how severe\n    the reaction was.\n\n    Args:\n        code: REQUIRED. The code value from the code system representing the reaction manifestation\n        display: The display name for the manifestation code\n        system: The code system for the manifestation code (default: SNOMED CT)\n        severity: The severity of the reaction (mild, moderate, severe)\n\n    Returns:\n        A list containing a single FHIR Reaction dictionary with manifestation and severity fields\n    \"\"\"\n    return [\n        {\n            \"manifestation\": [\n                CodeableReference(\n                    concept=CodeableConcept(\n                        coding=[Coding(system=system, code=code, display=display)]\n                    )\n                )\n            ],\n            \"severity\": severity,\n        }\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.read_content_attachment","title":"<code>read_content_attachment(document_reference, include_data=True)</code>","text":"<p>Read the attachments in a human readable format from a FHIR DocumentReference content field.</p> PARAMETER DESCRIPTION <code>document_reference</code> <p>The FHIR DocumentReference resource</p> <p> TYPE: <code>DocumentReference</code> </p> <code>include_data</code> <p>Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Optional[List[Dict[str, Any]]]</code> <p>Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata, or None if no attachments are found: [     {         \"data\": str,         \"metadata\": Dict[str, Any]     } ]</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def read_content_attachment(\n    document_reference: DocumentReference,\n    include_data: bool = True,\n) -&gt; Optional[List[Dict[str, Any]]]:\n    \"\"\"Read the attachments in a human readable format from a FHIR DocumentReference content field.\n\n    Args:\n        document_reference: The FHIR DocumentReference resource\n        include_data: Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)\n\n    Returns:\n        Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata,\n            or None if no attachments are found:\n            [\n                {\n                    \"data\": str,\n                    \"metadata\": Dict[str, Any]\n                }\n            ]\n    \"\"\"\n    if not document_reference.content:\n        return None\n\n    attachments = []\n    for content in document_reference.content:\n        attachment = content.attachment\n        result = {}\n\n        if include_data:\n            result[\"data\"] = (\n                attachment.url if attachment.url else attachment.data.decode(\"utf-8\")\n            )\n\n        result[\"metadata\"] = {\n            \"content_type\": attachment.contentType,\n            \"title\": attachment.title,\n            \"creation\": attachment.creation,\n        }\n\n        attachments.append(result)\n\n    return attachments\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.set_problem_list_item_category","title":"<code>set_problem_list_item_category(condition)</code>","text":"<p>Set the category of a FHIR Condition to problem-list-item.</p> <p>Sets the category field of a FHIR Condition resource to indicate it is a problem list item. This is commonly used to distinguish conditions that are part of the patient's active problem list from other types of conditions (e.g. encounter-diagnosis).</p> PARAMETER DESCRIPTION <code>condition</code> <p>The FHIR Condition resource to modify</p> <p> TYPE: <code>Condition</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>The modified FHIR Condition resource with problem-list-item category set</p> <p> TYPE: <code>Condition</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def set_problem_list_item_category(condition: Condition) -&gt; Condition:\n    \"\"\"Set the category of a FHIR Condition to problem-list-item.\n\n    Sets the category field of a FHIR Condition resource to indicate it is a problem list item.\n    This is commonly used to distinguish conditions that are part of the patient's active\n    problem list from other types of conditions (e.g. encounter-diagnosis).\n\n    Args:\n        condition: The FHIR Condition resource to modify\n\n    Returns:\n        Condition: The modified FHIR Condition resource with problem-list-item category set\n    \"\"\"\n    condition.category = [\n        create_single_codeable_concept(\n            code=\"problem-list-item\",\n            display=\"Problem List Item\",\n            system=\"http://terminology.hl7.org/CodeSystem/condition-category\",\n        )\n    ]\n    return condition\n</code></pre>"},{"location":"api/pipeline/","title":"Pipeline","text":""},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline","title":"<code>BasePipeline</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for creating and managing data processing pipelines.</p> <p>The BasePipeline class provides a framework for building modular data processing pipelines by allowing users to add, remove, and configure components with defined dependencies and execution order. Components can be added at specific positions, grouped into stages, and connected via input/output connectors.</p> <p>This is an abstract base class that should be subclassed to create specific pipeline implementations.</p> ATTRIBUTE DESCRIPTION <code>_components</code> <p>Ordered list of pipeline components</p> <p> TYPE: <code>List[PipelineNode[T]]</code> </p> <code>_stages</code> <p>Components grouped by processing stage</p> <p> TYPE: <code>Dict[str, List[Callable]]</code> </p> <code>_built_pipeline</code> <p>Compiled pipeline function</p> <p> TYPE: <code>Optional[Callable]</code> </p> <code>_input_connector</code> <p>Connector for processing input data</p> <p> TYPE: <code>Optional[BaseConnector[T]]</code> </p> <code>_output_connector</code> <p>Connector for processing output data</p> <p> TYPE: <code>Optional[BaseConnector[T]]</code> </p> <code>_output_template</code> <p>Template string for formatting pipeline outputs</p> <p> TYPE: <code>Optional[str]</code> </p> <code>_model_config</code> <p>Configuration for the pipeline model</p> <p> TYPE: <code>Optional[ModelConfig]</code> </p> Example <p>class MyPipeline(BasePipeline[str]): ...     def configure_pipeline(self, config: ModelConfig) -&gt; None: ...         self.add_node(preprocess, stage=\"preprocessing\") ...         self.add_node(process, stage=\"processing\") ...         self.add_node(postprocess, stage=\"postprocessing\") ... pipeline = MyPipeline() result = pipeline(\"input text\")</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class BasePipeline(Generic[T], ABC):\n    \"\"\"\n    Abstract base class for creating and managing data processing pipelines.\n\n    The BasePipeline class provides a framework for building modular data processing pipelines\n    by allowing users to add, remove, and configure components with defined dependencies and\n    execution order. Components can be added at specific positions, grouped into stages, and\n    connected via input/output connectors.\n\n    This is an abstract base class that should be subclassed to create specific pipeline\n    implementations.\n\n    Attributes:\n        _components (List[PipelineNode[T]]): Ordered list of pipeline components\n        _stages (Dict[str, List[Callable]]): Components grouped by processing stage\n        _built_pipeline (Optional[Callable]): Compiled pipeline function\n        _input_connector (Optional[BaseConnector[T]]): Connector for processing input data\n        _output_connector (Optional[BaseConnector[T]]): Connector for processing output data\n        _output_template (Optional[str]): Template string for formatting pipeline outputs\n        _model_config (Optional[ModelConfig]): Configuration for the pipeline model\n\n    Example:\n        &gt;&gt;&gt; class MyPipeline(BasePipeline[str]):\n        ...     def configure_pipeline(self, config: ModelConfig) -&gt; None:\n        ...         self.add_node(preprocess, stage=\"preprocessing\")\n        ...         self.add_node(process, stage=\"processing\")\n        ...         self.add_node(postprocess, stage=\"postprocessing\")\n        ...\n        &gt;&gt;&gt; pipeline = MyPipeline()\n        &gt;&gt;&gt; result = pipeline(\"input text\")\n    \"\"\"\n\n    def __init__(self):\n        self._components: List[PipelineNode[T]] = []\n        self._stages: Dict[str, List[Callable]] = {}\n        self._built_pipeline: Optional[Callable] = None\n        self._input_connector: Optional[BaseConnector[T]] = None\n        self._output_connector: Optional[BaseConnector[T]] = None\n        self._output_template: Optional[str] = None\n        self._output_template_path: Optional[Path] = None\n\n    def __repr__(self) -&gt; str:\n        components_repr = \", \".join(\n            [f'\"{component.name}\"' for component in self._components]\n        )\n        return f\"[{components_repr}]\"\n\n    def _configure_output_templates(\n        self,\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Configure template settings for the pipeline.\n\n        Args:\n            template (Optional[str]): Template string for formatting outputs.\n                Defaults to None.\n            template_path (Optional[Union[str, Path]]): Path to template file.\n                Defaults to None.\n        \"\"\"\n        self._output_template = template\n        self._output_template_path = Path(template_path) if template_path else None\n\n    @classmethod\n    def load(\n        cls,\n        pipeline: Callable,\n        source: str,\n        task: Optional[str] = \"text-generation\",\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        **kwargs: Any,\n    ) -&gt; \"BasePipeline\":\n        \"\"\"\n        Load a pipeline from a pre-built pipeline object (e.g. LangChain chain or HuggingFace pipeline).\n\n        Args:\n            pipeline (Callable): A callable pipeline object (e.g. LangChain chain, HuggingFace pipeline)\n            source (str): Source of the pipeline. Can be \"langchain\" or \"huggingface\".\n            task (Optional[str]): Task identifier used to retrieve model outputs.\n                Defaults to \"text-generation\".\n            template (Optional[str]): Template string for formatting outputs.\n                Defaults to None.\n            template_path (Optional[Union[str, Path]]): Path to template file.\n                Defaults to None.\n            **kwargs: Additional configuration options passed to the pipeline.\n\n        Returns:\n            BasePipeline: Configured pipeline instance.\n\n        Raises:\n            ValueError: If pipeline is not callable or source is invalid.\n\n        Examples:\n            &gt;&gt;&gt; # Load LangChain pipeline\n            &gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n            &gt;&gt;&gt; from langchain_openai import ChatOpenAI\n            &gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n            &gt;&gt;&gt; pipeline = Pipeline.load(chain, source=\"langchain\", temperature=0.7)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load HuggingFace pipeline\n            &gt;&gt;&gt; from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline\n            &gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n            &gt;&gt;&gt; model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n            &gt;&gt;&gt; pipe = pipeline(\"text-generation\", model=model, tokenizer=tokenizer, max_new_tokens=10)\n            &gt;&gt;&gt; pipeline = Pipeline.load(pipe, source=\"huggingface\")\n        \"\"\"\n        if not (hasattr(pipeline, \"__call__\") or hasattr(pipeline, \"invoke\")):\n            raise ValueError(\"Pipeline must be a callable object\")\n\n        # Validate source\n        source = source.lower()\n        if source not in [\"langchain\", \"huggingface\"]:\n            raise ValueError(\n                \"Source must be either 'langchain' or 'huggingface' for direct pipeline loading\"\n            )\n\n        # For HuggingFace pipelines, try to infer task if not provided\n        if source == \"huggingface\" and hasattr(pipeline, \"task\") and not task:\n            task = pipeline.task\n\n        instance = cls()\n        instance._configure_output_templates(template, template_path)\n\n        config = ModelConfig(\n            source=ModelSource(source),\n            pipeline_object=pipeline,\n            task=task,\n            kwargs=kwargs,\n        )\n\n        instance._model_config = config\n        instance.configure_pipeline(config)\n\n        return instance\n\n    @classmethod\n    def from_model_id(\n        cls,\n        model_id: str,\n        source: Union[str, ModelSource] = \"huggingface\",\n        task: Optional[str] = \"text-generation\",\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        **kwargs: Any,\n    ) -&gt; \"BasePipeline\":\n        \"\"\"\n        Load pipeline from a model identifier.\n\n        Args:\n            model_id (str): Model identifier (e.g. HuggingFace model ID, SpaCy model name)\n            source (Union[str, ModelSource]): Model source. Defaults to \"huggingface\".\n                Can be \"huggingface\", \"spacy\".\n            task (Optional[str]): Task identifier for the model. Defaults to \"text-generation\".\n            template (Optional[str]): Optional template string for formatting model output.\n            template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n            **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n        Returns:\n            BasePipeline: Configured pipeline instance.\n\n        Raises:\n            ValueError: If source is not a valid ModelSource.\n\n        Examples:\n            &gt;&gt;&gt; # Load HuggingFace model\n            &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n            ...     \"facebook/bart-large-cnn\",\n            ...     task=\"summarization\",\n            ...     temperature=0.7\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load SpaCy model\n            &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n            ...     \"en_core_sci_md\",\n            ...     source=\"spacy\",\n            ...     disable=[\"parser\"]\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load with output template\n            &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n            &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n            ...     \"gpt-3.5-turbo\",\n            ...     source=\"huggingface\",\n            ...     template=template\n            ... )\n        \"\"\"\n        pipeline = cls()\n        pipeline._configure_output_templates(template, template_path)\n\n        config = ModelConfig(\n            source=ModelSource(source.lower()),\n            model_id=model_id,\n            task=task,\n            kwargs=kwargs,\n        )\n        pipeline._model_config = config\n        pipeline.configure_pipeline(config)\n\n        return pipeline\n\n    @classmethod\n    def from_local_model(\n        cls,\n        path: Union[str, Path],\n        source: Union[str, ModelSource],\n        task: Optional[str] = None,\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        **kwargs: Any,\n    ) -&gt; \"BasePipeline\":\n        \"\"\"Load pipeline from a local model path.\n\n        Args:\n            path (Union[str, Path]): Path to local model files/directory\n            source (Union[str, ModelSource]): Model source (e.g. \"huggingface\", \"spacy\")\n            task (Optional[str]): Task identifier for the model. Defaults to None.\n            template (Optional[str]): Optional template string for formatting model output.\n            template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n            **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n        Returns:\n            BasePipeline: Configured pipeline instance.\n\n        Raises:\n            ValueError: If source is not a valid ModelSource.\n\n        Examples:\n            &gt;&gt;&gt; # Load local HuggingFace model\n            &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n            ...     \"models/my_summarizer\",\n            ...     source=\"huggingface\",\n            ...     task=\"summarization\",\n            ...     temperature=0.7\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load local SpaCy model\n            &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n            ...     \"models/en_core_sci_md\",\n            ...     source=\"spacy\",\n            ...     disable=[\"parser\"]\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load with output template\n            &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n            &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n            ...     \"models/gpt_model\",\n            ...     source=\"huggingface\",\n            ...     template=template\n            ... )\n        \"\"\"\n        pipeline = cls()\n        pipeline._configure_output_templates(template, template_path)\n\n        path = Path(path)\n        config = ModelConfig(\n            source=ModelSource(source.lower()),\n            model_id=path.name,\n            path=path,\n            task=task,\n            kwargs=kwargs,\n        )\n        pipeline._model_config = config\n        pipeline.configure_pipeline(config)\n\n        return pipeline\n\n    @abstractmethod\n    def configure_pipeline(self, model_config: ModelConfig) -&gt; None:\n        \"\"\"\n        Configure the pipeline based on the provided model configuration.\n\n        This method should be implemented by subclasses to add specific components\n        and configure the pipeline according to the given model configuration.\n        The configuration typically involves:\n        1. Setting up input/output connectors\n        2. Adding model components based on the model source\n        3. Adding any additional processing nodes\n        4. Configuring the pipeline stages and execution order\n\n        Args:\n            model_config (ModelConfig): Configuration object containing:\n                - source: Model source (e.g. huggingface, spacy, langchain)\n                - model: Model identifier or path\n                - task: Optional task name (e.g. summarization, ner)\n                - path: Optional local path to model files\n                - kwargs: Additional model configuration parameters\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the method is not implemented by a subclass.\n\n        Example:\n            &gt;&gt;&gt; def configure_pipeline(self, config: ModelConfig):\n            ...     # Add FHIR connector for input/output\n            ...     connector = FhirConnector()\n            ...     self.add_input(connector)\n            ...\n            ...     # Add model component\n            ...     model = self.get_model_component(config)\n            ...     self.add_node(model, stage=\"processing\")\n            ...\n            ...     # Add output formatting\n            ...     self.add_node(OutputFormatter(), stage=\"formatting\")\n            ...     self.add_output(connector)\n        \"\"\"\n        raise NotImplementedError(\"This method must be implemented by subclasses.\")\n\n    @property\n    def stages(self):\n        \"\"\"\n        Returns a human-readable representation of the pipeline stages.\n        \"\"\"\n        output = [\"Pipeline Stages:\"]\n        for stage, components in self._stages.items():\n            output.append(f\"  {stage}:\")\n            for component in components:\n                component_name = (\n                    component.__name__\n                    if hasattr(component, \"__name__\")\n                    else (\n                        component.__class__.__name__\n                        if hasattr(component, \"__class__\")\n                        else str(component)\n                    )\n                )\n                output.append(f\"    - {component_name}\")\n        if not self._stages:\n            output.append(\"  No stages defined.\")\n        return \"\\n\".join(output)\n\n    @stages.setter\n    def stages(self, new_stages: Dict[str, List[Callable]]):\n        \"\"\"\n        Sets the stages of the pipeline.\n\n        Args:\n            new_stages (Dict[str, List[Callable]]): A dictionary where keys are stage names\n                                                    and values are lists of callable components.\n        \"\"\"\n        self._stages = new_stages\n\n    def add_input(self, connector: BaseConnector[T]) -&gt; None:\n        \"\"\"\n        Adds an input connector to the pipeline.\n\n        This method sets the input connector for the pipeline, which is responsible\n        for processing the input data before it's passed to the pipeline components.\n\n        Args:\n            connector (Connector[T]): The input connector to be added to the pipeline.\n\n        Returns:\n            None\n\n        Note:\n            Only one input connector can be set for the pipeline. If this method is\n            called multiple times, the last connector will overwrite the previous ones.\n        \"\"\"\n        self._input_connector = connector\n\n    def add_output(self, connector: BaseConnector[T]) -&gt; None:\n        \"\"\"\n        Adds an output connector to the pipeline.\n\n        This method sets the output connector for the pipeline, which is responsible\n        for processing the output data after it has passed through all pipeline components.\n\n        Args:\n            connector (Connector[T]): The output connector to be added to the pipeline.\n\n        Returns:\n            None\n\n        Note:\n            Only one output connector can be set for the pipeline. If this method is\n            called multiple times, the last connector will overwrite the previous ones.\n        \"\"\"\n        self._output_connector = connector\n\n    def add_node(\n        self,\n        component: Union[\n            BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n        ] = None,\n        *,\n        position: PositionType = \"default\",\n        reference: str = None,\n        stage: str = None,\n        name: str = None,\n        input_model: Type[BaseModel] = None,\n        output_model: Type[BaseModel] = None,\n        dependencies: List[str] = [],\n    ) -&gt; None:\n        \"\"\"\n        Adds a component node to the pipeline.\n\n        Args:\n            component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]], optional):\n                The component to be added. It can be either a BaseComponent object or a callable function.\n                Defaults to None.\n            position (PositionType, optional):\n                The position at which the component should be added in the pipeline.\n                Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\".\n                Defaults to \"default\".\n            reference (str, optional):\n                The name of the component after or before which the new component should be added.\n                Only applicable when position is \"after\" or \"before\".\n                Defaults to None.\n            stage (str, optional):\n                The stage to which the component belongs.\n                Defaults to None.\n            name (str, optional):\n                The name of the component.\n                Defaults to None, in which case the name of the function will be used.\n            input_model (Type[BaseModel], optional):\n                The input Pydantic model class for validating the input data.\n                Defaults to None.\n            output_model (Type[BaseModel], optional):\n                The output Pydantic model class for validating the output data.\n                Defaults to None.\n            dependencies (List[str], optional):\n                The list of component names that this component depends on.\n                Defaults to an empty list.\n\n        Returns:\n            The original component if component is None, otherwise the wrapper function.\n\n        \"\"\"\n\n        def wrapper(func):\n            def validated_component(data: DataContainer[T]) -&gt; DataContainer[T]:\n                # Validate input if input_model is provided\n                if input_model:\n                    input_model(**data.__dict__)\n\n                # Run the component\n                result = func(data)\n\n                # Validate output if output_model is provided\n                if output_model:\n                    output_model(**result.__dict__)\n\n                return result\n\n            component_func = (\n                validated_component if input_model or output_model else func\n            )\n            new_component = PipelineNode(\n                func=component_func,\n                position=position,\n                reference=reference,\n                stage=stage,\n                name=name\n                if name is not None\n                else (\n                    component_func.__name__\n                    if hasattr(component_func, \"__name__\")\n                    else (\n                        component_func.__class__.__name__\n                        if hasattr(component_func, \"__class__\")\n                        else str(component_func)\n                    )\n                ),\n                dependencies=dependencies,\n            )\n            try:\n                self._add_component_at_position(new_component, position, reference)\n            except Exception as e:\n                raise ValueError(f\"Error adding component: {str(e)}\")\n\n            if stage:\n                if stage not in self._stages:\n                    self._stages[stage] = []\n                self._stages[stage].append(func)\n                logger.debug(\n                    f\"Successfully added component '{new_component.name}' to stage '{stage}'.\"\n                )\n\n            return func\n\n        if component is None:\n            return wrapper\n        if callable(component):\n            return wrapper(component)\n        else:\n            raise ValueError(\"Component must be callable\")\n\n    def _add_component_at_position(self, new_component, position, reference):\n        \"\"\"\n        Add a new component to the pipeline at a specified position.\n\n        Args:\n            new_component (PipelineNode): The new component to be added to the pipeline.\n            position (str): The position where the component should be added.\n                            Valid values are 'first', 'last', 'after', 'before', or 'default'.\n            reference (str, optional): The name of the reference component when using 'after' or 'before' positions.\n\n        Raises:\n            ValueError: If an invalid position is provided or if a reference is required but not provided.\n\n        This method handles the insertion of a new component into the pipeline based on the specified position:\n        - 'first': Inserts the component at the beginning of the pipeline.\n        - 'last' or 'default': Appends the component to the end of the pipeline.\n        - 'after' or 'before': Inserts the component relative to a reference component.\n\n        For 'after' and 'before' positions, a reference component name must be provided.\n        \"\"\"\n        if position == \"first\":\n            self._components.insert(0, new_component)\n        elif position in [\"last\", \"default\"]:\n            self._components.append(new_component)\n        elif position in [\"after\", \"before\"]:\n            if not reference:\n                raise ValueError(\n                    f\"Reference must be provided for position '{position}'.\"\n                )\n            offset = 1 if position == \"after\" else 0\n            self._insert_relative_position(new_component, reference, offset)\n        else:\n            raise ValueError(\n                f\"Invalid position '{position}'. Must be 'first', 'last', 'after', 'before', or 'default'.\"\n            )\n\n    def _insert_relative_position(self, component, reference, offset):\n        \"\"\"\n        Insert a component relative to a reference component in the pipeline.\n\n        Args:\n            component (PipelineNode): The component to be inserted.\n            reference (str): The name of the reference component.\n            offset (int): The offset from the reference component (0 for before, 1 for after).\n\n        Raises:\n            ValueError: If the reference component is not found in the pipeline.\n        \"\"\"\n        ref_index = next(\n            (i for i, c in enumerate(self._components) if c.name == reference), None\n        )\n        if ref_index is None:\n            raise ValueError(f\"Reference component '{reference}' not found.\")\n\n        self._components.insert(ref_index + offset, component)\n\n    def remove(self, component_name: str) -&gt; None:\n        \"\"\"\n        Removes a component from the pipeline.\n\n        Args:\n            component_name (str): The name of the component to be removed.\n\n        Raises:\n            ValueError: If the component is not found in the pipeline.\n\n        Returns:\n            None\n\n        Logs:\n            DEBUG: When the component is successfully removed.\n            WARNING: If the component fails to be removed after attempting to do so.\n        \"\"\"\n        # Check if the component exists in the pipeline\n        if not any(c.name == component_name for c in self._components):\n            raise ValueError(f\"Component '{component_name}' not found in the pipeline.\")\n\n        # Remove the component from self.components\n        original_count = len(self._components)\n        self._components = [c for c in self._components if c.name != component_name]\n\n        # Remove the component from stages\n        for stage in self._stages.values():\n            stage[:] = [c for c in stage if c.__name__ != component_name]\n\n        # Validate that the component was removed\n        if len(self._components) == original_count or any(\n            c.__name__ == component_name\n            for stage in self._stages.values()\n            for c in stage\n        ):\n            logger.warning(\n                f\"Failed to remove component '{component_name}' from the pipeline.\"\n            )\n        logger.debug(\n            f\"Successfully removed component '{component_name}' from the pipeline.\"\n        )\n\n    def replace(\n        self,\n        old_component_name: str,\n        new_component: Union[\n            BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n        ],\n    ) -&gt; None:\n        \"\"\"\n        Replaces a component in the pipeline with a new component.\n\n        Args:\n            old_component_name (str): The name of the component to be replaced.\n            new_component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]):\n                The new component to replace the old component with.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the old component is not found in the pipeline.\n            ValueError: If the new component is not a BaseComponent or a callable.\n            ValueError: If the new component callable doesn't have the correct signature.\n\n        Logs:\n            DEBUG: When the component is successfully replaced.\n        \"\"\"\n\n        if isinstance(new_component, BaseComponent):\n            # It's a valid BaseComponent, no further checks needed\n            pass\n        elif callable(new_component):\n            sig = signature(new_component)\n            param = list(sig.parameters.values())[0]\n            if len(sig.parameters) != 1 or not issubclass(\n                param.annotation, DataContainer\n            ):\n                raise ValueError(\n                    \"New component callable must accept a single argument that is a subclass of DataContainer.\"\n                )\n        else:\n            raise ValueError(\"New component must be a BaseComponent or a callable.\")\n\n        old_component_found = False\n\n        # Replace in self.components\n        for i, c in enumerate(self._components):\n            if c.name == old_component_name:\n                self._components[i] = PipelineNode(\n                    func=new_component,\n                    name=old_component_name,\n                    position=c.position,\n                    reference=c.reference,\n                    stage=c.stage,\n                    dependencies=c.dependencies,\n                )\n                old_component_found = True\n\n        # Replace in self.stages\n        for stage in self._stages.values():\n            for i, c in enumerate(stage):\n                if getattr(c, \"name\", c.__name__) == old_component_name:\n                    stage[i] = new_component\n                    old_component_found = True\n\n        if not old_component_found:\n            raise ValueError(\n                f\"Component '{old_component_name}' not found in the pipeline.\"\n            )\n        else:\n            logger.debug(\n                f\"Successfully replaced component '{old_component_name}' in the pipeline.\"\n            )\n\n    def __call__(self, data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n        if self._built_pipeline is None:\n            self._built_pipeline = self.build()\n        return self._built_pipeline(data)\n\n    def build(self) -&gt; Callable:\n        \"\"\"\n        Builds and returns a pipeline function that applies a series of components to the input data.\n        Returns:\n            pipeline: A function that takes input data and applies the ordered components to it.\n        Raises:\n            ValueError: If a circular dependency is detected among the components.\n        \"\"\"\n\n        def resolve_dependencies():\n            resolved = []\n            unresolved = self._components.copy()\n\n            while unresolved:\n                for component in unresolved:\n                    if all(\n                        dep in [c.name for c in resolved]\n                        for dep in component.dependencies\n                    ):\n                        resolved.append(component)\n                        unresolved.remove(component)\n                        break\n                else:\n                    raise ValueError(\"Circular dependency detected\")\n\n            return [c.func for c in resolved]\n\n        ordered_components = resolve_dependencies()\n\n        def pipeline(data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n            if self._input_connector:\n                data = self._input_connector.input(data)\n\n            if not isinstance(data, DataContainer):\n                data = DataContainer(data)\n\n            data = reduce(lambda d, comp: comp(d), ordered_components, data)\n            if self._output_connector:\n                data = self._output_connector.output(data)\n\n            return data\n\n        if self._built_pipeline is not pipeline:\n            self._built_pipeline = pipeline\n\n        return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.stages","title":"<code>stages</code>  <code>property</code> <code>writable</code>","text":"<p>Returns a human-readable representation of the pipeline stages.</p>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.add_input","title":"<code>add_input(connector)</code>","text":"<p>Adds an input connector to the pipeline.</p> <p>This method sets the input connector for the pipeline, which is responsible for processing the input data before it's passed to the pipeline components.</p> PARAMETER DESCRIPTION <code>connector</code> <p>The input connector to be added to the pipeline.</p> <p> TYPE: <code>Connector[T]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Note <p>Only one input connector can be set for the pipeline. If this method is called multiple times, the last connector will overwrite the previous ones.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def add_input(self, connector: BaseConnector[T]) -&gt; None:\n    \"\"\"\n    Adds an input connector to the pipeline.\n\n    This method sets the input connector for the pipeline, which is responsible\n    for processing the input data before it's passed to the pipeline components.\n\n    Args:\n        connector (Connector[T]): The input connector to be added to the pipeline.\n\n    Returns:\n        None\n\n    Note:\n        Only one input connector can be set for the pipeline. If this method is\n        called multiple times, the last connector will overwrite the previous ones.\n    \"\"\"\n    self._input_connector = connector\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.add_node","title":"<code>add_node(component=None, *, position='default', reference=None, stage=None, name=None, input_model=None, output_model=None, dependencies=[])</code>","text":"<p>Adds a component node to the pipeline.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to be added. It can be either a BaseComponent object or a callable function. Defaults to None.</p> <p> TYPE: <code>Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]</code> DEFAULT: <code>None</code> </p> <code>position</code> <p>The position at which the component should be added in the pipeline. Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\". Defaults to \"default\".</p> <p> TYPE: <code>PositionType</code> DEFAULT: <code>'default'</code> </p> <code>reference</code> <p>The name of the component after or before which the new component should be added. Only applicable when position is \"after\" or \"before\". Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>stage</code> <p>The stage to which the component belongs. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>The name of the component. Defaults to None, in which case the name of the function will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>input_model</code> <p>The input Pydantic model class for validating the input data. Defaults to None.</p> <p> TYPE: <code>Type[BaseModel]</code> DEFAULT: <code>None</code> </p> <code>output_model</code> <p>The output Pydantic model class for validating the output data. Defaults to None.</p> <p> TYPE: <code>Type[BaseModel]</code> DEFAULT: <code>None</code> </p> <code>dependencies</code> <p>The list of component names that this component depends on. Defaults to an empty list.</p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>[]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>The original component if component is None, otherwise the wrapper function.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def add_node(\n    self,\n    component: Union[\n        BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n    ] = None,\n    *,\n    position: PositionType = \"default\",\n    reference: str = None,\n    stage: str = None,\n    name: str = None,\n    input_model: Type[BaseModel] = None,\n    output_model: Type[BaseModel] = None,\n    dependencies: List[str] = [],\n) -&gt; None:\n    \"\"\"\n    Adds a component node to the pipeline.\n\n    Args:\n        component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]], optional):\n            The component to be added. It can be either a BaseComponent object or a callable function.\n            Defaults to None.\n        position (PositionType, optional):\n            The position at which the component should be added in the pipeline.\n            Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\".\n            Defaults to \"default\".\n        reference (str, optional):\n            The name of the component after or before which the new component should be added.\n            Only applicable when position is \"after\" or \"before\".\n            Defaults to None.\n        stage (str, optional):\n            The stage to which the component belongs.\n            Defaults to None.\n        name (str, optional):\n            The name of the component.\n            Defaults to None, in which case the name of the function will be used.\n        input_model (Type[BaseModel], optional):\n            The input Pydantic model class for validating the input data.\n            Defaults to None.\n        output_model (Type[BaseModel], optional):\n            The output Pydantic model class for validating the output data.\n            Defaults to None.\n        dependencies (List[str], optional):\n            The list of component names that this component depends on.\n            Defaults to an empty list.\n\n    Returns:\n        The original component if component is None, otherwise the wrapper function.\n\n    \"\"\"\n\n    def wrapper(func):\n        def validated_component(data: DataContainer[T]) -&gt; DataContainer[T]:\n            # Validate input if input_model is provided\n            if input_model:\n                input_model(**data.__dict__)\n\n            # Run the component\n            result = func(data)\n\n            # Validate output if output_model is provided\n            if output_model:\n                output_model(**result.__dict__)\n\n            return result\n\n        component_func = (\n            validated_component if input_model or output_model else func\n        )\n        new_component = PipelineNode(\n            func=component_func,\n            position=position,\n            reference=reference,\n            stage=stage,\n            name=name\n            if name is not None\n            else (\n                component_func.__name__\n                if hasattr(component_func, \"__name__\")\n                else (\n                    component_func.__class__.__name__\n                    if hasattr(component_func, \"__class__\")\n                    else str(component_func)\n                )\n            ),\n            dependencies=dependencies,\n        )\n        try:\n            self._add_component_at_position(new_component, position, reference)\n        except Exception as e:\n            raise ValueError(f\"Error adding component: {str(e)}\")\n\n        if stage:\n            if stage not in self._stages:\n                self._stages[stage] = []\n            self._stages[stage].append(func)\n            logger.debug(\n                f\"Successfully added component '{new_component.name}' to stage '{stage}'.\"\n            )\n\n        return func\n\n    if component is None:\n        return wrapper\n    if callable(component):\n        return wrapper(component)\n    else:\n        raise ValueError(\"Component must be callable\")\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.add_output","title":"<code>add_output(connector)</code>","text":"<p>Adds an output connector to the pipeline.</p> <p>This method sets the output connector for the pipeline, which is responsible for processing the output data after it has passed through all pipeline components.</p> PARAMETER DESCRIPTION <code>connector</code> <p>The output connector to be added to the pipeline.</p> <p> TYPE: <code>Connector[T]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Note <p>Only one output connector can be set for the pipeline. If this method is called multiple times, the last connector will overwrite the previous ones.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def add_output(self, connector: BaseConnector[T]) -&gt; None:\n    \"\"\"\n    Adds an output connector to the pipeline.\n\n    This method sets the output connector for the pipeline, which is responsible\n    for processing the output data after it has passed through all pipeline components.\n\n    Args:\n        connector (Connector[T]): The output connector to be added to the pipeline.\n\n    Returns:\n        None\n\n    Note:\n        Only one output connector can be set for the pipeline. If this method is\n        called multiple times, the last connector will overwrite the previous ones.\n    \"\"\"\n    self._output_connector = connector\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.build","title":"<code>build()</code>","text":"<p>Builds and returns a pipeline function that applies a series of components to the input data. Returns:     pipeline: A function that takes input data and applies the ordered components to it. Raises:     ValueError: If a circular dependency is detected among the components.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def build(self) -&gt; Callable:\n    \"\"\"\n    Builds and returns a pipeline function that applies a series of components to the input data.\n    Returns:\n        pipeline: A function that takes input data and applies the ordered components to it.\n    Raises:\n        ValueError: If a circular dependency is detected among the components.\n    \"\"\"\n\n    def resolve_dependencies():\n        resolved = []\n        unresolved = self._components.copy()\n\n        while unresolved:\n            for component in unresolved:\n                if all(\n                    dep in [c.name for c in resolved]\n                    for dep in component.dependencies\n                ):\n                    resolved.append(component)\n                    unresolved.remove(component)\n                    break\n            else:\n                raise ValueError(\"Circular dependency detected\")\n\n        return [c.func for c in resolved]\n\n    ordered_components = resolve_dependencies()\n\n    def pipeline(data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n        if self._input_connector:\n            data = self._input_connector.input(data)\n\n        if not isinstance(data, DataContainer):\n            data = DataContainer(data)\n\n        data = reduce(lambda d, comp: comp(d), ordered_components, data)\n        if self._output_connector:\n            data = self._output_connector.output(data)\n\n        return data\n\n    if self._built_pipeline is not pipeline:\n        self._built_pipeline = pipeline\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.configure_pipeline","title":"<code>configure_pipeline(model_config)</code>  <code>abstractmethod</code>","text":"<p>Configure the pipeline based on the provided model configuration.</p> <p>This method should be implemented by subclasses to add specific components and configure the pipeline according to the given model configuration. The configuration typically involves: 1. Setting up input/output connectors 2. Adding model components based on the model source 3. Adding any additional processing nodes 4. Configuring the pipeline stages and execution order</p> PARAMETER DESCRIPTION <code>model_config</code> <p>Configuration object containing: - source: Model source (e.g. huggingface, spacy, langchain) - model: Model identifier or path - task: Optional task name (e.g. summarization, ner) - path: Optional local path to model files - kwargs: Additional model configuration parameters</p> <p> TYPE: <code>ModelConfig</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented by a subclass.</p> Example <p>def configure_pipeline(self, config: ModelConfig): ...     # Add FHIR connector for input/output ...     connector = FhirConnector() ...     self.add_input(connector) ... ...     # Add model component ...     model = self.get_model_component(config) ...     self.add_node(model, stage=\"processing\") ... ...     # Add output formatting ...     self.add_node(OutputFormatter(), stage=\"formatting\") ...     self.add_output(connector)</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@abstractmethod\ndef configure_pipeline(self, model_config: ModelConfig) -&gt; None:\n    \"\"\"\n    Configure the pipeline based on the provided model configuration.\n\n    This method should be implemented by subclasses to add specific components\n    and configure the pipeline according to the given model configuration.\n    The configuration typically involves:\n    1. Setting up input/output connectors\n    2. Adding model components based on the model source\n    3. Adding any additional processing nodes\n    4. Configuring the pipeline stages and execution order\n\n    Args:\n        model_config (ModelConfig): Configuration object containing:\n            - source: Model source (e.g. huggingface, spacy, langchain)\n            - model: Model identifier or path\n            - task: Optional task name (e.g. summarization, ner)\n            - path: Optional local path to model files\n            - kwargs: Additional model configuration parameters\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the method is not implemented by a subclass.\n\n    Example:\n        &gt;&gt;&gt; def configure_pipeline(self, config: ModelConfig):\n        ...     # Add FHIR connector for input/output\n        ...     connector = FhirConnector()\n        ...     self.add_input(connector)\n        ...\n        ...     # Add model component\n        ...     model = self.get_model_component(config)\n        ...     self.add_node(model, stage=\"processing\")\n        ...\n        ...     # Add output formatting\n        ...     self.add_node(OutputFormatter(), stage=\"formatting\")\n        ...     self.add_output(connector)\n    \"\"\"\n    raise NotImplementedError(\"This method must be implemented by subclasses.\")\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.from_local_model","title":"<code>from_local_model(path, source, task=None, template=None, template_path=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load pipeline from a local model path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to local model files/directory</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>source</code> <p>Model source (e.g. \"huggingface\", \"spacy\")</p> <p> TYPE: <code>Union[str, ModelSource]</code> </p> <code>task</code> <p>Task identifier for the model. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template</code> <p>Optional template string for formatting model output.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template_path</code> <p>Optional path to template file for formatting model output.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to the model. e.g. temperature, max_length, etc.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePipeline</code> <p>Configured pipeline instance.</p> <p> TYPE: <code>BasePipeline</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If source is not a valid ModelSource.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Load local HuggingFace model\n&gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n...     \"models/my_summarizer\",\n...     source=\"huggingface\",\n...     task=\"summarization\",\n...     temperature=0.7\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load local SpaCy model\n&gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n...     \"models/en_core_sci_md\",\n...     source=\"spacy\",\n...     disable=[\"parser\"]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load with output template\n&gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n&gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n...     \"models/gpt_model\",\n...     source=\"huggingface\",\n...     template=template\n... )\n</code></pre> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@classmethod\ndef from_local_model(\n    cls,\n    path: Union[str, Path],\n    source: Union[str, ModelSource],\n    task: Optional[str] = None,\n    template: Optional[str] = None,\n    template_path: Optional[Union[str, Path]] = None,\n    **kwargs: Any,\n) -&gt; \"BasePipeline\":\n    \"\"\"Load pipeline from a local model path.\n\n    Args:\n        path (Union[str, Path]): Path to local model files/directory\n        source (Union[str, ModelSource]): Model source (e.g. \"huggingface\", \"spacy\")\n        task (Optional[str]): Task identifier for the model. Defaults to None.\n        template (Optional[str]): Optional template string for formatting model output.\n        template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n        **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n    Returns:\n        BasePipeline: Configured pipeline instance.\n\n    Raises:\n        ValueError: If source is not a valid ModelSource.\n\n    Examples:\n        &gt;&gt;&gt; # Load local HuggingFace model\n        &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n        ...     \"models/my_summarizer\",\n        ...     source=\"huggingface\",\n        ...     task=\"summarization\",\n        ...     temperature=0.7\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load local SpaCy model\n        &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n        ...     \"models/en_core_sci_md\",\n        ...     source=\"spacy\",\n        ...     disable=[\"parser\"]\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load with output template\n        &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n        &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n        ...     \"models/gpt_model\",\n        ...     source=\"huggingface\",\n        ...     template=template\n        ... )\n    \"\"\"\n    pipeline = cls()\n    pipeline._configure_output_templates(template, template_path)\n\n    path = Path(path)\n    config = ModelConfig(\n        source=ModelSource(source.lower()),\n        model_id=path.name,\n        path=path,\n        task=task,\n        kwargs=kwargs,\n    )\n    pipeline._model_config = config\n    pipeline.configure_pipeline(config)\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.from_model_id","title":"<code>from_model_id(model_id, source='huggingface', task='text-generation', template=None, template_path=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load pipeline from a model identifier.</p> PARAMETER DESCRIPTION <code>model_id</code> <p>Model identifier (e.g. HuggingFace model ID, SpaCy model name)</p> <p> TYPE: <code>str</code> </p> <code>source</code> <p>Model source. Defaults to \"huggingface\". Can be \"huggingface\", \"spacy\".</p> <p> TYPE: <code>Union[str, ModelSource]</code> DEFAULT: <code>'huggingface'</code> </p> <code>task</code> <p>Task identifier for the model. Defaults to \"text-generation\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'text-generation'</code> </p> <code>template</code> <p>Optional template string for formatting model output.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template_path</code> <p>Optional path to template file for formatting model output.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to the model. e.g. temperature, max_length, etc.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePipeline</code> <p>Configured pipeline instance.</p> <p> TYPE: <code>BasePipeline</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If source is not a valid ModelSource.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Load HuggingFace model\n&gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n...     \"facebook/bart-large-cnn\",\n...     task=\"summarization\",\n...     temperature=0.7\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load SpaCy model\n&gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n...     \"en_core_sci_md\",\n...     source=\"spacy\",\n...     disable=[\"parser\"]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load with output template\n&gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n&gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n...     \"gpt-3.5-turbo\",\n...     source=\"huggingface\",\n...     template=template\n... )\n</code></pre> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@classmethod\ndef from_model_id(\n    cls,\n    model_id: str,\n    source: Union[str, ModelSource] = \"huggingface\",\n    task: Optional[str] = \"text-generation\",\n    template: Optional[str] = None,\n    template_path: Optional[Union[str, Path]] = None,\n    **kwargs: Any,\n) -&gt; \"BasePipeline\":\n    \"\"\"\n    Load pipeline from a model identifier.\n\n    Args:\n        model_id (str): Model identifier (e.g. HuggingFace model ID, SpaCy model name)\n        source (Union[str, ModelSource]): Model source. Defaults to \"huggingface\".\n            Can be \"huggingface\", \"spacy\".\n        task (Optional[str]): Task identifier for the model. Defaults to \"text-generation\".\n        template (Optional[str]): Optional template string for formatting model output.\n        template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n        **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n    Returns:\n        BasePipeline: Configured pipeline instance.\n\n    Raises:\n        ValueError: If source is not a valid ModelSource.\n\n    Examples:\n        &gt;&gt;&gt; # Load HuggingFace model\n        &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n        ...     \"facebook/bart-large-cnn\",\n        ...     task=\"summarization\",\n        ...     temperature=0.7\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load SpaCy model\n        &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n        ...     \"en_core_sci_md\",\n        ...     source=\"spacy\",\n        ...     disable=[\"parser\"]\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load with output template\n        &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n        &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n        ...     \"gpt-3.5-turbo\",\n        ...     source=\"huggingface\",\n        ...     template=template\n        ... )\n    \"\"\"\n    pipeline = cls()\n    pipeline._configure_output_templates(template, template_path)\n\n    config = ModelConfig(\n        source=ModelSource(source.lower()),\n        model_id=model_id,\n        task=task,\n        kwargs=kwargs,\n    )\n    pipeline._model_config = config\n    pipeline.configure_pipeline(config)\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.load","title":"<code>load(pipeline, source, task='text-generation', template=None, template_path=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load a pipeline from a pre-built pipeline object (e.g. LangChain chain or HuggingFace pipeline).</p> PARAMETER DESCRIPTION <code>pipeline</code> <p>A callable pipeline object (e.g. LangChain chain, HuggingFace pipeline)</p> <p> TYPE: <code>Callable</code> </p> <code>source</code> <p>Source of the pipeline. Can be \"langchain\" or \"huggingface\".</p> <p> TYPE: <code>str</code> </p> <code>task</code> <p>Task identifier used to retrieve model outputs. Defaults to \"text-generation\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'text-generation'</code> </p> <code>template</code> <p>Template string for formatting outputs. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template_path</code> <p>Path to template file. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to the pipeline.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePipeline</code> <p>Configured pipeline instance.</p> <p> TYPE: <code>BasePipeline</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If pipeline is not callable or source is invalid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Load LangChain pipeline\n&gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n&gt;&gt;&gt; from langchain_openai import ChatOpenAI\n&gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n&gt;&gt;&gt; pipeline = Pipeline.load(chain, source=\"langchain\", temperature=0.7)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load HuggingFace pipeline\n&gt;&gt;&gt; from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline\n&gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n&gt;&gt;&gt; model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n&gt;&gt;&gt; pipe = pipeline(\"text-generation\", model=model, tokenizer=tokenizer, max_new_tokens=10)\n&gt;&gt;&gt; pipeline = Pipeline.load(pipe, source=\"huggingface\")\n</code></pre> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    pipeline: Callable,\n    source: str,\n    task: Optional[str] = \"text-generation\",\n    template: Optional[str] = None,\n    template_path: Optional[Union[str, Path]] = None,\n    **kwargs: Any,\n) -&gt; \"BasePipeline\":\n    \"\"\"\n    Load a pipeline from a pre-built pipeline object (e.g. LangChain chain or HuggingFace pipeline).\n\n    Args:\n        pipeline (Callable): A callable pipeline object (e.g. LangChain chain, HuggingFace pipeline)\n        source (str): Source of the pipeline. Can be \"langchain\" or \"huggingface\".\n        task (Optional[str]): Task identifier used to retrieve model outputs.\n            Defaults to \"text-generation\".\n        template (Optional[str]): Template string for formatting outputs.\n            Defaults to None.\n        template_path (Optional[Union[str, Path]]): Path to template file.\n            Defaults to None.\n        **kwargs: Additional configuration options passed to the pipeline.\n\n    Returns:\n        BasePipeline: Configured pipeline instance.\n\n    Raises:\n        ValueError: If pipeline is not callable or source is invalid.\n\n    Examples:\n        &gt;&gt;&gt; # Load LangChain pipeline\n        &gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n        &gt;&gt;&gt; from langchain_openai import ChatOpenAI\n        &gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n        &gt;&gt;&gt; pipeline = Pipeline.load(chain, source=\"langchain\", temperature=0.7)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load HuggingFace pipeline\n        &gt;&gt;&gt; from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline\n        &gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n        &gt;&gt;&gt; model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n        &gt;&gt;&gt; pipe = pipeline(\"text-generation\", model=model, tokenizer=tokenizer, max_new_tokens=10)\n        &gt;&gt;&gt; pipeline = Pipeline.load(pipe, source=\"huggingface\")\n    \"\"\"\n    if not (hasattr(pipeline, \"__call__\") or hasattr(pipeline, \"invoke\")):\n        raise ValueError(\"Pipeline must be a callable object\")\n\n    # Validate source\n    source = source.lower()\n    if source not in [\"langchain\", \"huggingface\"]:\n        raise ValueError(\n            \"Source must be either 'langchain' or 'huggingface' for direct pipeline loading\"\n        )\n\n    # For HuggingFace pipelines, try to infer task if not provided\n    if source == \"huggingface\" and hasattr(pipeline, \"task\") and not task:\n        task = pipeline.task\n\n    instance = cls()\n    instance._configure_output_templates(template, template_path)\n\n    config = ModelConfig(\n        source=ModelSource(source),\n        pipeline_object=pipeline,\n        task=task,\n        kwargs=kwargs,\n    )\n\n    instance._model_config = config\n    instance.configure_pipeline(config)\n\n    return instance\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.remove","title":"<code>remove(component_name)</code>","text":"<p>Removes a component from the pipeline.</p> PARAMETER DESCRIPTION <code>component_name</code> <p>The name of the component to be removed.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the component is not found in the pipeline.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Logs <p>DEBUG: When the component is successfully removed. WARNING: If the component fails to be removed after attempting to do so.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def remove(self, component_name: str) -&gt; None:\n    \"\"\"\n    Removes a component from the pipeline.\n\n    Args:\n        component_name (str): The name of the component to be removed.\n\n    Raises:\n        ValueError: If the component is not found in the pipeline.\n\n    Returns:\n        None\n\n    Logs:\n        DEBUG: When the component is successfully removed.\n        WARNING: If the component fails to be removed after attempting to do so.\n    \"\"\"\n    # Check if the component exists in the pipeline\n    if not any(c.name == component_name for c in self._components):\n        raise ValueError(f\"Component '{component_name}' not found in the pipeline.\")\n\n    # Remove the component from self.components\n    original_count = len(self._components)\n    self._components = [c for c in self._components if c.name != component_name]\n\n    # Remove the component from stages\n    for stage in self._stages.values():\n        stage[:] = [c for c in stage if c.__name__ != component_name]\n\n    # Validate that the component was removed\n    if len(self._components) == original_count or any(\n        c.__name__ == component_name\n        for stage in self._stages.values()\n        for c in stage\n    ):\n        logger.warning(\n            f\"Failed to remove component '{component_name}' from the pipeline.\"\n        )\n    logger.debug(\n        f\"Successfully removed component '{component_name}' from the pipeline.\"\n    )\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.replace","title":"<code>replace(old_component_name, new_component)</code>","text":"<p>Replaces a component in the pipeline with a new component.</p> PARAMETER DESCRIPTION <code>old_component_name</code> <p>The name of the component to be replaced.</p> <p> TYPE: <code>str</code> </p> <code>new_component</code> <p>The new component to replace the old component with.</p> <p> TYPE: <code>Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the old component is not found in the pipeline.</p> <code>ValueError</code> <p>If the new component is not a BaseComponent or a callable.</p> <code>ValueError</code> <p>If the new component callable doesn't have the correct signature.</p> Logs <p>DEBUG: When the component is successfully replaced.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def replace(\n    self,\n    old_component_name: str,\n    new_component: Union[\n        BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n    ],\n) -&gt; None:\n    \"\"\"\n    Replaces a component in the pipeline with a new component.\n\n    Args:\n        old_component_name (str): The name of the component to be replaced.\n        new_component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]):\n            The new component to replace the old component with.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the old component is not found in the pipeline.\n        ValueError: If the new component is not a BaseComponent or a callable.\n        ValueError: If the new component callable doesn't have the correct signature.\n\n    Logs:\n        DEBUG: When the component is successfully replaced.\n    \"\"\"\n\n    if isinstance(new_component, BaseComponent):\n        # It's a valid BaseComponent, no further checks needed\n        pass\n    elif callable(new_component):\n        sig = signature(new_component)\n        param = list(sig.parameters.values())[0]\n        if len(sig.parameters) != 1 or not issubclass(\n            param.annotation, DataContainer\n        ):\n            raise ValueError(\n                \"New component callable must accept a single argument that is a subclass of DataContainer.\"\n            )\n    else:\n        raise ValueError(\"New component must be a BaseComponent or a callable.\")\n\n    old_component_found = False\n\n    # Replace in self.components\n    for i, c in enumerate(self._components):\n        if c.name == old_component_name:\n            self._components[i] = PipelineNode(\n                func=new_component,\n                name=old_component_name,\n                position=c.position,\n                reference=c.reference,\n                stage=c.stage,\n                dependencies=c.dependencies,\n            )\n            old_component_found = True\n\n    # Replace in self.stages\n    for stage in self._stages.values():\n        for i, c in enumerate(stage):\n            if getattr(c, \"name\", c.__name__) == old_component_name:\n                stage[i] = new_component\n                old_component_found = True\n\n    if not old_component_found:\n        raise ValueError(\n            f\"Component '{old_component_name}' not found in the pipeline.\"\n        )\n    else:\n        logger.debug(\n            f\"Successfully replaced component '{old_component_name}' in the pipeline.\"\n        )\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.ModelConfig","title":"<code>ModelConfig</code>  <code>dataclass</code>","text":"<p>Configuration for model initialization</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@dataclass\nclass ModelConfig:\n    \"\"\"Configuration for model initialization\"\"\"\n\n    source: ModelSource\n    model_id: Optional[str] = None\n    pipeline_object: Optional[Any] = None\n    task: Optional[str] = None\n    path: Optional[Path] = None\n    kwargs: Dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.ModelSource","title":"<code>ModelSource</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported model sources</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class ModelSource(Enum):\n    \"\"\"Enumeration of supported model sources\"\"\"\n\n    SPACY = \"spacy\"\n    HUGGINGFACE = \"huggingface\"\n    LANGCHAIN = \"langchain\"\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.Pipeline","title":"<code>Pipeline</code>","text":"<p>               Bases: <code>BasePipeline</code>, <code>Generic[T]</code></p> <p>Default Pipeline class for creating a basic data processing pipeline. This class inherits from BasePipeline and provides a default implementation of the configure_pipeline method, which does not add any specific components.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class Pipeline(BasePipeline, Generic[T]):\n    \"\"\"\n    Default Pipeline class for creating a basic data processing pipeline.\n    This class inherits from BasePipeline and provides a default implementation\n    of the configure_pipeline method, which does not add any specific components.\n    \"\"\"\n\n    def configure_pipeline(self, model_path: str) -&gt; None:\n        \"\"\"\n        Configures the pipeline by adding components based on the provided model path.\n        This default implementation does not add any specific components.\n\n        Args:\n            model_path (str): The path to the model used for configuring the pipeline.\n        \"\"\"\n        # Default implementation: No specific components added\n        pass\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.Pipeline.configure_pipeline","title":"<code>configure_pipeline(model_path)</code>","text":"<p>Configures the pipeline by adding components based on the provided model path. This default implementation does not add any specific components.</p> PARAMETER DESCRIPTION <code>model_path</code> <p>The path to the model used for configuring the pipeline.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def configure_pipeline(self, model_path: str) -&gt; None:\n    \"\"\"\n    Configures the pipeline by adding components based on the provided model path.\n    This default implementation does not add any specific components.\n\n    Args:\n        model_path (str): The path to the model used for configuring the pipeline.\n    \"\"\"\n    # Default implementation: No specific components added\n    pass\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.PipelineNode","title":"<code>PipelineNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Represents a node in a pipeline.</p> ATTRIBUTE DESCRIPTION <code>func</code> <p>The function to be applied to the data.</p> <p> TYPE: <code>Callable[[DataContainer[T]], DataContainer[T]]</code> </p> <code>position</code> <p>The position of the node in the pipeline. Defaults to \"default\".</p> <p> TYPE: <code>PositionType</code> </p> <code>reference</code> <p>The reference for the relative position of the node. Name should be the \"name\" attribute of another node. Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>stage</code> <p>The stage of the node in the pipeline. Group nodes by stage e.g. \"preprocessing\". Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of the node. Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>dependencies</code> <p>The list of dependencies for the node. Defaults to an empty list.</p> <p> TYPE: <code>List[str]</code> </p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@dataclass\nclass PipelineNode(Generic[T]):\n    \"\"\"\n    Represents a node in a pipeline.\n\n    Attributes:\n        func (Callable[[DataContainer[T]], DataContainer[T]]): The function to be applied to the data.\n        position (PositionType, optional): The position of the node in the pipeline. Defaults to \"default\".\n        reference (str, optional): The reference for the relative position of the node. Name should be the \"name\" attribute of another node. Defaults to None.\n        stage (str, optional): The stage of the node in the pipeline. Group nodes by stage e.g. \"preprocessing\". Defaults to None.\n        name (str, optional): The name of the node. Defaults to None.\n        dependencies (List[str], optional): The list of dependencies for the node. Defaults to an empty list.\n    \"\"\"\n\n    func: Callable[[DataContainer[T]], DataContainer[T]]\n    position: PositionType = \"default\"\n    reference: str = None\n    stage: str = None\n    name: str = None\n    dependencies: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/service/","title":"Service","text":""},{"location":"api/service/#healthchain.service.service.Service","title":"<code>Service</code>","text":"<p>A service wrapper which registers routes and starts a FastAPI service</p> <p>Parameters: endpoints (Dict[str, Enpoint]): the list of endpoints to register, must be a dictionary of Endpoint objects. Should have human-readable keys e.g. [\"info\", \"service_mount\"]</p> Source code in <code>healthchain/service/service.py</code> <pre><code>class Service:\n    \"\"\"\n    A service wrapper which registers routes and starts a FastAPI service\n\n    Parameters:\n    endpoints (Dict[str, Enpoint]): the list of endpoints to register, must be a dictionary\n    of Endpoint objects. Should have human-readable keys e.g. [\"info\", \"service_mount\"]\n\n    \"\"\"\n\n    def __init__(self, endpoints: Dict[str, Endpoint] = None):\n        self.app = FastAPI(lifespan=self.lifespan)\n        self.endpoints: Endpoint = endpoints\n\n        if self.endpoints is not None:\n            self._register_routes()\n\n        # Router to handle stopping the server\n        self.stop_router = APIRouter()\n        self.stop_router.add_api_route(\n            \"/shutdown\", self._shutdown, methods=[\"GET\"], include_in_schema=False\n        )\n        self.app.include_router(self.stop_router)\n\n    def _register_routes(self) -&gt; None:\n        # TODO: add kwargs\n        for endpoint in self.endpoints.values():\n            if endpoint.api_protocol == ApiProtocol.soap:\n                wsgi_app = start_wsgi(endpoint.function)\n                self.app.mount(endpoint.path, WSGIMiddleware(wsgi_app))\n            else:\n                self.app.add_api_route(\n                    endpoint.path,\n                    endpoint.function,\n                    methods=[endpoint.method],\n                    response_model_exclude_none=True,\n                )\n\n    @asynccontextmanager\n    async def lifespan(self, app: FastAPI):\n        self._startup()\n        yield\n        self._shutdown()\n\n    def _startup(self) -&gt; None:\n        healthchain_ascii = r\"\"\"\n\n    __  __           ____  __    ________          _\n   / / / /__  ____ _/ / /_/ /_  / ____/ /_  ____ _(_)___\n  / /_/ / _ \\/ __ `/ / __/ __ \\/ /   / __ \\/ __ `/ / __ \\\n / __  /  __/ /_/ / / /_/ / / / /___/ / / / /_/ / / / / /\n/_/ /_/\\___/\\__,_/_/\\__/_/ /_/\\____/_/ /_/\\__,_/_/_/ /_/\n\n\"\"\"  # noqa: E501\n\n        colors = [\"red\", \"yellow\", \"green\", \"cyan\", \"blue\", \"magenta\"]\n        for i, line in enumerate(healthchain_ascii.split(\"\\n\")):\n            color = colors[i % len(colors)]\n            print(colored(line, color))\n        for endpoint in self.endpoints.values():\n            print(\n                f\"{colored('HEALTHCHAIN', 'green')}: {endpoint.method} endpoint at {endpoint.path}/\"\n            )\n        print(\n            f\"{colored('HEALTHCHAIN', 'green')}: See more details at {colored(self.app.docs_url, 'magenta')}\"\n        )\n\n    def _shutdown(self):\n        \"\"\"\n        Shuts down server\n        \"\"\"\n        os.kill(os.getpid(), signal.SIGTERM)\n        return JSONResponse(content={\"message\": \"Server is shutting down...\"})\n\n    def run(self, config: Dict = None) -&gt; None:\n        \"\"\"\n        Starts server on uvicorn.\n\n        Parameters:\n        config (Dict): kwargs to pass into uvicorn.\n\n        \"\"\"\n        if config is None:\n            config = {}\n\n        uvicorn.run(self.app, **config)\n</code></pre>"},{"location":"api/service/#healthchain.service.service.Service.run","title":"<code>run(config=None)</code>","text":"<p>Starts server on uvicorn.</p> <p>Parameters: config (Dict): kwargs to pass into uvicorn.</p> Source code in <code>healthchain/service/service.py</code> <pre><code>def run(self, config: Dict = None) -&gt; None:\n    \"\"\"\n    Starts server on uvicorn.\n\n    Parameters:\n    config (Dict): kwargs to pass into uvicorn.\n\n    \"\"\"\n    if config is None:\n        config = {}\n\n    uvicorn.run(self.app, **config)\n</code></pre>"},{"location":"api/use_cases/","title":"Use Cases","text":""},{"location":"api/use_cases/#healthchain.use_cases.cds.ClinicalDecisionSupport","title":"<code>ClinicalDecisionSupport</code>","text":"<p>               Bases: <code>BaseUseCase</code></p> <p>Implements EHR backend simulator for Clinical Decision Support (CDS)</p> PARAMETER DESCRIPTION <code>service_api</code> <p>the function body to inject into the main service</p> <p> TYPE: <code>APIMethod</code> DEFAULT: <code>None</code> </p> <code>service_config</code> <p>the config kwargs for the uvicorn server passed into service</p> <p> TYPE: <code>Dict</code> DEFAULT: <code>None</code> </p> <code>service</code> <p>the service runner object</p> <p> TYPE: <code>Service</code> DEFAULT: <code>None</code> </p> <code>client</code> <p>the client runner object</p> <p> TYPE: <code>BaseClient</code> DEFAULT: <code>None</code> </p> <p>See https://cds-hooks.org/ for specification</p> Source code in <code>healthchain/use_cases/cds.py</code> <pre><code>class ClinicalDecisionSupport(BaseUseCase):\n    \"\"\"\n    Implements EHR backend simulator for Clinical Decision Support (CDS)\n\n    Parameters:\n        service_api (APIMethod): the function body to inject into the main service\n        service_config (Dict): the config kwargs for the uvicorn server passed into service\n        service (Service): the service runner object\n        client (BaseClient): the client runner object\n\n    See https://cds-hooks.org/ for specification\n    \"\"\"\n\n    def __init__(\n        self,\n        service_api: Optional[APIMethod] = None,\n        service_config: Optional[Dict] = None,\n        service: Optional[Service] = None,\n        client: Optional[BaseClient] = None,\n    ) -&gt; None:\n        super().__init__(\n            service_api=service_api,\n            service_config=service_config,\n            service=service,\n            client=client,\n        )\n        self._type = UseCaseType.cds\n        self._strategy = ClinicalDecisionSupportStrategy()\n        # do we need keys? just in case\n        # TODO make configurable\n        self._endpoints = {\n            \"info\": Endpoint(\n                path=\"/cds-services\",\n                method=\"GET\",\n                function=self.cds_discovery,\n                api_protocol=\"REST\",\n            ),\n            \"service_mount\": Endpoint(\n                path=\"/cds-services/{id}\",\n                method=\"POST\",\n                function=self.cds_service,\n                api_protocol=\"REST\",\n            ),\n        }\n\n    @property\n    def description(self) -&gt; str:\n        return \"Clinical decision support (HL7 CDS specification)\"\n\n    @property\n    def type(self) -&gt; UseCaseType:\n        return self._type\n\n    @property\n    def strategy(self) -&gt; BaseStrategy:\n        return self._strategy\n\n    @property\n    def endpoints(self) -&gt; Dict[str, Endpoint]:\n        return self._endpoints\n\n    def cds_discovery(self) -&gt; CDSServiceInformation:\n        \"\"\"\n        CDS discovery endpoint for FastAPI app, should be mounted to /cds-services\n        \"\"\"\n        if self._client is None:\n            log.warning(\"CDS 'client' not configured, check class init.\")\n            return CDSServiceInformation(services=[])\n\n        service_info = CDSService(\n            hook=self._client.workflow.value,\n            description=\"A test CDS hook service.\",\n            id=\"1\",\n        )\n        return CDSServiceInformation(services=[service_info])\n\n    def cds_service(self, id: str, request: CDSRequest) -&gt; CDSResponse:\n        \"\"\"\n        CDS service endpoint for FastAPI app, mounted to /cds-services/{id}\n\n        This method handles the execution of a specific CDS service. It validates the\n        service configuration, checks the input parameters, executes the service\n        function, and ensures the correct response type is returned.\n\n        Args:\n            id (str): The unique identifier of the CDS service to be executed.\n            request (CDSRequest): The request object containing the input data for the CDS service.\n\n        Returns:\n            CDSResponse: The response object containing the cards generated by the CDS service.\n\n        Raises:\n            AssertionError: If the service function is not properly configured.\n            TypeError: If the input or output types do not match the expected types.\n\n        Note:\n            This method performs several checks to ensure the integrity of the service:\n            1. Verifies that the service API is configured.\n            2. Validates the signature of the service function.\n            3. Ensures the service function accepts a CDSRequest as its first argument.\n            4. Verifies that the service function returns a CDSResponse.\n        \"\"\"\n        # TODO: can register multiple services and fetch with id\n\n        # Check service_api\n        if self._service_api is None:\n            log.warning(\"CDS 'service_api' not configured, check class init.\")\n            return CDSResponse(cards=[])\n\n        # Check that the first argument of self._service_api.func is of type CDSRequest\n        func_signature = inspect.signature(self._service_api.func)\n        params = list(func_signature.parameters.values())\n        if len(params) &lt; 2:  # Only 'self' parameter\n            raise AssertionError(\n                \"Service function must have at least one parameter besides 'self'\"\n            )\n        first_param = params[1]  # Skip 'self'\n        if first_param.annotation == inspect.Parameter.empty:\n            log.warning(\n                \"Service function parameter has no type annotation. Expected CDSRequest.\"\n            )\n        elif first_param.annotation != CDSRequest:\n            raise TypeError(\n                f\"Expected first argument of service function to be CDSRequest, but got {first_param.annotation}\"\n            )\n\n        # Call the service function\n        response = self._service_api.func(self, request)\n\n        # Check that response is of type CDSResponse\n        if not isinstance(response, CDSResponse):\n            raise TypeError(f\"Expected CDSResponse, but got {type(response).__name__}\")\n\n        return response\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.cds.ClinicalDecisionSupport.cds_discovery","title":"<code>cds_discovery()</code>","text":"<p>CDS discovery endpoint for FastAPI app, should be mounted to /cds-services</p> Source code in <code>healthchain/use_cases/cds.py</code> <pre><code>def cds_discovery(self) -&gt; CDSServiceInformation:\n    \"\"\"\n    CDS discovery endpoint for FastAPI app, should be mounted to /cds-services\n    \"\"\"\n    if self._client is None:\n        log.warning(\"CDS 'client' not configured, check class init.\")\n        return CDSServiceInformation(services=[])\n\n    service_info = CDSService(\n        hook=self._client.workflow.value,\n        description=\"A test CDS hook service.\",\n        id=\"1\",\n    )\n    return CDSServiceInformation(services=[service_info])\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.cds.ClinicalDecisionSupport.cds_service","title":"<code>cds_service(id, request)</code>","text":"<p>CDS service endpoint for FastAPI app, mounted to /cds-services/{id}</p> <p>This method handles the execution of a specific CDS service. It validates the service configuration, checks the input parameters, executes the service function, and ensures the correct response type is returned.</p> PARAMETER DESCRIPTION <code>id</code> <p>The unique identifier of the CDS service to be executed.</p> <p> TYPE: <code>str</code> </p> <code>request</code> <p>The request object containing the input data for the CDS service.</p> <p> TYPE: <code>CDSRequest</code> </p> RETURNS DESCRIPTION <code>CDSResponse</code> <p>The response object containing the cards generated by the CDS service.</p> <p> TYPE: <code>CDSResponse</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the service function is not properly configured.</p> <code>TypeError</code> <p>If the input or output types do not match the expected types.</p> Note <p>This method performs several checks to ensure the integrity of the service: 1. Verifies that the service API is configured. 2. Validates the signature of the service function. 3. Ensures the service function accepts a CDSRequest as its first argument. 4. Verifies that the service function returns a CDSResponse.</p> Source code in <code>healthchain/use_cases/cds.py</code> <pre><code>def cds_service(self, id: str, request: CDSRequest) -&gt; CDSResponse:\n    \"\"\"\n    CDS service endpoint for FastAPI app, mounted to /cds-services/{id}\n\n    This method handles the execution of a specific CDS service. It validates the\n    service configuration, checks the input parameters, executes the service\n    function, and ensures the correct response type is returned.\n\n    Args:\n        id (str): The unique identifier of the CDS service to be executed.\n        request (CDSRequest): The request object containing the input data for the CDS service.\n\n    Returns:\n        CDSResponse: The response object containing the cards generated by the CDS service.\n\n    Raises:\n        AssertionError: If the service function is not properly configured.\n        TypeError: If the input or output types do not match the expected types.\n\n    Note:\n        This method performs several checks to ensure the integrity of the service:\n        1. Verifies that the service API is configured.\n        2. Validates the signature of the service function.\n        3. Ensures the service function accepts a CDSRequest as its first argument.\n        4. Verifies that the service function returns a CDSResponse.\n    \"\"\"\n    # TODO: can register multiple services and fetch with id\n\n    # Check service_api\n    if self._service_api is None:\n        log.warning(\"CDS 'service_api' not configured, check class init.\")\n        return CDSResponse(cards=[])\n\n    # Check that the first argument of self._service_api.func is of type CDSRequest\n    func_signature = inspect.signature(self._service_api.func)\n    params = list(func_signature.parameters.values())\n    if len(params) &lt; 2:  # Only 'self' parameter\n        raise AssertionError(\n            \"Service function must have at least one parameter besides 'self'\"\n        )\n    first_param = params[1]  # Skip 'self'\n    if first_param.annotation == inspect.Parameter.empty:\n        log.warning(\n            \"Service function parameter has no type annotation. Expected CDSRequest.\"\n        )\n    elif first_param.annotation != CDSRequest:\n        raise TypeError(\n            f\"Expected first argument of service function to be CDSRequest, but got {first_param.annotation}\"\n        )\n\n    # Call the service function\n    response = self._service_api.func(self, request)\n\n    # Check that response is of type CDSResponse\n    if not isinstance(response, CDSResponse):\n        raise TypeError(f\"Expected CDSResponse, but got {type(response).__name__}\")\n\n    return response\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.cds.ClinicalDecisionSupportStrategy","title":"<code>ClinicalDecisionSupportStrategy</code>","text":"<p>               Bases: <code>BaseStrategy</code></p> <p>Handles the request construction and validation</p> Source code in <code>healthchain/use_cases/cds.py</code> <pre><code>class ClinicalDecisionSupportStrategy(BaseStrategy):\n    \"\"\"\n    Handles the request construction and validation\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.api_protocol = ApiProtocol.rest\n        self.context_mapping = {\n            Workflow.order_select: OrderSelectContext,\n            Workflow.order_sign: OrderSignContext,\n            Workflow.patient_view: PatientViewContext,\n            Workflow.encounter_discharge: EncounterDischargeContext,\n        }\n\n    @validate_workflow(UseCaseMapping.ClinicalDecisionSupport)\n    def construct_request(\n        self,\n        prefetch_data: Dict[str, Resource],\n        workflow: Workflow,\n        context: Optional[Dict[str, str]] = {},\n    ) -&gt; CDSRequest:\n        \"\"\"\n        Constructs a HL7-compliant CDS request based on workflow.\n\n        Parameters:\n            prefetch_data (Dict[str, Resource]): Dictionary mapping prefetch keys to FHIR resources\n            workflow (Workflow): The CDS hook name, e.g. patient-view\n            context (Optional[Dict[str, str]]): Optional context data for the CDS hook\n\n        Returns:\n            CDSRequest: A Pydantic model that wraps a CDS request for REST API\n\n        Raises:\n            ValueError: If the workflow is invalid or not implemented\n            TypeError: If any prefetch value is not a valid FHIR resource\n        \"\"\"\n        log.debug(f\"Constructing CDS request for {workflow.value} from {prefetch_data}\")\n\n        context_model = self.context_mapping.get(workflow, None)\n        if context_model is None:\n            raise ValueError(\n                f\"Invalid workflow {workflow.value} or workflow model not implemented.\"\n            )\n        if not isinstance(prefetch_data, Prefetch):\n            raise TypeError(\n                f\"Prefetch data must be a Prefetch object, but got {type(prefetch_data)}\"\n            )\n\n        request = CDSRequest(\n            hook=workflow.value,\n            context=context_model(**context),\n            prefetch=prefetch_data.prefetch,\n        )\n\n        return request\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.cds.ClinicalDecisionSupportStrategy.construct_request","title":"<code>construct_request(prefetch_data, workflow, context={})</code>","text":"<p>Constructs a HL7-compliant CDS request based on workflow.</p> PARAMETER DESCRIPTION <code>prefetch_data</code> <p>Dictionary mapping prefetch keys to FHIR resources</p> <p> TYPE: <code>Dict[str, Resource]</code> </p> <code>workflow</code> <p>The CDS hook name, e.g. patient-view</p> <p> TYPE: <code>Workflow</code> </p> <code>context</code> <p>Optional context data for the CDS hook</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>CDSRequest</code> <p>A Pydantic model that wraps a CDS request for REST API</p> <p> TYPE: <code>CDSRequest</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the workflow is invalid or not implemented</p> <code>TypeError</code> <p>If any prefetch value is not a valid FHIR resource</p> Source code in <code>healthchain/use_cases/cds.py</code> <pre><code>@validate_workflow(UseCaseMapping.ClinicalDecisionSupport)\ndef construct_request(\n    self,\n    prefetch_data: Dict[str, Resource],\n    workflow: Workflow,\n    context: Optional[Dict[str, str]] = {},\n) -&gt; CDSRequest:\n    \"\"\"\n    Constructs a HL7-compliant CDS request based on workflow.\n\n    Parameters:\n        prefetch_data (Dict[str, Resource]): Dictionary mapping prefetch keys to FHIR resources\n        workflow (Workflow): The CDS hook name, e.g. patient-view\n        context (Optional[Dict[str, str]]): Optional context data for the CDS hook\n\n    Returns:\n        CDSRequest: A Pydantic model that wraps a CDS request for REST API\n\n    Raises:\n        ValueError: If the workflow is invalid or not implemented\n        TypeError: If any prefetch value is not a valid FHIR resource\n    \"\"\"\n    log.debug(f\"Constructing CDS request for {workflow.value} from {prefetch_data}\")\n\n    context_model = self.context_mapping.get(workflow, None)\n    if context_model is None:\n        raise ValueError(\n            f\"Invalid workflow {workflow.value} or workflow model not implemented.\"\n        )\n    if not isinstance(prefetch_data, Prefetch):\n        raise TypeError(\n            f\"Prefetch data must be a Prefetch object, but got {type(prefetch_data)}\"\n        )\n\n    request = CDSRequest(\n        hook=workflow.value,\n        context=context_model(**context),\n        prefetch=prefetch_data.prefetch,\n    )\n\n    return request\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdsrequest.CDSRequest","title":"<code>CDSRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model representing the data structure for a CDS service call, triggered by specific hooks within a healthcare application.</p> ATTRIBUTE DESCRIPTION <code>hook</code> <p>The hook that triggered this CDS Service call. For example, 'patient-view'.</p> <p> TYPE: <code>str</code> </p> <code>hookInstance</code> <p>A universally unique identifier for this particular hook call.</p> <p> TYPE: <code>UUID</code> </p> <code>fhirServer</code> <p>The base URL of the CDS Client's FHIR server. This field is required if <code>fhirAuthorization</code> is provided.</p> <p> TYPE: <code>HttpUrl</code> </p> <code>fhirAuthorization</code> <p>Optional authorization details providing a bearer access token for FHIR resources.</p> <p> TYPE: <code>Optional[FhirAuthorization]</code> </p> <code>context</code> <p>Hook-specific contextual data required by the CDS service.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>prefetch</code> <p>Optional FHIR data that was prefetched by the CDS Client.</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#http-request_1</p> Source code in <code>healthchain/models/requests/cdsrequest.py</code> <pre><code>class CDSRequest(BaseModel):\n    \"\"\"\n    A model representing the data structure for a CDS service call, triggered by specific hooks\n    within a healthcare application.\n\n    Attributes:\n        hook (str): The hook that triggered this CDS Service call. For example, 'patient-view'.\n        hookInstance (UUID): A universally unique identifier for this particular hook call.\n        fhirServer (HttpUrl): The base URL of the CDS Client's FHIR server. This field is required if `fhirAuthorization` is provided.\n        fhirAuthorization (Optional[FhirAuthorization]): Optional authorization details providing a bearer access token for FHIR resources.\n        context (Dict[str, Any]): Hook-specific contextual data required by the CDS service.\n        prefetch (Optional[Dict[str, Any]]): Optional FHIR data that was prefetched by the CDS Client.\n\n    Documentation: https://cds-hooks.org/specification/current/#http-request_1\n    \"\"\"\n\n    hook: str\n    hookInstance: str = Field(default_factory=id_generator.generate_random_uuid)\n    context: BaseHookContext\n    fhirServer: Optional[HttpUrl] = None\n    fhirAuthorization: Optional[FHIRAuthorization] = (\n        None  # TODO: note this is required if fhirserver is given\n    )\n    prefetch: Optional[Dict[str, Any]] = (\n        None  # fhir resource is passed either thru prefetched template of fhir server\n    )\n    extension: Optional[List[Dict[str, Any]]] = None\n\n    def model_dump(self, **kwargs):\n        \"\"\"\n        Model dump method to convert any nested datetime and byte objects to strings for readability.\n        This is also a workaround to this Pydantic V2 issue https://github.com/pydantic/pydantic/issues/9571\n        For proper JSON serialization, should use model_dump_json() instead when issue is resolved.\n        \"\"\"\n\n        def convert_objects(obj):\n            if isinstance(obj, dict):\n                return {k: convert_objects(v) for k, v in obj.items()}\n            elif isinstance(obj, list):\n                return [convert_objects(i) for i in obj]\n            elif isinstance(obj, datetime):\n                return obj.astimezone().isoformat()\n            elif isinstance(obj, bytes):\n                return obj.decode(\"utf-8\")\n            return obj\n\n        dump = super().model_dump(**kwargs)\n        return convert_objects(dump)\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdsrequest.CDSRequest.model_dump","title":"<code>model_dump(**kwargs)</code>","text":"<p>Model dump method to convert any nested datetime and byte objects to strings for readability. This is also a workaround to this Pydantic V2 issue https://github.com/pydantic/pydantic/issues/9571 For proper JSON serialization, should use model_dump_json() instead when issue is resolved.</p> Source code in <code>healthchain/models/requests/cdsrequest.py</code> <pre><code>def model_dump(self, **kwargs):\n    \"\"\"\n    Model dump method to convert any nested datetime and byte objects to strings for readability.\n    This is also a workaround to this Pydantic V2 issue https://github.com/pydantic/pydantic/issues/9571\n    For proper JSON serialization, should use model_dump_json() instead when issue is resolved.\n    \"\"\"\n\n    def convert_objects(obj):\n        if isinstance(obj, dict):\n            return {k: convert_objects(v) for k, v in obj.items()}\n        elif isinstance(obj, list):\n            return [convert_objects(i) for i in obj]\n        elif isinstance(obj, datetime):\n            return obj.astimezone().isoformat()\n        elif isinstance(obj, bytes):\n            return obj.decode(\"utf-8\")\n        return obj\n\n    dump = super().model_dump(**kwargs)\n    return convert_objects(dump)\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.Action","title":"<code>Action</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Within a suggestion, all actions are logically AND'd together, such that a user selecting a suggestion selects all of the actions within it. When a suggestion contains multiple actions, the actions SHOULD be processed as per FHIR's rules for processing transactions with the CDS Client's fhirServer as the base url for the inferred full URL of the transaction bundle entries.</p> <p>https://cds-hooks.org/specification/current/#action</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Action(BaseModel):\n    \"\"\"\n    Within a suggestion, all actions are logically AND'd together, such that a user selecting a\n    suggestion selects all of the actions within it. When a suggestion contains multiple actions,\n    the actions SHOULD be processed as per FHIR's rules for processing transactions with the CDS\n    Client's fhirServer as the base url for the inferred full URL of the transaction bundle entries.\n\n    https://cds-hooks.org/specification/current/#action\n    \"\"\"\n\n    type: ActionTypeEnum\n    description: str\n    resource: Optional[Dict] = None\n    resourceId: Optional[str] = None\n\n    @model_validator(mode=\"after\")\n    def validate_action_type(self) -&gt; Self:\n        if self.type in [ActionTypeEnum.create, ActionTypeEnum.update]:\n            assert (\n                self.resource\n            ), f\"'resource' must be provided when type is '{self.type.value}'\"\n        else:\n            assert (\n                self.resourceId\n            ), f\"'resourceId' must be provided when type is '{self.type.value}'\"\n\n        return self\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.ActionTypeEnum","title":"<code>ActionTypeEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of action being performed</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class ActionTypeEnum(str, Enum):\n    \"\"\"\n    The type of action being performed\n    \"\"\"\n\n    create = \"create\"\n    update = \"update\"\n    delete = \"delete\"\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.CDSResponse","title":"<code>CDSResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the response from a CDS service.</p> <p>This class models the structure of a CDS Hooks response, which includes cards for displaying information or suggestions to the user, and optional system actions that can be executed automatically.</p> ATTRIBUTE DESCRIPTION <code>cards</code> <p>A list of Card objects to be displayed to the end user. Default is an empty list.</p> <p> TYPE: <code>List[Card]</code> </p> <code>systemActions</code> <p>A list of Action objects representing actions that the CDS Client should execute as part of performing the decision support requested. This field is optional.</p> <p> TYPE: <code>Optional[List[Action]]</code> </p> <p>For more information, see: https://cds-hooks.org/specification/current/#cds-service-response</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class CDSResponse(BaseModel):\n    \"\"\"\n    Represents the response from a CDS service.\n\n    This class models the structure of a CDS Hooks response, which includes\n    cards for displaying information or suggestions to the user, and optional\n    system actions that can be executed automatically.\n\n    Attributes:\n        cards (List[Card]): A list of Card objects to be displayed to the end user.\n            Default is an empty list.\n        systemActions (Optional[List[Action]]): A list of Action objects representing\n            actions that the CDS Client should execute as part of performing\n            the decision support requested. This field is optional.\n\n    For more information, see:\n    https://cds-hooks.org/specification/current/#cds-service-response\n    \"\"\"\n\n    cards: List[Card] = []\n    systemActions: Optional[List[Action]] = None\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.Card","title":"<code>Card</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Cards can provide a combination of information (for reading), suggested actions (to be applied if a user selects them), and links (to launch an app if the user selects them). The CDS Client decides how to display cards, but this specification recommends displaying suggestions using buttons, and links using underlined text.</p> <p>https://cds-hooks.org/specification/current/#card-attributes</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Card(BaseModel):\n    \"\"\"\n    Cards can provide a combination of information (for reading), suggested actions\n    (to be applied if a user selects them), and links (to launch an app if the user selects them).\n    The CDS Client decides how to display cards, but this specification recommends displaying suggestions\n    using buttons, and links using underlined text.\n\n    https://cds-hooks.org/specification/current/#card-attributes\n    \"\"\"\n\n    summary: str = Field(..., max_length=140)\n    indicator: IndicatorEnum\n    source: Source\n    uuid: Optional[str] = None\n    detail: Optional[str] = None\n    suggestions: Optional[List[Suggestion]] = None\n    selectionBehavior: Optional[SelectionBehaviorEnum] = None\n    overrideReasons: Optional[List[SimpleCoding]] = None\n    links: Optional[List[Link]] = None\n\n    @model_validator(mode=\"after\")\n    def validate_suggestions(self) -&gt; Self:\n        if self.suggestions is not None:\n            assert self.selectionBehavior, f\"'selectionBehavior' must be given if 'suggestions' is present! Choose from {[v for v in SelectionBehaviorEnum.value]}\"\n        return self\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.IndicatorEnum","title":"<code>IndicatorEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Urgency/importance of what Card conveys. Allowed values, in order of increasing urgency, are: info, warning, critical. The CDS Client MAY use this field to help make UI display decisions such as sort order or coloring.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class IndicatorEnum(str, Enum):\n    \"\"\"\n    Urgency/importance of what Card conveys.\n    Allowed values, in order of increasing urgency, are: info, warning, critical.\n    The CDS Client MAY use this field to help make UI display decisions such as sort order or coloring.\n    \"\"\"\n\n    info = \"info\"\n    warning = \"warning\"\n    critical = \"critical\"\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.Link","title":"<code>Link</code>","text":"<p>               Bases: <code>BaseModel</code></p> <ul> <li> <p>CDS Client support for appContext requires additional coordination with the authorization server that is not described or specified in CDS Hooks nor SMART.</p> </li> <li> <p>Autolaunchable is experimental</p> </li> </ul> <p>https://cds-hooks.org/specification/current/#link</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Link(BaseModel):\n    \"\"\"\n    * CDS Client support for appContext requires additional coordination with the authorization\n    server that is not described or specified in CDS Hooks nor SMART.\n\n    * Autolaunchable is experimental\n\n    https://cds-hooks.org/specification/current/#link\n    \"\"\"\n\n    label: str\n    url: HttpUrl\n    type: LinkTypeEnum\n    appContext: Optional[str] = None\n    autoLaunchable: Optional[bool]\n\n    @model_validator(mode=\"after\")\n    def validate_link(self) -&gt; Self:\n        if self.appContext:\n            assert (\n                self.type == LinkTypeEnum.smart\n            ), \"'type' must be 'smart' for appContext to be valued.\"\n\n        return self\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.LinkTypeEnum","title":"<code>LinkTypeEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of the given URL. There are two possible values for this field. A type of absolute indicates that the URL is absolute and should be treated as-is. A type of smart indicates that the URL is a SMART app launch URL and the CDS Client should ensure the SMART app launch URL is populated with the appropriate SMART launch parameters.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class LinkTypeEnum(str, Enum):\n    \"\"\"\n    The type of the given URL. There are two possible values for this field.\n    A type of absolute indicates that the URL is absolute and should be treated as-is.\n    A type of smart indicates that the URL is a SMART app launch URL and the CDS Client\n    should ensure the SMART app launch URL is populated with the appropriate SMART\n    launch parameters.\n    \"\"\"\n\n    absolute = \"absolute\"\n    smart = \"smart\"\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.SelectionBehaviorEnum","title":"<code>SelectionBehaviorEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Describes the intended selection behavior of the suggestions in the card. Allowed values are: at-most-one, indicating that the user may choose none or at most one of the suggestions; any, indicating that the end user may choose any number of suggestions including none of them and all of them. CDS Clients that do not understand the value MUST treat the card as an error.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class SelectionBehaviorEnum(str, Enum):\n    \"\"\"\n    Describes the intended selection behavior of the suggestions in the card.\n    Allowed values are: at-most-one, indicating that the user may choose none or\n    at most one of the suggestions; any, indicating that the end user may choose\n    any number of suggestions including none of them and all of them.\n    CDS Clients that do not understand the value MUST treat the card as an error.\n    \"\"\"\n\n    at_most_one = \"at-most-one\"\n    any = \"any\"\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.SimpleCoding","title":"<code>SimpleCoding</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The Coding data type captures the concept of a code. This coding type is a standalone data type in CDS Hooks modeled after a trimmed down version of the FHIR Coding data type.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class SimpleCoding(BaseModel):\n    \"\"\"\n    The Coding data type captures the concept of a code. This coding type is a standalone data type\n    in CDS Hooks modeled after a trimmed down version of the FHIR Coding data type.\n    \"\"\"\n\n    code: str\n    system: str\n    display: Optional[str] = None\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.Source","title":"<code>Source</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Grouping structure for the Source of the information displayed on this card. The source should be the primary source of guidance for the decision support Card represents.</p> <p>https://cds-hooks.org/specification/current/#source</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Source(BaseModel):\n    \"\"\"\n    Grouping structure for the Source of the information displayed on this card.\n    The source should be the primary source of guidance for the decision support Card represents.\n\n    https://cds-hooks.org/specification/current/#source\n    \"\"\"\n\n    label: str\n    url: Optional[HttpUrl] = None\n    icon: Optional[HttpUrl] = None\n    topic: Optional[SimpleCoding] = None\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdsresponse.Suggestion","title":"<code>Suggestion</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Allows a service to suggest a set of changes in the context of the current activity (e.g. changing the dose of a medication currently being prescribed, for the order-sign activity). If suggestions are present, selectionBehavior MUST also be provided.</p> <p>https://cds-hooks.org/specification/current/#suggestion</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Suggestion(BaseModel):\n    \"\"\"\n    Allows a service to suggest a set of changes in the context of the current activity\n    (e.g. changing the dose of a medication currently being prescribed, for the order-sign activity).\n    If suggestions are present, selectionBehavior MUST also be provided.\n\n    https://cds-hooks.org/specification/current/#suggestion\n    \"\"\"\n\n    label: str\n    uuid: Optional[str] = None\n    isRecommended: Optional[bool]\n    actions: Optional[List[Action]] = []\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.clindoc.ClinicalDocumentation","title":"<code>ClinicalDocumentation</code>","text":"<p>               Bases: <code>BaseUseCase</code></p> <p>Implements EHR backend strategy for clinical documentation (NoteReader)</p> <p>This class represents the backend strategy for clinical documentation using the NoteReader system. It inherits from the <code>BaseUseCase</code> class and provides methods for processing NoteReader documents.</p> ATTRIBUTE DESCRIPTION <code>service_api</code> <p>The service API method to be used for processing the documents.</p> <p> TYPE: <code>Optional[APIMethod]</code> </p> <code>service_config</code> <p>The configuration for the service.</p> <p> TYPE: <code>Optional[Dict]</code> </p> <code>service</code> <p>The service to be used for processing the documents.</p> <p> TYPE: <code>Optional[Service]</code> </p> <code>client</code> <p>The client to be used for communication with the service.</p> <p> TYPE: <code>Optional[BaseClient]</code> </p> Source code in <code>healthchain/use_cases/clindoc.py</code> <pre><code>class ClinicalDocumentation(BaseUseCase):\n    \"\"\"\n    Implements EHR backend strategy for clinical documentation (NoteReader)\n\n    This class represents the backend strategy for clinical documentation using the NoteReader system.\n    It inherits from the `BaseUseCase` class and provides methods for processing NoteReader documents.\n\n    Attributes:\n        service_api (Optional[APIMethod]): The service API method to be used for processing the documents.\n        service_config (Optional[Dict]): The configuration for the service.\n        service (Optional[Service]): The service to be used for processing the documents.\n        client (Optional[BaseClient]): The client to be used for communication with the service.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        service_api: Optional[APIMethod] = None,\n        service_config: Optional[Dict] = None,\n        service: Optional[Service] = None,\n        client: Optional[BaseClient] = None,\n    ) -&gt; None:\n        super().__init__(\n            service_api=service_api,\n            service_config=service_config,\n            service=service,\n            client=client,\n        )\n        self._type = UseCaseType.clindoc\n        self._strategy = ClinicalDocumentationStrategy()\n        self._endpoints = {\n            \"service_mount\": Endpoint(\n                path=\"/notereader/\",\n                method=\"POST\",\n                function=self.process_notereader_document,\n                api_protocol=\"SOAP\",\n            )\n        }\n\n    @property\n    def description(self) -&gt; str:\n        return \"Clinical documentation (NoteReader)\"\n\n    @property\n    def type(self) -&gt; UseCaseType:\n        return self._type\n\n    @property\n    def strategy(self) -&gt; BaseStrategy:\n        return self._strategy\n\n    @property\n    def endpoints(self) -&gt; Dict[str, Endpoint]:\n        return self._endpoints\n\n    def process_notereader_document(self, request: CdaRequest) -&gt; CdaResponse:\n        \"\"\"\n        Process the NoteReader document using the configured service API.\n\n        This method handles the execution of the NoteReader service. It validates the\n        service configuration, checks the input parameters, executes the service\n        function, and ensures the correct response type is returned.\n\n        Args:\n            request (CdaRequest): The request object containing the CDA document to be processed.\n\n        Returns:\n            CdaResponse: The response object containing the processed CDA document.\n\n        Raises:\n            AssertionError: If the service function is not properly configured.\n            TypeError: If the output type does not match the expected CdaResponse type.\n\n        Note:\n            This method performs several checks to ensure the integrity of the service:\n            1. Verifies that the service API is configured.\n            2. Validates the signature of the service function.\n            3. Ensures the service function accepts a CdaRequest as its argument.\n            4. Verifies that the service function returns a CdaResponse.\n        \"\"\"\n        # Check service_api\n        if self._service_api is None:\n            log.warning(\"'service_api' not configured, check class init.\")\n            return CdaResponse(document=\"\")\n\n        # Check service function signature\n        signature = inspect.signature(self._service_api.func)\n        params = list(signature.parameters.values())\n        if len(params) &lt; 2:  # Only 'self' parameter\n            raise AssertionError(\n                \"Service function must have at least one parameter besides 'self'\"\n            )\n        first_param = params[1]  # Skip 'self'\n        if first_param.annotation == inspect.Parameter.empty:\n            log.warning(\n                \"Service function parameter has no type annotation. Expected CdaRequest.\"\n            )\n        elif first_param.annotation != CdaRequest:\n            raise TypeError(\n                f\"Expected first argument of service function to be CdaRequest, but got {first_param.annotation}\"\n            )\n\n        # Call the service function\n        response = self._service_api.func(self, request)\n\n        # Check return type\n        if not isinstance(response, CdaResponse):\n            raise TypeError(\n                f\"Expected return type CdaResponse, got {type(response)} instead.\"\n            )\n\n        return response\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.clindoc.ClinicalDocumentation.process_notereader_document","title":"<code>process_notereader_document(request)</code>","text":"<p>Process the NoteReader document using the configured service API.</p> <p>This method handles the execution of the NoteReader service. It validates the service configuration, checks the input parameters, executes the service function, and ensures the correct response type is returned.</p> PARAMETER DESCRIPTION <code>request</code> <p>The request object containing the CDA document to be processed.</p> <p> TYPE: <code>CdaRequest</code> </p> RETURNS DESCRIPTION <code>CdaResponse</code> <p>The response object containing the processed CDA document.</p> <p> TYPE: <code>CdaResponse</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the service function is not properly configured.</p> <code>TypeError</code> <p>If the output type does not match the expected CdaResponse type.</p> Note <p>This method performs several checks to ensure the integrity of the service: 1. Verifies that the service API is configured. 2. Validates the signature of the service function. 3. Ensures the service function accepts a CdaRequest as its argument. 4. Verifies that the service function returns a CdaResponse.</p> Source code in <code>healthchain/use_cases/clindoc.py</code> <pre><code>def process_notereader_document(self, request: CdaRequest) -&gt; CdaResponse:\n    \"\"\"\n    Process the NoteReader document using the configured service API.\n\n    This method handles the execution of the NoteReader service. It validates the\n    service configuration, checks the input parameters, executes the service\n    function, and ensures the correct response type is returned.\n\n    Args:\n        request (CdaRequest): The request object containing the CDA document to be processed.\n\n    Returns:\n        CdaResponse: The response object containing the processed CDA document.\n\n    Raises:\n        AssertionError: If the service function is not properly configured.\n        TypeError: If the output type does not match the expected CdaResponse type.\n\n    Note:\n        This method performs several checks to ensure the integrity of the service:\n        1. Verifies that the service API is configured.\n        2. Validates the signature of the service function.\n        3. Ensures the service function accepts a CdaRequest as its argument.\n        4. Verifies that the service function returns a CdaResponse.\n    \"\"\"\n    # Check service_api\n    if self._service_api is None:\n        log.warning(\"'service_api' not configured, check class init.\")\n        return CdaResponse(document=\"\")\n\n    # Check service function signature\n    signature = inspect.signature(self._service_api.func)\n    params = list(signature.parameters.values())\n    if len(params) &lt; 2:  # Only 'self' parameter\n        raise AssertionError(\n            \"Service function must have at least one parameter besides 'self'\"\n        )\n    first_param = params[1]  # Skip 'self'\n    if first_param.annotation == inspect.Parameter.empty:\n        log.warning(\n            \"Service function parameter has no type annotation. Expected CdaRequest.\"\n        )\n    elif first_param.annotation != CdaRequest:\n        raise TypeError(\n            f\"Expected first argument of service function to be CdaRequest, but got {first_param.annotation}\"\n        )\n\n    # Call the service function\n    response = self._service_api.func(self, request)\n\n    # Check return type\n    if not isinstance(response, CdaResponse):\n        raise TypeError(\n            f\"Expected return type CdaResponse, got {type(response)} instead.\"\n        )\n\n    return response\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.clindoc.ClinicalDocumentationStrategy","title":"<code>ClinicalDocumentationStrategy</code>","text":"<p>               Bases: <code>BaseStrategy</code></p> <p>Handles the request construction and validation of a NoteReader CDA file</p> Source code in <code>healthchain/use_cases/clindoc.py</code> <pre><code>class ClinicalDocumentationStrategy(BaseStrategy):\n    \"\"\"\n    Handles the request construction and validation of a NoteReader CDA file\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.api_protocol: ApiProtocol = ApiProtocol.soap\n        self.soap_envelope: Dict = self._load_soap_envelope()\n\n    def _load_soap_envelope(self):\n        data = pkgutil.get_data(\"healthchain\", \"templates/soap_envelope.xml\")\n        return xmltodict.parse(data.decode(\"utf-8\"))\n\n    def construct_cda_xml_document(self):\n        \"\"\"\n        This function should wrap FHIR resources from Document into a template CDA file\n        TODO: implement this function\n        \"\"\"\n        raise NotImplementedError(\"This function is not implemented yet.\")\n\n    @validate_workflow(UseCaseMapping.ClinicalDocumentation)\n    def construct_request(\n        self, document_reference: DocumentReference, workflow: Workflow\n    ) -&gt; CdaRequest:\n        \"\"\"\n        Constructs a CDA request for clinical documentation use cases (NoteReader)\n\n        Parameters:\n            document_reference (DocumentReference): FHIR DocumentReference containing CDA XML data\n            workflow (Workflow): The NoteReader workflow type, e.g. notereader-sign-inpatient\n\n        Returns:\n            CdaRequest: A Pydantic model containing the CDA XML wrapped in a SOAP envelope\n\n        Raises:\n            ValueError: If the SOAP envelope template is invalid or missing required keys\n        \"\"\"\n        # TODO: handle different workflows\n        cda_xml = None\n        for content in document_reference.content:\n            if content.attachment.contentType == \"text/xml\":\n                cda_xml = content.attachment.data\n                break\n\n        if cda_xml is not None:\n            # Make a copy of the SOAP envelope template\n            soap_envelope = self.soap_envelope.copy()\n\n            cda_xml = base64.b64encode(cda_xml).decode(\"utf-8\")\n\n            # Insert encoded cda in the Document section\n            if not insert_at_key(soap_envelope, \"urn:Document\", cda_xml):\n                raise ValueError(\n                    \"Key 'urn:Document' missing from SOAP envelope template!\"\n                )\n            request = CdaRequest.from_dict(soap_envelope)\n\n            return request\n        else:\n            log.warning(\"No CDA document found in the DocumentReference!\")\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.clindoc.ClinicalDocumentationStrategy.construct_cda_xml_document","title":"<code>construct_cda_xml_document()</code>","text":"<p>This function should wrap FHIR resources from Document into a template CDA file TODO: implement this function</p> Source code in <code>healthchain/use_cases/clindoc.py</code> <pre><code>def construct_cda_xml_document(self):\n    \"\"\"\n    This function should wrap FHIR resources from Document into a template CDA file\n    TODO: implement this function\n    \"\"\"\n    raise NotImplementedError(\"This function is not implemented yet.\")\n</code></pre>"},{"location":"api/use_cases/#healthchain.use_cases.clindoc.ClinicalDocumentationStrategy.construct_request","title":"<code>construct_request(document_reference, workflow)</code>","text":"<p>Constructs a CDA request for clinical documentation use cases (NoteReader)</p> PARAMETER DESCRIPTION <code>document_reference</code> <p>FHIR DocumentReference containing CDA XML data</p> <p> TYPE: <code>DocumentReference</code> </p> <code>workflow</code> <p>The NoteReader workflow type, e.g. notereader-sign-inpatient</p> <p> TYPE: <code>Workflow</code> </p> RETURNS DESCRIPTION <code>CdaRequest</code> <p>A Pydantic model containing the CDA XML wrapped in a SOAP envelope</p> <p> TYPE: <code>CdaRequest</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the SOAP envelope template is invalid or missing required keys</p> Source code in <code>healthchain/use_cases/clindoc.py</code> <pre><code>@validate_workflow(UseCaseMapping.ClinicalDocumentation)\ndef construct_request(\n    self, document_reference: DocumentReference, workflow: Workflow\n) -&gt; CdaRequest:\n    \"\"\"\n    Constructs a CDA request for clinical documentation use cases (NoteReader)\n\n    Parameters:\n        document_reference (DocumentReference): FHIR DocumentReference containing CDA XML data\n        workflow (Workflow): The NoteReader workflow type, e.g. notereader-sign-inpatient\n\n    Returns:\n        CdaRequest: A Pydantic model containing the CDA XML wrapped in a SOAP envelope\n\n    Raises:\n        ValueError: If the SOAP envelope template is invalid or missing required keys\n    \"\"\"\n    # TODO: handle different workflows\n    cda_xml = None\n    for content in document_reference.content:\n        if content.attachment.contentType == \"text/xml\":\n            cda_xml = content.attachment.data\n            break\n\n    if cda_xml is not None:\n        # Make a copy of the SOAP envelope template\n        soap_envelope = self.soap_envelope.copy()\n\n        cda_xml = base64.b64encode(cda_xml).decode(\"utf-8\")\n\n        # Insert encoded cda in the Document section\n        if not insert_at_key(soap_envelope, \"urn:Document\", cda_xml):\n            raise ValueError(\n                \"Key 'urn:Document' missing from SOAP envelope template!\"\n            )\n        request = CdaRequest.from_dict(soap_envelope)\n\n        return request\n    else:\n        log.warning(\"No CDA document found in the DocumentReference!\")\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdarequest.CdaRequest","title":"<code>CdaRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>class CdaRequest(BaseModel):\n    document: str\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        \"\"\"\n        Loads data from dict (xmltodict format)\n        \"\"\"\n        return cls(document=xmltodict.unparse(data))\n\n    def model_dump(self, *args, **kwargs) -&gt; Dict:\n        \"\"\"\n        Dumps document as dict with xmltodict\n        \"\"\"\n        return xmltodict.parse(self.document)\n\n    def model_dump_xml(self, *args, **kwargs) -&gt; str:\n        \"\"\"\n        Decodes and dumps document as an xml string\n        \"\"\"\n        xml_dict = xmltodict.parse(self.document)\n        document = search_key(xml_dict, \"urn:Document\")\n        if document is None:\n            log.warning(\"Couldn't find document under namespace 'urn:Document\")\n            return \"\"\n\n        cda = base64.b64decode(document).decode(\"UTF-8\")\n\n        return cda\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdarequest.CdaRequest.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Loads data from dict (xmltodict format)</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict):\n    \"\"\"\n    Loads data from dict (xmltodict format)\n    \"\"\"\n    return cls(document=xmltodict.unparse(data))\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdarequest.CdaRequest.model_dump","title":"<code>model_dump(*args, **kwargs)</code>","text":"<p>Dumps document as dict with xmltodict</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>def model_dump(self, *args, **kwargs) -&gt; Dict:\n    \"\"\"\n    Dumps document as dict with xmltodict\n    \"\"\"\n    return xmltodict.parse(self.document)\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.requests.cdarequest.CdaRequest.model_dump_xml","title":"<code>model_dump_xml(*args, **kwargs)</code>","text":"<p>Decodes and dumps document as an xml string</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>def model_dump_xml(self, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Decodes and dumps document as an xml string\n    \"\"\"\n    xml_dict = xmltodict.parse(self.document)\n    document = search_key(xml_dict, \"urn:Document\")\n    if document is None:\n        log.warning(\"Couldn't find document under namespace 'urn:Document\")\n        return \"\"\n\n    cda = base64.b64decode(document).decode(\"UTF-8\")\n\n    return cda\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdaresponse.CdaResponse","title":"<code>CdaResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>class CdaResponse(BaseModel):\n    document: str\n    error: Optional[str] = None\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        \"\"\"\n        Loads data from dict (xmltodict format)\n        \"\"\"\n        return cls(document=xmltodict.unparse(data))\n\n    def model_dump(self, *args, **kwargs) -&gt; Dict:\n        \"\"\"\n        Dumps document as dict with xmltodict\n        \"\"\"\n        return xmltodict.parse(self.document)\n\n    def model_dump_xml(self, *args, **kwargs) -&gt; str:\n        \"\"\"\n        Decodes and dumps document as an xml string\n        \"\"\"\n        xml_dict = xmltodict.parse(self.document)\n        document = search_key(xml_dict, \"tns:Document\")\n        if document is None:\n            log.warning(\"Couldn't find document under namespace 'tns:Document\")\n            return \"\"\n\n        cda = base64.b64decode(document).decode(\"UTF-8\")\n\n        return cda\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdaresponse.CdaResponse.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Loads data from dict (xmltodict format)</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict):\n    \"\"\"\n    Loads data from dict (xmltodict format)\n    \"\"\"\n    return cls(document=xmltodict.unparse(data))\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdaresponse.CdaResponse.model_dump","title":"<code>model_dump(*args, **kwargs)</code>","text":"<p>Dumps document as dict with xmltodict</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>def model_dump(self, *args, **kwargs) -&gt; Dict:\n    \"\"\"\n    Dumps document as dict with xmltodict\n    \"\"\"\n    return xmltodict.parse(self.document)\n</code></pre>"},{"location":"api/use_cases/#healthchain.models.responses.cdaresponse.CdaResponse.model_dump_xml","title":"<code>model_dump_xml(*args, **kwargs)</code>","text":"<p>Decodes and dumps document as an xml string</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>def model_dump_xml(self, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Decodes and dumps document as an xml string\n    \"\"\"\n    xml_dict = xmltodict.parse(self.document)\n    document = search_key(xml_dict, \"tns:Document\")\n    if document is None:\n        log.warning(\"Couldn't find document under namespace 'tns:Document\")\n        return \"\"\n\n    cda = base64.b64decode(document).decode(\"UTF-8\")\n\n    return cda\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"community/","title":"Community","text":""},{"location":"community/#contribute","title":"Contribute","text":"<p>Contributing Guidelines</p>"},{"location":"community/contribution_guide/","title":"Contribution Guide","text":""},{"location":"community/resources/","title":"Resources","text":""},{"location":"cookbook/","title":"Examples","text":"<p>The best way to learn is by example! Here are some to get you started:</p> <ul> <li>Build a CDS sandbox: Build a clinical decision support (CDS) system that uses encounter-discharge to summarize discharge notes.</li> <li>Build a Clinical Documentation sandbox: Build a NoteReader system which extracts problem, medication, and allergy concepts from free-text clinical notes.</li> </ul>"},{"location":"cookbook/cds_sandbox/","title":"Build a CDS sandbox for encounter discharge summarization","text":"<p>This tutorial demonstrates how to build a clinical decision support (CDS) application that summarizes information in encounter discharge notes to streamline operational workflows using the <code>encounter-discharge</code> CDS hook workflow. We will use the <code>SummarizationPipeline</code> for the application and test it using the HealthChain sandbox server.</p> <p>Check out the full working example here!</p>"},{"location":"cookbook/cds_sandbox/#setup","title":"Setup","text":"<p>Make sure you have a Hugging Face API token and set it as the <code>HUGGINGFACEHUB_API_TOKEN</code> environment variable.</p> <pre><code>import getpass\nimport os\n\nif not os.getenv(\"HUGGINGFACEHUB_API_TOKEN\"):\n    os.environ[\"HUGGINGFACEHUB_API_TOKEN\"] = getpass.getpass(\n      \"Enter your token: \"\n    )\n</code></pre> <p>If you are using a chat model, make sure you have the necessary <code>langchain</code> packages installed.</p> <pre><code>pip install langchain langchain-huggingface\n</code></pre>"},{"location":"cookbook/cds_sandbox/#initialize-the-pipeline","title":"Initialize the pipeline","text":"<p>First, we'll initialize our model and pipeline. You can choose between:</p> <ul> <li>A transformer model fine-tuned for summarization (like <code>google/pegasus-xsum</code>)</li> <li>An LLM chat model (like <code>zephyr-7b-beta</code>) with custom prompting</li> </ul> <p>If you are using a chat model, we recommend you initialize the pipeline with the LangChain wrapper to fully utilize the chat interface and prompting functionality.</p> Non-chat modelChat model <pre><code>from healthchain.pipelines import SummarizationPipeline\n\npipeline = SummarizationPipeline.from_model_id(\n  \"google/pegasus-xsum\", source=\"huggingface\", task=\"summarization\"\n  )\n</code></pre> <pre><code>from healthchain.pipelines import SummarizationPipeline\n\nfrom langchain_huggingface.llms import HuggingFaceEndpoint\nfrom langchain_huggingface import ChatHuggingFace\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\n\nhf = HuggingFaceEndpoint(\n    repo_id=\"HuggingFaceH4/zephyr-7b-beta\",\n    task=\"text-generation\",\n    max_new_tokens=512,\n    do_sample=False,\n    repetition_penalty=1.03,\n)\n\nmodel = ChatHuggingFace(llm=hf)\n\ntemplate = \"\"\"\nProvide a concise, objective summary of the input text in\nshort bullet points separated by new lines, focusing on key\nactions such as appointments and medication dispense instructions,\nwithout using second or third person pronouns.\\n'''{text}'''\n\"\"\"\nprompt = PromptTemplate.from_template(template)\n\nchain = prompt | model | StrOutputParser()\n\npipeline = SummarizationPipeline.load(chain, source=\"langchain\")\n</code></pre> <p>Loading your model into <code>SummarizationPipeline</code> will automatically handle the data parsing and text extraction. Now it's ready to use with the sandbox!</p>"},{"location":"cookbook/cds_sandbox/#build-the-sandbox","title":"Build the sandbox","text":"<p>We'll deploy our <code>SummarizationPipeline</code> as a Clinical Decision Support sandbox. We can do this by creating a class that inherits from <code>ClinicalDecisionSupport</code> and decorating it with the <code>@hc.sandbox</code> decorator.</p> <p>We'll also need to implement the service method, which will process the request through our pipeline and return the result. We can define the service method with the <code>@hc.api</code> decorator.</p> <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.models import CDSRequest, CDSResponse\n\n@hc.sandbox\nclass DischargeNoteSummarizer(ClinicalDecisionSupport):\n  def __init__(self):\n    self.pipeline = pipeline\n\n    @hc.api\n    def my_service(self, request: CDSRequest) -&gt; CDSResponse:\n        result = self.pipeline(request)\n        return result\n</code></pre>"},{"location":"cookbook/cds_sandbox/#add-a-data-generator","title":"Add a data generator","text":"<p>Now that we have our service function defined, we'll need to generate some test data for the sandbox to send to our service. We can use the <code>CdsDataGenerator</code> to generate synthetic FHIR data for testing.</p> <p>By default, the generator generates a random single patient with structured FHIR resources. To pass in free-text discharge notes for our <code>SummarizationPipeline</code>, we can set the <code>free_text_path</code> and <code>column_name</code> parameters.</p> <pre><code>from healthchain.data_generators import CdsDataGenerator\n\ndata_generator = CdsDataGenerator()\ndata = data_generator.generate(\n  free_text_path=\"data/discharge_notes.csv\", column_name=\"text\"\n)\nprint(data.model_dump())\n# {\n#    \"prefetch\": {\n#        \"entry\": [\n#        {\n#            \"resource\": {\n#                \"resourceType\": \"Bundle\",\n#                ...\n#            }\n#        }\n#    ]\n# }\n</code></pre> <p>The data generator returns a <code>Prefetch</code> object, which ensures that the data is parsed correctly inside the sandbox.</p>"},{"location":"cookbook/cds_sandbox/#define-client-workflow","title":"Define client workflow","text":"<p>To finish our sandbox, we'll define a client function that loads the data generator into the sandbox. We'll use the <code>@hc.ehr</code> decorator and pass in the CDS hook workflow that we want to use - in this case, <code>encounter-discharge</code>. This will automatically send the generated test data to our service method when a request is made, using the workflow format that we specified.</p> <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.models import CDSRequest, CDSResponse, Prefetch\n\n@hc.sandbox\nclass DischargeNoteSummarizer(ClinicalDecisionSupport):\n  def __init__(self):\n    self.pipeline = pipeline\n    self.data_generator = data_generator\n\n  @hc.api\n  def my_service(self, request: CDSRequest) -&gt; CDSResponse:\n    result = self.pipeline(request)\n    return result\n\n  @hc.ehr(workflow=\"encounter-discharge\")\n  def load_data_in_client(self) -&gt; Prefetch:\n    data = self.data_generator.generate_prefetch()\n    return data\n</code></pre>"},{"location":"cookbook/cds_sandbox/#run-the-sandbox","title":"Run the sandbox","text":"<p>Start the sandbox by running the <code>start_sandbox()</code> method on your class instance.</p> <pre><code>summarizer = DischargeNoteSummarizer()\nsummarizer.start_sandbox()\n</code></pre> <p>Then run the sandbox using the HealthChain CLI:</p> <pre><code>healthchain run discharge_summarizer.py\n</code></pre> <p>The sandbox will:</p> <ul> <li>Start a FastAPI server with your service method mounted to CDS endpoints at <code>http://localhost:8000/</code></li> <li>Generate synthetic data and send it to your service method</li> <li>Save the processed request and response to the <code>output/requests</code> and <code>output/responses</code> folders of your current working directory</li> </ul> <p>An example response containing CDS cards might look like this:</p> <pre><code>{\n    \"cards\": [\n        {\n            \"summary\": \"Action Item 1\",\n            \"indicator\": \"info\",\n            \"source\": {\n                \"label\": \"Card Generated by HealthChain\"\n            },\n            \"detail\": \"- Transport arranged for 11:00 HRs, requires bariatric ambulance and 2 crew members (confirmed).\"\n        },\n        {\n            \"summary\": \"Action Item 2\",\n            \"indicator\": \"info\",\n            \"source\": {\n                \"label\": \"Card Generated by HealthChain\"\n            },\n            \"detail\": \"- Medication reconciliation completed, discharge medications prepared (Apixaban 5mg, Baclofen 20mg MR, new anticoagulation card) for collection by daughter\"\n        }\n    ]\n}\n</code></pre>"},{"location":"cookbook/notereader_sandbox/","title":"NoteReader Sandbox","text":"<p>A sandbox example of NoteReader clinical documentation improvement which extracts problems, medications, and allergies entries from the progress note section of a pre-configured CDA document using scispacy with a custom entity linker component.</p> <p>Full example coming soon!</p> <pre><code>import healthchain as hc\n\nfrom healthchain.io import Document\nfrom healthchain.models.requests.cda import CdaRequest, CdaResponse\nfrom healthchain.pipeline.medicalcodingpipeline import MedicalCodingPipeline\nfrom healthchain.use_cases.clindoc import ClinicalDocumentation\nfrom healthchain.fhir import create_document_reference\n\nfrom spacy.tokens import Span\n\nfrom fhir.resources.documentreference import DocumentReference\n\npipeline = MedicalCodingPipeline.from_model_id(\"en_core_sci_sm\", source=\"spacy\")\n\n@pipeline.add_node(position=\"after\", reference=\"SpacyNLP\")\ndef link_entities(doc: Document) -&gt; Document:\n    # Register the extension if it doesn't exist already\n    if not Span.has_extension(\"cui\"):\n        Span.set_extension(\"cui\", default=None)\n    spacy_doc = doc.nlp.get_spacy_doc()\n\n    dummy_linker = {\"fever\": \"C0006477\",\n                    \"cough\": \"C0006477\",\n                    \"cold\": \"C0006477\",\n                    \"flu\": \"C0006477\",\n                    \"headache\": \"C0006477\",\n                    \"sore throat\": \"C0006477\",\n                    }\n\n    for ent in spacy_doc.ents:\n        if ent.text in dummy_linker:\n            ent._.cui = dummy_linker[ent.text]\n\n    doc.update_problem_list_from_nlp()\n\n    return doc\n\n\n@hc.sandbox\nclass NotereaderSandbox(ClinicalDocumentation):\n    def __init__(self):\n        self.pipeline = pipeline\n\n    @hc.ehr(workflow=\"sign-note-inpatient\")\n    def load_data_in_client(self) -&gt; DocumentReference:\n        with open(\"./resources/uclh_cda.xml\", \"r\") as file:\n            xml_string = file.read()\n\n        cda_document_reference = create_document_reference(\n            data=xml_string,\n            content_type=\"text/xml\",\n            description=\"Original CDA Document loaded from my sandbox\",\n        )\n\n        return cda_document_reference\n\n    @hc.api\n    def my_service(self, request: CdaRequest) -&gt; CdaResponse:\n        result = self.pipeline(request)\n\n        return result\n\n\nif __name__ == \"__main__\":\n    clindoc = NotereaderSandbox()\n    clindoc.start_sandbox()\n</code></pre>"},{"location":"reference/","title":"Welcome!","text":""},{"location":"reference/pipeline/data_container/","title":"Data Container","text":"<p>The <code>healthchain.io.containers</code> module provides classes for storing and manipulating data throughout the pipeline. The main classes are <code>DataContainer</code>, <code>Document</code>, and <code>Tabular</code>.</p>"},{"location":"reference/pipeline/data_container/#datacontainer","title":"DataContainer \ud83d\udce6","text":"<p><code>DataContainer</code> is a generic base class for storing data of any type.</p> <pre><code>from healthchain.io.containers import DataContainer\n\n# Create a DataContainer with string data\ncontainer = DataContainer(\"Some data\")\n\n# Convert to dictionary and JSON\ndata_dict = container.to_dict()\ndata_json = container.to_json()\n\n# Create from dictionary or JSON\ncontainer_from_dict = DataContainer.from_dict(data_dict)\ncontainer_from_json = DataContainer.from_json(data_json)\n</code></pre>"},{"location":"reference/pipeline/data_container/#document","title":"Document \ud83d\udcc4","text":"<p>The <code>Document</code> class provides comprehensive functionality for working with text, NLP annotations, FHIR resources, and more.</p> Attribute Access Primary Purpose Key Features Common Use Cases FHIR Data <code>doc.fhir</code> Manage clinical data in FHIR format \u2022 Resource bundles\u2022 Clinical lists (problems, meds, allergies)\u2022 Document references\u2022 CDS prefetch \u2022 Store patient records\u2022 Track medical history\u2022 Manage clinical documents NLP <code>doc.nlp</code> Process and analyze text \u2022 Tokenization\u2022 Entity recognition\u2022 Embeddings\u2022 spaCy integration \u2022 Extract medical terms\u2022 Analyze clinical text\u2022 Generate features CDS <code>doc.cds</code> Clinical decision support \u2022 Recommendation cards\u2022 Suggested actions\u2022 Clinical alerts \u2022 Generate alerts\u2022 Suggest interventions\u2022 Guide clinical decisions Model Outputs <code>doc.models</code> Store ML model results \u2022 Multi-framework support\u2022 Task-specific outputs\u2022 Text generation \u2022 Store classifications\u2022 Keep predictions\u2022 Track generations"},{"location":"reference/pipeline/data_container/#fhir-data-docfhir","title":"FHIR Data (<code>doc.fhir</code>)","text":"<p>The FHIR component serves as a comprehensive manager for FHIR resources, providing:</p> <p>Storage and Management:</p> <ul> <li>Automatic <code>Bundle</code> creation and management</li> <li>Resource type validation</li> <li>Convenient access to common clinical data lists</li> </ul> <p>Clinical Data Lists:</p> <ul> <li><code>problem_list</code>: List of <code>Condition</code> resources (diagnoses, problems)</li> <li><code>medication_list</code>: List of <code>MedicationStatement</code> resources</li> <li><code>allergy_list</code>: List of <code>AllergyIntolerance</code> resources</li> </ul> <p>Document Reference Management:</p> <ul> <li>Document relationship tracking (parent/child/sibling)</li> <li>Attachment handling with <code>base64</code> encoding</li> <li>Document family retrieval</li> </ul> <p>CDS Support:</p> <ul> <li>Support for CDS Hooks prefetch resources</li> <li>Resource indexing by type</li> </ul> <p>Example usage:</p> <pre><code>from healthchain.io import Document\nfrom healthchain.fhir import (\n    create_condition,\n    create_medication_statement,\n    create_document_reference,\n)\n\n# Basic usage with clinical lists\ndoc = Document(\"Patient presents with hypertension\")\n\n# Add problems to the problem list\ndoc.fhir.problem_list = [\n    create_condition(subject=\"Patient/123\", code=\"38341003\", display=\"Hypertension\")\n]\n\n# Add medications\ndoc.fhir.medication_list = [\n    create_medication_statement(\n        subject=\"Patient/123\", code=\"1049221\", display=\"Acetaminophen\"\n    )\n]\n\n# Working with document references\nparent_doc = create_document_reference(\n    data=\"Original clinical note\", content_type=\"text/plain\"\n)\nparent_id = doc.fhir.add_document_reference(parent_doc)\n\n# Add a child document with relationship\nchild_doc = create_document_reference(\n    data=\"Updated clinical note\", content_type=\"text/plain\"\n)\nchild_id = doc.fhir.add_document_reference(\n    child_doc, parent_id=parent_id, relationship_type=\"replaces\"\n)\n\n# Get document family (parents/children/siblings)\nfamily = doc.fhir.get_document_reference_family(child_id)\nprint(f\"Parent doc: {family['parents'][0].description}\")\n\n# Using CDS prefetch resources\nprefetch = {\n    \"Condition\": doc.fhir.problem_list,\n    \"MedicationStatement\": doc.fhir.medication_list,\n}\ndoc.fhir.prefetch_resources = prefetch\nconditions = doc.fhir.get_prefetch_resources(\"Condition\")\n</code></pre> <p>Technical Notes:</p> <ul> <li>All FHIR resources are validated using fhir.resources</li> <li>Document relationships follow the FHIR DocumentReference.relatesTo standard</li> </ul> <p>Resource Documentation:</p> <ul> <li>FHIR Bundle</li> <li>FHIR DocumentReference</li> <li>FHIR Condition</li> <li>FHIR MedicationStatement</li> <li>FHIR AllergyIntolerance</li> </ul>"},{"location":"reference/pipeline/data_container/#nlp-component-docnlp","title":"NLP Component (<code>doc.nlp</code>)","text":"<ul> <li><code>get_tokens()</code>: Returns list of tokens from the text</li> <li><code>get_entities()</code>: Returns named entities with optional CUI (SNOMED CT concept IDs)</li> <li><code>get_embeddings()</code>: Returns vector representations of text</li> <li><code>get_spacy_doc()</code>: Returns the underlying spaCy document for advanced NLP features</li> <li><code>word_count()</code>: Returns total word count based on tokenization</li> </ul>"},{"location":"reference/pipeline/data_container/#clinical-decision-support-doccds","title":"Clinical Decision Support (<code>doc.cds</code>)","text":"<ul> <li><code>cards</code>: List of Card objects with clinical recommendations</li> <li><code>actions</code>: List of Action objects for suggested interventions</li> </ul>"},{"location":"reference/pipeline/data_container/#model-outputs-docmodels","title":"Model Outputs (<code>doc.models</code>)","text":"<ul> <li><code>get_output(model_name, task)</code>: Get specific model output</li> <li><code>get_generated_text(model_name, task)</code>: Get generated text</li> <li>Supports outputs from various models (e.g., Hugging Face, LangChain)</li> </ul> <p>Example using all components: <pre><code>from healthchain.io import Document\nfrom healthchain.fhir import create_condition\nfrom healthchain.models import Card, Action\n\n# Create document with text\ndoc = Document(\"Patient reports chest pain and shortness of breath.\")\n\n# Access and update NLP features\nprint(f\"Word count: {doc.word_count()}\")\ntokens = doc.nlp.get_tokens()\nspacy_doc = doc.nlp.get_spacy_doc()\n\n# Add FHIR resources\ndoc.fhir.problem_list.append(\n    create_condition(subject=\"Patient/123\", code=\"29857009\", display=\"Chest pain\")\n)\n\n# Update problem list from NLP entities (requires spaCy doc with CUI extension)\ndoc.update_problem_list_from_nlp()\n\n# Add CDS results\ndoc.cds.cards = [\n    Card(\n        summary=\"Consider cardiac evaluation\",\n        indicator=\"warning\",\n        source={\"label\": \"AHA Guidelines\"},\n    )\n]\ndoc.cds.actions = [Action(...)]\n\n# Get model outputs\nclassification = doc.models.get_output(\"huggingface\", \"classification\")\n</code></pre></p> <p>Document API Reference</p>"},{"location":"reference/pipeline/data_container/#tabular","title":"Tabular \ud83d\udcca","text":"<p>The <code>Tabular</code> class is used for storing and manipulating tabular data, wrapping a pandas DataFrame.</p> <pre><code>import pandas as pd\nfrom healthchain.io.containers import Tabular\n\n# Create a Tabular object from a DataFrame\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': ['a', 'b', 'c']})\ntabular = Tabular(df)\n\n# Access basic information\nprint(f\"Columns: {tabular.columns}\")\nprint(f\"Row count: {tabular.row_count()}\")\nprint(f\"Column count: {tabular.column_count()}\")\nprint(f\"Data types: {tabular.dtypes}\")\n\n# Describe the tabular data\nprint(tabular.describe())\n\n# Remove a column\ntabular.remove_column('A')\n\n# Save to CSV\ntabular.to_csv('output.csv')\n\n# Create from CSV\ntabular_from_csv = Tabular.from_csv('input.csv')\n</code></pre> <p>These classes provide a consistent interface for working with different types of data in the healthchain pipeline.</p>"},{"location":"reference/pipeline/pipeline/","title":"Pipeline","text":"<p>HealthChain pipelines provide a simple interface to test, version, and connect your pipeline to common healthcare data standards, such as CDA (Clinical Document Architecture) and FHIR (Fast Healthcare Interoperability Resources).</p> <p>Depending on your need, you can either go top down, where you use prebuilt pipelines and customize them to your needs, or bottom up, where you build your own pipeline from scratch.</p>"},{"location":"reference/pipeline/pipeline/#prebuilt","title":"Prebuilt \ud83d\udce6","text":"<p>HealthChain comes with a set of prebuilt pipelines that are out-of-the-box implementations of common healthcare data processing tasks:</p> Pipeline Container Compatible Connector Description Example Use Case MedicalCodingPipeline <code>Document</code> <code>CdaConnector</code> An NLP pipeline that processes free-text clinical notes into structured data Automatically generating SNOMED CT codes from clinical notes SummarizationPipeline <code>Document</code> <code>CdsFhirConnector</code> An NLP pipeline for summarizing clinical notes Generating discharge summaries from patient history and notes QAPipeline [TODO] <code>Document</code> N/A A Question Answering pipeline suitable for conversational AI applications Developing a chatbot to answer patient queries about their medical records ClassificationPipeline [TODO] <code>Tabular</code> <code>CdsFhirConnector</code> A pipeline for machine learning classification tasks Predicting patient readmission risk based on historical health data <p>Prebuilt pipelines are end-to-end workflows with Connectors built into them. They interact with raw data received from EHR interfaces, usually CDA or FHIR data from specific use cases.</p> <p>You can load your models directly as a pipeline object, from local files or from a remote model repository such as Hugging Face.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.models import CdaRequest\n\n#\u00a0Load from Hugging Face\npipeline = MedicalCodingPipeline.from_model_id(\n    'gpt2', source=\"huggingface\"\n)\n# Load from local model files\npipeline = MedicalCodingPipeline.from_local_model(\n    '/path/to/model', source=\"spacy\"\n)\n# Load from a pipeline object\npipeline = MedicalCodingPipeline.load(pipeline_object)\n\ncda_request = CdaRequest(document=\"&lt;Clinical Document&gt;\")\ncda_response = pipeline(cda_request)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#customizing-prebuilt-pipelines","title":"Customizing Prebuilt Pipelines","text":"<p>To customize a prebuilt pipeline, you can use the pipeline management methods to add, remove, and replace components. For example, you may want to change the model being used. [TODO]</p> <p>If you need more control and don't mind writing more code, you can subclass <code>BasePipeline</code> and implement your own pipeline logic.</p> <p>(BasePipeline API Reference)</p>"},{"location":"reference/pipeline/pipeline/#integrations","title":"Integrations","text":"<p>HealthChain offers powerful integrations with popular NLP libraries, enhancing its capabilities and allowing you to build more sophisticated pipelines. These integrations include components for spaCy, Hugging Face Transformers, and LangChain, enabling you to leverage state-of-the-art NLP models and techniques within your HealthChain workflows.</p> <p>Integrations are covered in detail on the Integrations homepage.</p>"},{"location":"reference/pipeline/pipeline/#freestyle","title":"Freestyle \ud83d\udd7a","text":"<p>To build your own pipeline, you can start with an empty pipeline and add components to it. Initialize your pipeline with the appropriate container type, such as <code>Document</code> or <code>Tabular</code>. This is not essential, but it allows the pipeline to enforce type safety (If you don't specify the container type, it will be inferred from the first component added.)</p> <p>You can see the full list of available containers at the Container page.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io.containers import Document\n\npipeline = Pipeline[Document]()\n\n# Or if you live dangerously\n# pipeline = Pipeline()\n</code></pre> <p>To use a built pipeline, compile it by running <code>.build()</code>. This will return a compiled pipeline that you can run on your data.</p> <pre><code>pipe = pipeline.build()\ndoc = pipe(Document(\"Patient is diagnosed with diabetes\"))\n\nprint(doc.entities)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#adding-nodes","title":"Adding Nodes","text":"<p>There are three types of nodes you can add to your pipeline with the method <code>.add_node()</code>:</p> <ul> <li>Inline Functions</li> <li>Components</li> <li>Custom Components</li> </ul>"},{"location":"reference/pipeline/pipeline/#inline-functions","title":"Inline Functions","text":"<p>Inline functions are simple functions that take in a container and return a container.</p> <pre><code>@pipeline.add_node\ndef remove_stopwords(doc: Document) -&gt; Document:\n    stopwords = {\"the\", \"a\", \"an\", \"in\", \"on\", \"at\"}\n    doc.tokens = [token for token in doc.tokens if token not in stopwords]\n    return doc\n\n# Equivalent to:\npipeline.add_node(remove_stopwords)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#components","title":"Components","text":"<p>Components are pre-configured building blocks that perform specific tasks. They are defined as separate classes and can be reused across multiple pipelines.</p> <p>You can see the full list of available components at the Components page.</p> <pre><code>from healthchain.pipeline import TextPreProcessor\n\npreprocessor = TextPreProcessor(tokenizer=\"spacy\", lowercase=True)\npipeline.add_node(preprocessor)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#custom-components","title":"Custom Components","text":"<p>Custom components are classes that implement the <code>BaseComponent</code> interface. You can use them to add custom processing logic to your pipeline.</p> <pre><code>from healthchain.pipeline import BaseComponent\n\nclass RemoveStopwords(BaseComponent):\n    def __init__(self, stopwords: List[str]):\n        super().__init__()\n        self.stopwords = stopwords\n\n    def __call__(self, doc: Document) -&gt; Document:\n        doc.tokens = [token for token in doc.tokens if token not in self.stopwords]\n        return doc\n\nstopwords = [\"the\", \"a\", \"an\", \"in\", \"on\", \"at\"]\npipeline.add_node(RemoveStopwords(stopwords))\n</code></pre> <p>(BaseComponent API Reference)</p>"},{"location":"reference/pipeline/pipeline/#adding-connectors","title":"Adding Connectors \ud83d\udd17","text":"<p>Connectors are added to the pipeline using the <code>.add_input()</code> and <code>.add_output()</code> methods. You can learn more about connectors at the Connectors documentation page.</p> <pre><code>from healthchain.io import CdaConnector\n\ncda_connector = CdaConnector()\n\npipeline.add_input(cda_connector)\npipeline.add_output(cda_connector)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#pipeline-management","title":"Pipeline Management \ud83d\udd28","text":""},{"location":"reference/pipeline/pipeline/#adding","title":"Adding","text":"<p>Use <code>.add_node()</code> to add a component to the pipeline. By default, the component will be added to the end of the pipeline and named as the function name provided.</p> <p>You can specify the position of the component using the <code>position</code> parameter. Available positions are:</p> <ul> <li><code>\"first\"</code></li> <li><code>\"last\"</code></li> <li><code>\"default\"</code></li> <li><code>\"after\"</code></li> <li><code>\"before\"</code></li> </ul> <p>When using <code>\"after\"</code> or <code>\"before\"</code>, you must also specify the <code>reference</code> parameter with the name of the node you want to add the component after or before.</p> <p>You can also specify the <code>stage</code> parameter to add the component to a specific stage group of the pipeline.</p> <pre><code>@pipeline.add_node(position=\"after\", reference=\"tokenize\", stage=\"preprocessing\")\ndef remove_stopwords(doc: Document) -&gt; Document:\n    stopwords = {\"the\", \"a\", \"an\", \"in\", \"on\", \"at\"}\n    doc.tokens = [token for token in doc.tokens if token not in stopwords]\n    return doc\n</code></pre> <p>You can specify dependencies between components using the <code>dependencies</code> parameter. This is useful if you want to ensure that a component is run after another component.</p> <pre><code>@pipeline.add_node(dependencies=[\"tokenize\"])\ndef remove_stopwords(doc: Document) -&gt; Document:\n    stopwords = {\"the\", \"a\", \"an\", \"in\", \"on\", \"at\"}\n    doc.tokens = [token for token in doc.tokens if token not in stopwords]\n    return doc\n</code></pre>"},{"location":"reference/pipeline/pipeline/#removing","title":"Removing","text":"<p>Use <code>.remove()</code> to remove a component from the pipeline.</p> <pre><code>pipeline.remove(\"remove_stopwords\")\n</code></pre>"},{"location":"reference/pipeline/pipeline/#replacing","title":"Replacing","text":"<p>Use <code>.replace()</code> to replace a component in the pipeline.</p> <pre><code>def remove_names(doc: Document) -&gt; Document:\n    doc.entities = [token for token in doc.entities if token[0].isupper() and len(token) &gt; 1]\n    return doc\n\npipeline.replace(\"remove_stopwords\", remove_names)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#inspecting-the-pipeline","title":"Inspecting the Pipeline","text":"<pre><code>print(pipeline)\nprint(pipeline.stages)\n\n# [\"TextPreprocessor\", \"Model\", \"TextPostProcessor\"]\n# preprocessing:\n#   - TextPreprocessor\n# ner+l:\n#   - Model\n# postprocessing:\n#   - TextPostProcessor\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/","title":"CdsCardCreator","text":"<p>More detailed documentation coming soon!</p> <p>The <code>CdsCardCreator</code> is a pipeline component that creates CDS Hooks cards from either model outputs or static content. These cards can be displayed in Electronic Health Record (EHR) systems as part of clinical decision support workflows.</p>"},{"location":"reference/pipeline/components/cdscardcreator/#overview","title":"Overview","text":"<p>The component takes text input and formats it into standardized CDS Hooks cards using <code>Jinja2</code> templates. It can create cards from:</p> <ol> <li>Model-generated text stored in a document's model outputs container</li> <li>Static content provided during initialization</li> </ol>"},{"location":"reference/pipeline/components/cdscardcreator/#usage","title":"Usage","text":""},{"location":"reference/pipeline/components/cdscardcreator/#basic-usage-with-model-output","title":"Basic Usage with Model Output","text":"<pre><code>from healthchain.pipeline.components import CdsCardCreator\n\n# Create cards from model output\ncreator = CdsCardCreator(source=\"huggingface\", task=\"summarization\")\ndoc = creator(doc)  # Creates cards from model output\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#using-static-content","title":"Using Static Content","text":"<pre><code># Create cards with static content\ncreator = CdsCardCreator(static_content=\"Static card message\")\ndoc = creator(doc)  # Creates card with static content\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#custom-template","title":"Custom Template","text":"<pre><code># Create cards with custom template\ntemplate = '''\n{\n    \"summary\": \"Warning heading!\",\n    \"indicator\": \"warning\",\n    \"source\": {{ default_source | tojson }},\n    \"detail\": \"{{ model_output }}\"\n}\n'''\n\ncreator = CdsCardCreator(\n    template=template,\n    source=\"langchain\",\n    task=\"chat\",\n    delimiter=\"\\n\"\n)\ndoc = creator(doc)  # Creates cards split by newlines\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#configuration-options","title":"Configuration Options","text":"Parameter Type Description <code>template</code> <code>str</code> Optional Jinja2 template string for card creation <code>template_path</code> <code>str</code> or <code>Path</code> Optional path to a Jinja2 template file <code>static_content</code> <code>str</code> Optional static text to use instead of model output <code>source</code> <code>str</code> Source framework to get model output from (e.g. \"huggingface\") <code>task</code> <code>str</code> Task name to get model output from (e.g. \"summarization\") <code>delimiter</code> <code>str</code> Optional string to split model output into multiple cards <code>default_source</code> <code>Dict[str, Any]</code> Default source info for cards. Defaults to <code>{\"label\": \"Card Generated by HealthChain\"}</code>"},{"location":"reference/pipeline/components/cdscardcreator/#card-template-format","title":"Card Template Format","text":"<p>The default template creates an info card with the following structure:</p> <pre><code>{\n    \"summary\": \"{{ model_output[:140] }}\",\n    \"indicator\": \"info\",\n    \"source\": {{ default_source | tojson }},\n    \"detail\": \"{{ model_output }}\"\n}\n</code></pre> <p>Available template variables: - <code>model_output</code>: The text content to display in the card - <code>default_source</code>: Source information dictionary</p>"},{"location":"reference/pipeline/components/cdscardcreator/#card-properties","title":"Card Properties","text":"<p>The created cards have the following properties:</p> <ul> <li><code>summary</code>: Brief description (max 140 characters)</li> <li><code>indicator</code>: Card urgency level (\"info\", \"warning\", \"critical\")</li> <li><code>source</code>: Source information object</li> <li><code>detail</code>: Full text content</li> <li><code>suggestions</code>: Optional suggested actions</li> <li><code>selectionBehavior</code>: Optional selection behavior</li> <li><code>overrideReasons</code>: Optional override reasons</li> <li><code>links</code>: Optional external links</li> </ul>"},{"location":"reference/pipeline/components/cdscardcreator/#error-handling","title":"Error Handling","text":"<p>The component includes error handling for:</p> <ul> <li>Invalid template files</li> <li>Template rendering errors</li> <li>JSON parsing errors</li> <li>Missing model output</li> </ul> <p>Errors are logged using the standard Python logging module.</p>"},{"location":"reference/pipeline/components/cdscardcreator/#integration-with-pipeline","title":"Integration with Pipeline","text":"<p>The CdsCardCreator can be used as part of a larger pipeline:</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import CdsCardCreator\n\npipeline = Pipeline()\npipeline.add_component(CdsCardCreator(\n    source=\"huggingface\",\n    task=\"summarization\",\n    template_path=\"path/to/template.json\",\n    delimiter=\"\\n\"\n))\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#related-documentation","title":"Related Documentation","text":"<ul> <li>CDS Hooks Specification</li> <li>Clinical Decision Support Documentation</li> </ul>"},{"location":"reference/pipeline/components/components/","title":"Component","text":"<p>Components are the building blocks of the healthchain pipeline. They are designed to process data in a consistent manner, allowing for easy composition and reusability.</p>"},{"location":"reference/pipeline/components/components/#available-components","title":"Available Components","text":"Component Description Methods <code>TextPreprocessor</code> Handles text preprocessing tasks <code>tokenizer</code>: Specifies the tokenization method (e.g., <code>\"basic\"</code> or <code>\"spacy\"</code>)  <code>lowercase</code>: Converts text to lowercase if <code>True</code> <code>remove_punctuation</code>: Removes punctuation if <code>True</code> <code>standardize_spaces</code>: Standardizes spaces if <code>True</code> <code>regex</code>: List of custom regex patterns and replacements <code>LLM</code> Wraps local LLMs for use in the pipeline [TODO] <code>load_model</code>: Loads the specified model <code>TextPostProcessor</code> Handles text postprocessing tasks <code>postcoordination_lookup</code>: Dictionary for entity refinement lookups <code>CdsCardCreator</code> Formats model outputs into CDS cards for clinical decision support <code>create_card</code>: Creates a CDS card"},{"location":"reference/pipeline/components/components/#creating-custom-components","title":"Creating Custom Components","text":"<p>You can create your own custom components by extending the <code>BaseComponent</code> class and implementing the <code>__call__</code> method.</p> <pre><code>from healthchain.pipeline.base import BaseComponent\n\nclass MyCustomComponent(BaseComponent):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def __call__(self, data):\n        # Your custom processing logic here\n        return data\n</code></pre>"},{"location":"reference/pipeline/connectors/cdaconnector/","title":"CDA Connector","text":"<p>The <code>CdaConnector</code> parses CDA documents, extracting free-text notes and relevant structured clinical data into FHIR resources in the <code>Document</code> container, and returns an annotated CDA document as output. It will also extract the text from the note section of the document and store it in the <code>Document.text</code> attribute.</p> <p>This connector is particularly useful for clinical documentation improvement (CDI) workflows where a document needs to be processed and updated with additional structured data.</p> <p>(Full Documentation on Clinical Documentation)</p> <p>(Full Documentation on CDA Parser)</p>"},{"location":"reference/pipeline/connectors/cdaconnector/#input-and-output","title":"Input and Output","text":"Input Output Access CdaRequest CdaResponse <code>Document.fhir.problem_list</code>, <code>Document.fhir.medication_list</code>, <code>Document.fhir.allergy_list</code>, <code>Document.text</code>"},{"location":"reference/pipeline/connectors/cdaconnector/#usage","title":"Usage","text":"<pre><code>from healthchain.io import CdaConnector, Document\nfrom healthchain.models import CdaRequest\nfrom healthchain.pipeline import Pipeline\n\n# Create a pipeline with CdaConnector\npipeline = Pipeline()\n\ncda_connector = CdaConnector()\npipeline.add_input(cda_connector)\npipeline.add_output(cda_connector)\n\n# Example CDA request\ncda_request = CdaRequest(document=\"&lt;CDA&gt;test&lt;/CDA&gt;\")\n\n# Accessing CDA data inside a pipeline node\n@pipeline.add_node\ndef example_pipeline_node(document: Document) -&gt; Document:\n    print(document.fhir.problem_list)\n    print(document.text)\n    return document\n\n# Pipeline execution\npipe = pipeline.build()\ncda_response = pipe(cda_request)\nprint(cda_response)\n# Output: CdaResponse(document='&lt;Annotated CDA XML content&gt;')\n</code></pre>"},{"location":"reference/pipeline/connectors/cdaconnector/#accessing-data-inside-your-pipeline","title":"Accessing data inside your pipeline","text":"<p>Data parsed from the CDA document is converted into FHIR resources and stored in the <code>Document.fhir.bundle</code> attribute. The connector currently supports the following CDA section to FHIR resource mappings:</p> CDA section FHIR resource Document.fhir attribute Problem List Condition <code>Document.fhir.problem_list</code> Medication List MedicationStatement <code>Document.fhir.medication_list</code> Allergy List AllergyIntolerance <code>Document.fhir.allergy_list</code> Note DocumentReference <code>Document.fhir.bundle</code> (use <code>get_resources(\"DocumentReference\")</code> to access)"},{"location":"reference/pipeline/connectors/cdaconnector/#configuration","title":"Configuration","text":"<p>The <code>overwrite</code> parameter in the <code>CdaConnector</code> constructor determines whether existing data in the document should be overwritten. This can be useful for readability with very long CDA documents when the receiving system does not require the full document.</p> <pre><code>cda_connector = CdaConnector(overwrite=True)\n</code></pre>"},{"location":"reference/pipeline/connectors/cdsfhirconnector/","title":"CDS FHIR Connector","text":"<p>The <code>CdsFhirConnector</code> handles FHIR data in the context of Clinical Decision Support (CDS) services, specifically using the CDS Hooks specification.</p> <p>(Full Documentation on Clinical Decision Support)</p>"},{"location":"reference/pipeline/connectors/cdsfhirconnector/#input-and-output","title":"Input and Output","text":"Input Output Access CDSRequest CDSResponse <code>Document.fhir.prefetch_resources</code>"},{"location":"reference/pipeline/connectors/cdsfhirconnector/#usage","title":"Usage","text":"<pre><code>from healthchain.io import CdsFhirConnector, Document\nfrom healthchain.models import CDSRequest\nfrom healthchain.pipeline import Pipeline\n\n# Create a pipeline with CdsFhirConnector\npipeline = Pipeline()\n\ncds_fhir_connector = CdsFhirConnector(hook_name=\"patient-view\")\npipeline.add_input(cds_fhir_connector)\npipeline.add_output(cds_fhir_connector)\n\n# Example CDS request\ncds_request = CDSRequest(\n    hook=\"patient-view\",\n    hookInstance=\"d1577c69-dfbe-44ad-ba6d-3e05e953b2ea\",\n    context={\n        \"userId\": \"Practitioner/123\",\n        \"patientId\": \"Patient/456\"\n    },\n    prefetch={\n        \"patient\": {\n            \"resourceType\": \"Patient\",\n            \"id\": \"456\",\n            \"name\": [{\"family\": \"Doe\", \"given\": [\"John\"]}],\n            \"birthDate\": \"1970-01-01\"\n        }\n    }\n)\n\n# Accessing FHIR data inside a pipeline node\n@pipeline.add_node\ndef example_pipeline_node(document: Document) -&gt; Document:\n    print(document.fhir.get_prefetch_resources(\"patient\"))\n    return document\n\n# Execute the pipeline\npipe = pipeline.build()\ncds_response = pipe(cds_request)\n# Output: CdsResponse with cards...\n</code></pre>"},{"location":"reference/pipeline/connectors/cdsfhirconnector/#accessing-data-inside-your-pipeline","title":"Accessing data inside your pipeline","text":"<p>Data parsed from the CDS request is stored in the <code>Document.fhir.prefetch_resources</code> attribute as a dictionary of FHIR resources corresponding to the keys in the <code>prefetch</code> field of the <code>CDSRequest</code>. For more information on the <code>prefetch</code> field, check out the CDS Hooks specification on providing FHIR resources to a CDS service.</p>"},{"location":"reference/pipeline/connectors/cdsfhirconnector/#example-prefetch","title":"Example Prefetch","text":"<pre><code>{\n    \"patient\": {\n        \"resourceType\": \"Patient\",\n        \"id\": \"123\",\n        \"name\": [{\"family\": \"Doe\", \"given\": [\"John\"]}],\n        \"birthDate\": \"1970-01-01\"\n    },\n    \"condition\": // Condition FHIR resource...\n    \"document\": // DocumentReference FHIR resource...\n}\n</code></pre>"},{"location":"reference/pipeline/connectors/connectors/","title":"Connectors","text":"<p>Connectors transform your data into a format that can be understood by healthcare systems such as EHRs. They allow your pipelines to work directly with data in HL7 interoperability standard formats, such as CDA or FHIR, without the headache of parsing and validating the data yourself.</p> <p>Connectors are what give you the power to build end-to-end pipelines that interact with real-time healthcare systems.</p>"},{"location":"reference/pipeline/connectors/connectors/#available-connectors","title":"Available connectors","text":"<p>Connectors parse data from a specific format into FHIR resources and store them in a <code>Document</code> container.</p> <p>(Document API Reference)</p> <p>Some connectors require the same instance to be used for both input and output as they respond to a synchronous call, while others may be input or output only.</p> Connector FHIR Resources Access Same instance I/O? CdaConnector DocumentReference <code>Document.text</code>, <code>Document.fhir.problem_list</code>, <code>Document.fhir.medication_list</code>, <code>Document.fhir.allergy_list</code> \u2705 CdsFhirConnector Any FHIR Resource <code>Document.fhir.get_prefetch_resources()</code> \u2705"},{"location":"reference/pipeline/connectors/connectors/#use-cases","title":"Use Cases","text":"<p>Each connector can be mapped to a specific use case in the sandbox module.</p> Connector Use Case <code>CdaConnector</code> Clinical Documentation <code>CdsFhirConnector</code> Clinical Decision Support"},{"location":"reference/pipeline/connectors/connectors/#adding-connectors-to-your-pipeline","title":"Adding connectors to your pipeline","text":"<p>To add connectors to your pipeline, use the <code>.add_input()</code> and <code>.add_output()</code> methods.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io import CdaConnector\n\npipeline = Pipeline()\n# In this example, we're using the same connector instance for input and output\ncda_connector = CdaConnector()\n\npipeline.add_input(cda_connector)\npipeline.add_output(cda_connector)\n</code></pre> <p>Connectors are currently intended for development and testing purposes only. They are not production-ready, although this is something we are working towards on our long-term roadmap. If there is a specific connector you would like to see, please feel free to open an issue or contact us!</p>"},{"location":"reference/pipeline/integrations/integrations/","title":"HealthChain Integrations","text":"<p>This document provides an overview of the integration components available in the HealthChain package. These components allow you to easily incorporate popular NLP libraries into your HealthChain pipelines.</p>"},{"location":"reference/pipeline/integrations/integrations/#table-of-contents","title":"Table of Contents","text":"<ol> <li>SpacyNLP</li> <li>HFTransformer</li> <li>LangChainLLM</li> </ol>"},{"location":"reference/pipeline/integrations/integrations/#installation-requirements","title":"Installation Requirements","text":"<p>Before utilizing the integration components, it is important to note that the required third-party libraries are not included in HealthChain's default installation. This design decision was made to:</p> <ul> <li>Maintain a lean and flexible core package</li> <li>Allow users to selectively install only the necessary dependencies</li> <li>Avoid potential version conflicts with other packages in your environment</li> </ul> <p>To use these integrations, you will need to manually install the corresponding libraries using <code>pip</code>.</p> <pre><code>pip install spacy\npython -m spacy download en_core_web_sm  # or another desired model\npip install transformers\npip install langchain\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#spacynlp","title":"SpacyNLP","text":"<p>The <code>SpacyNLP</code> component allows you to integrate spaCy models into your HealthChain pipeline. There are two ways to initialize this component:</p> <ol> <li> <p>Using a pre-configured spaCy <code>Language</code> object:    <pre><code>import spacy\nfrom healthchain.pipeline.components.integrations import SpacyNLP\n\nnlp = spacy.load(\"en_core_web_sm\")\nspacy_component = SpacyNLP(nlp)\n</code></pre></p> </li> <li> <p>Using the factory method with a model identifier or path to a custom local model:    <pre><code>from healthchain.pipeline.components.integrations import SpacyNLP\n\n# Using a standard spaCy model\nspacy_component = SpacyNLP.from_model_id(\n   \"en_core_web_sm\",\n   disable=[\"parser\"]  # kwargs passed to spacy.load()\n)\n\n# Using a custom local model\nspacy_component = SpacyNLP.from_model_id(\"/path/to/your/model\")\n</code></pre></p> </li> </ol> <p>Choose the appropriate model based on your specific needs - standard models for general text, custom-trained models for domain-specific tasks, or specialized models like scispaCy for biomedical text analysis.</p> <pre><code># Using scispaCy models for biomedical text (requires: pip install scispacy)\nspacy_component = SpacyNLP.from_model_id(\"en_core_sci_sm\")\n</code></pre> <p>The component will process documents using spaCy and store the spaCy Doc object in the document's <code>nlp</code> annotations. It can be accessed using the <code>Document.nlp.get_spacy_doc()</code> method.</p>"},{"location":"reference/pipeline/integrations/integrations/#example","title":"Example","text":"<pre><code>from healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import SpacyNLP\n\npipeline = Pipeline()\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_web_sm\"))\n\ndoc = Document(\"This is a test sentence.\")\nprocessed_doc = pipeline(doc)\n\n# Access spaCy annotations\nspacy_doc = processed_doc.nlp.get_spacy_doc()\nfor token in spacy_doc:\n    print(f\"Token: {token.text}, POS: {token.pos_}, Lemma: {token.lemma_}\")\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#hftransformer","title":"HFTransformer","text":"<p>The <code>HFTransformer</code> integrates HuggingFace <code>transformers</code> models into your HealthChain pipeline. Models can be browsed on the HuggingFace website.</p> <p>HuggingFace offers models for a wide range of different tasks, and while not all of these have been thoroughly tested for HealthChain compatibility, we expect that all NLP models and tasks should be compatible. If you have an issues integrating any models please raise an issue on our Github homepage!</p> <p>There are two ways to initialize this component:</p> <ol> <li> <p>Using a pre-configured HuggingFace pipeline:    <pre><code>from transformers import pipeline, AutoTokenizer, AutoModelForCausalLM\nfrom healthchain.pipeline.components.integrations import HFTransformer\n\nmodel_id = \"gpt2\"\ntokenizer = AutoTokenizer.from_pretrained(model_id)\nmodel = AutoModelForCausalLM.from_pretrained(model_id)\npipe = pipeline(\n   \"text-generation\",\n   model=model,\n   tokenizer=tokenizer,\n   max_new_tokens=10\n)\n\nhuggingface_component = HFTransformer(pipe)\n</code></pre></p> </li> <li> <p>Using the factory method with a model identifier:    <pre><code>from healthchain.pipeline.components.integrations import HFTransformer\n\nhuggingface_component = HFTransformer.from_model_id(\n    model=\"facebook/bart-large-cnn\",\n    task=\"summarization\",\n    max_length=130,  # kwargs passed to pipeline()\n    min_length=30,\n    do_sample=False\n)\n</code></pre></p> </li> </ol> <p>The factory method requires the following arguments:</p> <ul> <li><code>task</code> (str): The NLP task to perform (e.g., \"sentiment-analysis\", \"named-entity-recognition\").</li> <li><code>model</code> (str): The name or path of the Hugging Face model to use.</li> <li><code>**kwargs**</code>: Additional keyword arguments passed to the <code>pipeline()</code> function.</li> </ul> <p>This component applies the specified Hugging Face model to the input document and stores the output in the HealthChain <code>Document.models</code>.</p> <p>It can be accessed using the <code>Document.models.get_output()</code> method with the key <code>\"huggingface\"</code> and the task name.</p>"},{"location":"reference/pipeline/integrations/integrations/#example_1","title":"Example","text":"<pre><code>from healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import HFTransformer\n\npipeline = Pipeline()\npipeline.add_node(HFTransformer.from_model_id(\n   task=\"sentiment-analysis\",\n   model=\"distilbert-base-uncased-finetuned-sst-2-english\"\n   )\n)\n\ndoc = Document(\"I love using HealthChain for my NLP projects!\")\nprocessed_doc = pipeline(doc)\n\n# Access Hugging Face output\nsentiment_result = processed_doc.models.get_output(\n   \"huggingface\", \"sentiment-analysis\"\n)\n\nprint(f\"Sentiment: {sentiment_result}\")\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#langchainllm","title":"LangChainLLM","text":"<p>The <code>LangChainLLM</code> allows you to integrate LangChain chains into your HealthChain pipeline.</p> <pre><code>from langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain.llms import FakeListLLM\n\nfrom healthchain.pipeline.components.integrations import LangChainLLM\n\n# Let's create a simple FakeListLLM for demonstration\nfake_llm = FakeListLLM(responses=[\"This is a great summary!\"])\n\n# Define the prompt template\nprompt = PromptTemplate.from_template(\"Summarize the following text: {text}\")\n\n# Create the LCEL chain\nchain = prompt | fake_llm | StrOutputParser()\n\n# Create the component\nlangchain_component = LangChainLLM(\n    chain=chain,\n    task=\"chat\",\n    temperature=0.7  # Optional kwargs passed to invoke()\n)\n</code></pre> <p>The component requires the following arguments:</p> <ul> <li><code>chain</code>: A LangChain chain object to be executed within the pipeline.</li> <li><code>task</code>: The key to store the output in <code>Document.models</code>.</li> <li><code>**kwargs**</code>: Additional keyword arguments passed to the <code>invoke()</code> method.</li> </ul> <p>This component runs the specified LangChain chain on the input document's text and stores the output in the HealthChain <code>Document.models</code>.</p> <p>It can be accessed using the <code>Document.models.get_output()</code> method with the key <code>\"langchain\"</code> and the task name.</p>"},{"location":"reference/pipeline/integrations/integrations/#example_2","title":"Example","text":"<pre><code>from langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain.llms import FakeListLLM\n\nfrom healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import LangChainLLM\n\n# Set up LangChain with a FakeListLLM\nfake_llm = FakeListLLM(\n    responses=[\"HealthChain integrates NLP libraries for easy pipeline creation.\"]\n)\n# Define the prompt template\nprompt = PromptTemplate.from_template(\"Summarize the following text: {text}\")\n\n# Create the LCEL chain\nchain = prompt | fake_llm | StrOutputParser()\n\n# Set up your HealthChain pipeline\npipeline = Pipeline()\npipeline.add_node(LangChainLLM(chain=chain, task=\"summarization\"))\n\n# Let's summarize something\ndoc = Document(\n    \"HealthChain is a powerful package for building NLP pipelines. It integrates seamlessly with popular libraries like spaCy, Hugging Face Transformers, and LangChain, allowing users to create complex NLP workflows with ease.\"\n)\nprocessed_doc = pipeline(doc)\n\n# What summary did we get?\nsummary = processed_doc.models.get_output(\"langchain\", \"summarization\")\nprint(f\"Summary: {summary}\")\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#combining-components","title":"Combining Components","text":"<p>You can easily combine multiple integration components in a single HealthChain pipeline:</p> <pre><code>from healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import (\n    SpacyNLP,\n    HFTransformer,\n    LangChainLLM,\n)\n\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain.llms import FakeListLLM\n\n# Set up our components\nspacy_component = SpacyNLP.from_model_id(\"en_core_web_sm\")\nhuggingface_component = HFTransformer.from_model_id(\n    model=\"distilbert-base-uncased-finetuned-sst-2-english\",\n    task=\"sentiment-analysis\",\n)\n\n# Set up LangChain with a FakeListLLM\nfake_llm = FakeListLLM(responses=[\"HealthChain: Powerful NLP pipeline builder.\"])\n# Define the prompt template\nprompt = PromptTemplate.from_template(\"Summarize the following text: {text}\")\n# Create the LCEL chain\nchain = prompt | fake_llm | StrOutputParser()\nlangchain_component = LangChainLLM(chain=chain, task=\"summarization\")\n\n# Build our pipeline\npipeline = Pipeline()\npipeline.add_node(spacy_component)\npipeline.add_node(huggingface_component)\npipeline.add_node(langchain_component)\npipeline.build()\n\n# Process a document\ndoc = Document(\"HealthChain makes it easy to build powerful NLP pipelines!\")\nprocessed_doc = pipeline(doc)\n\n# Let's see what we got!\nspacy_doc = processed_doc.nlp.get_spacy_doc()\nsentiment = processed_doc.models.get_output(\"huggingface\", \"sentiment-analysis\")\nsummary = processed_doc.models.get_output(\"langchain\", \"summarization\")\n\nprint(f\"Tokens: {[token.text for token in spacy_doc]}\")\nprint(f\"Sentiment: {sentiment}\")\nprint(f\"Summary: {summary}\")\n</code></pre> <p>This documentation provides an overview of the integration components available in HealthChain. For more detailed information on each library, please refer to their respective documentation:</p> <ul> <li>spaCy Documentation</li> <li>Hugging Face Transformers Documentation</li> <li>LangChain Documentation</li> </ul>"},{"location":"reference/pipeline/prebuilt_pipelines/medicalcoding/","title":"MedicalCodingPipeline","text":"<p>Full documentation coming soon!</p>"},{"location":"reference/pipeline/prebuilt_pipelines/summarization/","title":"SummarizationPipeline","text":"<p>Full documentation coming soon! Check out this cookbook example for now.</p>"},{"location":"reference/sandbox/client/","title":"Client","text":"<p>A client is a healthcare system object that requests information and processing from an external service. This is typically an EHR system, but we may also support other health objects in the future such as a CPOE (Computerized Physician Order Entry).</p> <p>We can mark a client by using the decorator <code>@hc.ehr</code>. You must declare a particular workflow for the EHR client, which informs the sandbox how your data will be formatted. You can find more information on the Use Cases documentation page.</p> <p>Data returned from the client should be wrapped in a Prefetch object, where prefetch is a dictionary of FHIR resources with keys corresponding to the CDS service.</p> <p>You can optionally specify the number of requests to generate with the <code>num</code> parameter.</p> Clinical DocumentationCDS <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDocumentation\nfrom healthchain.fhir import create_document_reference\n\nfrom fhir.resources.documentreference import DocumentReference\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDocumentation):\n    def __init__(self) -&gt; None:\n        pass\n\n    @hc.ehr(workflow=\"sign-note-inpatient\", num=10)\n    def load_data_in_client(self) -&gt; DocumentReference:\n        # Do things here to load in your data\n        return create_document_reference(data=\"\", content_type=\"text/xml\")\n</code></pre> <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.models import Prefetch\n\nfrom fhir.resources.patient import Patient\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDecisionSupport):\n    def __init__(self) -&gt; None:\n        pass\n\n    @hc.ehr(workflow=\"patient-view\", num=10)\n    def load_data_in_client(self) -&gt; Prefetch:\n        # Do things here to load in your data\n        return Prefetch(prefetch={\"patient\": Patient(id=\"123\")})\n</code></pre>"},{"location":"reference/sandbox/sandbox/","title":"Sandbox","text":"<p>Designing your pipeline to integrate well in a healthcare context is an essential step to turning it into an application that could potentially be adapted for real-world use. As a developer who has years of experience deploying healthcare NLP solutions into hospitals, I know how painful and slow this process can be.</p> <p>A sandbox makes this process easier. It provides a staging environment to debug, test, track, and interact with your application in realistic deployment scenarios without having to gain access to such environments, especially ones that are tightly integrated with local EHR configurations. Think of it as integration testing in healthcare systems.</p> <p>For a given sandbox run:</p> <ol> <li> <p>Data is generated or loaded into a client (EHR)</p> </li> <li> <p>Data is wrapped and sent as standardized API requests the designated service</p> </li> <li> <p>Data is processed by the service (you application)</p> </li> <li> <p>Processed result is wrapped and sent back to the service as a standardized API response</p> </li> <li> <p>Data is received by the client which could be rendered in a UI interface</p> </li> </ol> <p>To create a sandbox, initialize a class that inherits from a type of <code>UseCase</code> and decorate it with the <code>@hc.sandbox</code> decorator. <code>UseCase</code> loads in the blueprint of the API endpoints for the specified use case, and <code>@hc.sandbox</code> orchestrates these interactions.</p> <p>Every sandbox also requires a Client function marked by <code>@hc.ehr</code> and a Service function marked by <code>@hc.api</code>. Every client function must specify a workflow that informs the sandbox how your data will be formatted. For more information on workflows, see the Use Cases documentation.</p> <p>For each sandbox you need to specify...</p> <ul> <li>Use case</li> <li>service function</li> <li>client function</li> <li>workflow of client</li> </ul> <pre><code>import healthchain as hc\n\nfrom healthchain.pipeline import SummarizationPipeline\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.data_generators import CdsDataGenerator\nfrom healthchain.models import CDSRequest, Prefetch, CDSResponse\n\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDecisionSupport):\n    def __init__(self):\n        self.data_generator = CdsDataGenerator()\n        self.pipeline = SummarizationPipeline('gpt-4o')\n\n    @hc.ehr(workflow=\"encounter-discharge\")\n    def load_data_in_client(self) -&gt; Prefetch:\n        prefetch = self.data_generator.generate_prefetch()\n        return prefetch\n\n    @hc.api\n    def my_service(self, request: CDSRequest) -&gt; CDSResponse:\n        cds_response = self.pipeline(request)\n        return cds_response\n\nif __name__ == \"__main__\":\n    cds = MyCoolSandbox()\n    cds.start_sandbox()\n</code></pre>"},{"location":"reference/sandbox/service/","title":"Service","text":"<p>A service is typically an API of a third-party system that returns data to the client, the healthcare provider object. This is where you define your application logic.</p> <p>When you decorate a function with <code>@hc.api</code> in a sandbox, the function is mounted standardized API endpoint an EHR client can make requests to. This can be defined by healthcare interoperability standards, such as HL7, or the EHR provider. HealthChain will start a FastAPI server with these APIs pre-defined for you.</p> <p>Your service function receives use case specific request data as input and returns the response data.</p> <p>We recommend you initialize your pipeline in the class <code>__init__</code> method.</p> <p>Here are minimal examples for each use case:</p> Clinical DocumentationCDS <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDocumentation\nfrom healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest, CdaResponse\nfrom healthchain.fhir import create_document_reference\nfrom fhir.resources.documentreference import DocumentReference\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDocumentation):\n    def __init__(self):\n        self.pipeline = MedicalCodingPipeline.load(\"./path/to/model\")\n\n    @hc.ehr(workflow=\"sign-note-inpatient\")\n    def load_data_in_client(self) -&gt; DocumentReference:\n        with open('/path/to/data.xml', \"r\") as file:\n            xml_string = file.read()\n\n        return create_document_reference(data=xml_string, content_type=\"text/xml\")\n\n    @hc.api\n    def my_service(self, request: CdaRequest) -&gt; CdaResponse:\n        response = self.pipeline(request)\n        return response\n</code></pre> <pre><code>import healthchain as hc\n\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.pipeline import SummarizationPipeline\nfrom healthchain.models import CDSRequest, CDSResponse, Prefetch\nfrom fhir.resources.patient import Patient\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDecisionSupport):\n    def __init__(self):\n        self.pipeline = SummarizationPipeline.load(\"model-name\")\n\n    @hc.ehr(workflow=\"patient-view\")\n    def load_data_in_client(self) -&gt; Prefetch:\n        with open('/path/to/data.json', \"r\") as file:\n            fhir_json = file.read()\n\n        return Prefetch(prefetch={\"patient\": Patient(**fhir_json)})\n\n    @hc.api\n    def my_service(self, request: CDSRequest) -&gt; CDSResponse:\n        response = self.pipeline(request)\n        return response\n</code></pre>"},{"location":"reference/sandbox/use_cases/cds/","title":"Use Cases","text":""},{"location":"reference/sandbox/use_cases/cds/#clinical-decision-support-cds","title":"Clinical Decision Support (CDS)","text":"<p>CDS workflows are based on CDS Hooks. CDS Hooks is an HL7 published specification for clinical decision support. CDS hooks communicate using FHIR (Fast Healthcare Interoperability Resources). For more information you can consult the official documentation.</p> When Where What you receive What you send back Triggered at certain events during a clinician's workflow, e.g. when a patient record is opened. EHR The context of the event and FHIR resources that are requested by your service. e.g. patient ID, <code>Encounter</code> and <code>Patient</code>. \u201cCards\u201d displaying text, actionable suggestions, or links to launch a SMART app from within the workflow."},{"location":"reference/sandbox/use_cases/cds/#data-flow","title":"Data Flow","text":"Stage Input Output Client N/A <code>Prefetch</code> Service <code>CDSRequest</code> <code>CDSResponse</code> <p>CdsFhirConnector handles the conversion of <code>CDSRequests</code> <code>Document</code> <code>CDSResponse</code> in a HealthChain pipeline.</p>"},{"location":"reference/sandbox/use_cases/cds/#supported-workflows","title":"Supported Workflows","text":"Workflow Name Description Trigger Maturity <code>patient-view</code> Triggered when a patient chart is opened Opening a patient's chart \u2705 <code>order-select</code> Triggered when a new order is selected Selecting a new order \u23f3 <code>order-sign</code> Triggered when orders are being signed Signing orders \u23f3 <code>encounter-discharge</code> Triggered when a patient is being discharged Discharging a patient \u2705"},{"location":"reference/sandbox/use_cases/cds/#generated-api-endpoints","title":"Generated API Endpoints","text":"Endpoint Method Function Name API Protocol <code>/cds-services</code> GET <code>cds_discovery</code> REST <code>/cds-services/{id}</code> POST <code>cds_service</code> REST"},{"location":"reference/sandbox/use_cases/cds/#what-does-the-data-look-like","title":"What does the data look like?","text":""},{"location":"reference/sandbox/use_cases/cds/#example-cdsrequest","title":"Example <code>CDSRequest</code>","text":"<pre><code>{\n   \"hookInstance\" : \"23f1a303-991f-4118-86c5-11d99a39222e\",\n   \"fhirServer\" : \"https://fhir.example.org\",\n   \"hook\" : \"patient-view\",\n   \"context\" : {\n     \"patientId\" : \"1288992\",\n     \"userId\" : \"Practitioner/example\"\n    },\n   \"prefetch\" : {\n      \"patientToGreet\" : {\n        \"resourceType\" : \"Patient\",\n        \"gender\" : \"male\",\n        \"birthDate\" : \"1925-12-23\",\n        \"id\" : \"1288992\",\n        \"active\" : true\n      }\n   }\n}\n</code></pre>"},{"location":"reference/sandbox/use_cases/cds/#example-cdsresponse","title":"Example <code>CDSResponse</code>","text":"<pre><code>{\n  \"summary\": \"Bilirubin: Based on the age of this patient consider overlaying bilirubin [Mass/volume] results over a time-based risk chart\",\n  \"indicator\": \"info\",\n  \"detail\": \"The focus of this app is to reduce the incidence of severe hyperbilirubinemia and bilirubin encephalopathy while minimizing the risks of unintended harm such as maternal anxiety, decreased breastfeeding, and unnecessary costs or treatment.\",\n  \"source\": {\n    \"label\": \"Intermountain\",\n    \"url\": null\n  },\n  \"links\": [\n    {\n      \"label\": \"Bilirubin SMART app\",\n      \"url\": \"https://example.com/launch\",\n      \"type\": \"smart\"\n   }\n  ]\n}\n</code></pre>"},{"location":"reference/sandbox/use_cases/cds/#implemented-fhir-resources","title":"Implemented FHIR Resources","text":"<ul> <li><code>Patient</code></li> <li><code>Encounter</code></li> <li><code>Procedure</code></li> <li><code>MedicationRequest</code></li> </ul>"},{"location":"reference/sandbox/use_cases/clindoc/","title":"Clinical Documentation","text":"<p>The <code>ClinicalDocumentation</code> use case implements a real-time Clinical Documentation Improvement (CDI) service. It currently implements the Epic-integrated NoteReader CDI specification, which communicates with a third-party NLP engine to analyse clinical notes and extract structured data. It helps convert free-text medical documentation into coded information that can be used for billing, quality reporting, continuity of care, and clinical decision support  (case study).</p> <p><code>ClinicalDocumentation</code> communicates using CDA (Clinical Document Architecture). CDAs are standardized electronic documents for exchanging clinical information. They provide a common structure for capturing and sharing patient data like medical history, medications, and care plans between different healthcare systems and providers. Think of it as a collaborative Google Doc that you can add, amend, and remove entries from.</p> When Where What you receive What you send back Triggered when a clinician opts in to a CDI functionality and signs or pends a note after writing it. Specific modules in EHR where clinical documentation takes place, such as NoteReader in Epic. A CDA document which contains continuity of care data and free-text data, e.g. a patient's problem list and the progress note that the clinician has entered in the EHR. A CDA document which contains additional structured data extracted and returned by your CDI service."},{"location":"reference/sandbox/use_cases/clindoc/#data-flow","title":"Data Flow","text":"Stage Input Output Client N/A <code>DocumentReference</code> Service <code>CdaRequest</code> <code>CdaResponse</code> <p>CdaConnector handles the conversion of <code>CdaRequests</code> <code>DocumentReference</code> <code>CdaResponse</code> in a HealthChain pipeline.</p>"},{"location":"reference/sandbox/use_cases/clindoc/#supported-workflows","title":"Supported Workflows","text":"Workflow Name Description Trigger Maturity <code>sign-note-inpatient</code> Triggered when a clinician opts in to a CDI functionality and signs or pends a note after writing it in an inpatient setting. Signing or pending a note in Epic \u2705 <code>sign-note-outpatient</code> Triggered when a clinician opts in to a CDI functionality and signs or pends a note after writing it in an outpatient setting. Signing or pending a note in Epic \u23f3 <p>We support parsing of problems, medications, and allergies sections, though some of the data fields may be limited. We plan to implement additional CDI services and workflows for different vendor specifications.</p>"},{"location":"reference/sandbox/use_cases/clindoc/#generated-api-endpoints","title":"Generated API Endpoints","text":"Endpoint Method Function API Protocol <code>/notereader/</code> POST <code>process_notereader_document</code> SOAP <p>Note that NoteReader is a vendor-specific component (Epic). This particular note-based workflow is one type of CDI service. Different EHR vendors will have different support for third-party CDI services.</p>"},{"location":"reference/sandbox/use_cases/clindoc/#what-does-the-data-look-like","title":"What does the data look like?","text":""},{"location":"reference/sandbox/use_cases/clindoc/#example-cda-request","title":"Example CDA Request","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n  &lt;typeId root=\"2.16.840.1.113883.1.3\" extension=\"POCD_HD000040\"/&gt;\n  &lt;templateId root=\"2.16.840.1.113883.10.20.22.1.2\"/&gt;\n  &lt;id root=\"2.16.840.1.113883.19.5.99999.1\"/&gt;\n  &lt;code code=\"34133-9\" displayName=\"Summarization of Episode Note\" codeSystem=\"2.16.840.1.113883.6.1\" codeSystemName=\"LOINC\"/&gt;\n  &lt;title&gt;CDA Document with Problem List and Progress Note&lt;/title&gt;\n  &lt;effectiveTime value=\"20240712\"/&gt;\n  &lt;confidentialityCode code=\"N\" codeSystem=\"2.16.840.1.113883.5.25\"/&gt;\n  &lt;languageCode code=\"en-US\"/&gt;\n\n  &lt;component&gt;\n    &lt;structuredBody&gt;\n      &lt;!-- Problem List Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.5.1\"/&gt;\n          &lt;code code=\"11450-4\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Problem List\"/&gt;\n          &lt;title&gt;Problems&lt;/title&gt;\n          &lt;text&gt;\n            &lt;list&gt;\n              &lt;item&gt;Hypertension&lt;/item&gt;\n            &lt;/list&gt;\n          &lt;/text&gt;\n          &lt;entry&gt;\n            &lt;act classCode=\"ACT\" moodCode=\"EVN\"&gt;\n              &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.3\"/&gt;\n              &lt;id root=\"ab1791b0-5c71-11db-b0de-0800200c9a66\"/&gt;\n              &lt;code code=\"CONC\" codeSystem=\"2.16.840.1.113883.5.6\"/&gt;\n              &lt;statusCode code=\"active\"/&gt;\n              &lt;effectiveTime&gt;\n                &lt;low value=\"20240712\"/&gt;\n              &lt;/effectiveTime&gt;\n              &lt;entryRelationship typeCode=\"SUBJ\"&gt;\n                &lt;observation classCode=\"OBS\" moodCode=\"EVN\"&gt;\n                  &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.4\"/&gt;\n                  &lt;id root=\"ab1791b0-5c71-11db-b0de-0800200c9a66\"/&gt;\n                  &lt;code code=\"55607006\" displayName=\"Problem\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"/&gt;\n                  &lt;text&gt;Hypertension&lt;/text&gt;\n                  &lt;statusCode code=\"completed\"/&gt;\n                  &lt;effectiveTime&gt;\n                    &lt;low value=\"20240712\"/&gt;\n                  &lt;/effectiveTime&gt;\n                  &lt;value xsi:type=\"CD\" code=\"59621000\" displayName=\"Essential hypertension\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"/&gt;\n                &lt;/observation&gt;\n              &lt;/entryRelationship&gt;\n            &lt;/act&gt;\n          &lt;/entry&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n\n      &lt;!-- Progress Note Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.65\"/&gt;\n          &lt;code code=\"11506-3\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Progress Note\"/&gt;\n          &lt;title&gt;Progress Note&lt;/title&gt;\n          &lt;text&gt;\n            &lt;paragraph&gt;Patient's blood pressure remains elevated. Discussed lifestyle modifications and medication adherence. Started Lisinopril 10 mg daily for hypertension management. Will follow up in 3 months to assess response to treatment.&lt;/paragraph&gt;\n          &lt;/text&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n    &lt;/structuredBody&gt;\n  &lt;/component&gt;\n&lt;/ClinicalDocument&gt;\n</code></pre>"},{"location":"reference/sandbox/use_cases/clindoc/#example-cda-response","title":"Example CDA Response","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n  &lt;typeId root=\"2.16.840.1.113883.1.3\" extension=\"POCD_HD000040\"/&gt;\n  &lt;templateId root=\"2.16.840.1.113883.10.20.22.1.2\"/&gt;\n  &lt;id root=\"2.16.840.1.113883.19.5.99999.1\"/&gt;\n  &lt;code code=\"34133-9\" displayName=\"Summarization of Episode Note\" codeSystem=\"2.16.840.1.113883.6.1\" codeSystemName=\"LOINC\"/&gt;\n  &lt;title&gt;CDA Document with Problem List, Medication, and Progress Note&lt;/title&gt;\n  &lt;effectiveTime value=\"20240712\"/&gt;\n  &lt;confidentialityCode code=\"N\" codeSystem=\"2.16.840.1.113883.5.25\"/&gt;\n  &lt;languageCode code=\"en-US\"/&gt;\n\n  &lt;component&gt;\n    &lt;structuredBody&gt;\n      &lt;!-- Problem List Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.5.1\"/&gt;\n          &lt;code code=\"11450-4\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Problem List\"/&gt;\n          &lt;title&gt;Problems&lt;/title&gt;\n          &lt;text&gt;\n            &lt;list&gt;\n              &lt;item&gt;Hypertension&lt;/item&gt;\n            &lt;/list&gt;\n          &lt;/text&gt;\n          &lt;entry&gt;\n            &lt;act classCode=\"ACT\" moodCode=\"EVN\"&gt;\n              &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.3\"/&gt;\n              &lt;id root=\"ab1791b0-5c71-11db-b0de-0800200c9a66\"/&gt;\n              &lt;code code=\"CONC\" codeSystem=\"2.16.840.1.113883.5.6\"/&gt;\n              &lt;statusCode code=\"active\"/&gt;\n              &lt;effectiveTime&gt;\n                &lt;low value=\"20240712\"/&gt;\n              &lt;/effectiveTime&gt;\n              &lt;entryRelationship typeCode=\"SUBJ\"&gt;\n                &lt;observation classCode=\"OBS\" moodCode=\"EVN\"&gt;\n                  &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.4\"/&gt;\n                  &lt;id root=\"ab1791b0-5c71-11db-b0de-0800200c9a66\"/&gt;\n                  &lt;code code=\"55607006\" displayName=\"Problem\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"/&gt;\n                  &lt;text&gt;Hypertension&lt;/text&gt;\n                  &lt;statusCode code=\"completed\"/&gt;\n                  &lt;effectiveTime&gt;\n                    &lt;low value=\"20240712\"/&gt;\n                  &lt;/effectiveTime&gt;\n                  &lt;value xsi:type=\"CD\" code=\"59621000\" displayName=\"Essential hypertension\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"/&gt;\n                &lt;/observation&gt;\n              &lt;/entryRelationship&gt;\n            &lt;/act&gt;\n          &lt;/entry&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n\n      &lt;!-- Medications Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.1.1\"/&gt;\n          &lt;code code=\"10160-0\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"History of medication use\"/&gt;\n          &lt;title&gt;Medications&lt;/title&gt;\n          &lt;text&gt;\n            &lt;list&gt;\n              &lt;item&gt;Lisinopril 10 mg oral tablet, once daily&lt;/item&gt;\n            &lt;/list&gt;\n          &lt;/text&gt;\n          &lt;entry&gt;\n            &lt;substanceAdministration classCode=\"SBADM\" moodCode=\"EVN\"&gt;\n              &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.16\"/&gt;\n              &lt;id root=\"cdbd33f0-6cde-11db-9fe1-0800200c9a66\"/&gt;\n              &lt;statusCode code=\"active\"/&gt;\n              &lt;effectiveTime xsi:type=\"IVL_TS\"&gt;\n                &lt;low value=\"20240712\"/&gt;\n              &lt;/effectiveTime&gt;\n              &lt;routeCode code=\"PO\" codeSystem=\"2.16.840.1.113883.5.112\" displayName=\"Oral\"/&gt;\n              &lt;doseQuantity value=\"1\"/&gt;\n              &lt;administrationUnitCode code=\"C48542\" displayName=\"Tablet\" codeSystem=\"2.16.840.1.113883.3.26.1.1\"/&gt;\n              &lt;consumable&gt;\n                &lt;manufacturedProduct classCode=\"MANU\"&gt;\n                  &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.23\"/&gt;\n                  &lt;manufacturedMaterial&gt;\n                    &lt;code code=\"197884\" codeSystem=\"2.16.840.1.113883.6.88\" displayName=\"Lisinopril 10 MG Oral Tablet\"&gt;\n                      &lt;originalText&gt;Lisinopril 10 mg oral tablet&lt;/originalText&gt;\n                    &lt;/code&gt;\n                  &lt;/manufacturedMaterial&gt;\n                &lt;/manufacturedProduct&gt;\n              &lt;/consumable&gt;\n              &lt;entryRelationship typeCode=\"SUBJ\"&gt;\n                &lt;observation classCode=\"OBS\" moodCode=\"EVN\"&gt;\n                  &lt;templateId root=\"2.16.840.1.113883.10.20.22.4.20\"/&gt;\n                  &lt;code code=\"33999-4\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Indication\"/&gt;\n                  &lt;value xsi:type=\"CD\" code=\"59621000\" displayName=\"Essential hypertension\" codeSystem=\"2.16.840.1.113883.6.96\"/&gt;\n                &lt;/observation&gt;\n              &lt;/entryRelationship&gt;\n            &lt;/substanceAdministration&gt;\n          &lt;/entry&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n\n      &lt;!-- Progress Note Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.65\"/&gt;\n          &lt;code code=\"11506-3\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Progress Note\"/&gt;\n          &lt;title&gt;Progress Note&lt;/title&gt;\n          &lt;text&gt;\n            &lt;paragraph&gt;Patient's blood pressure remains elevated. Discussed lifestyle modifications and medication adherence. Started Lisinopril 10 mg daily for hypertension management. Will follow up in 3 months to assess response to treatment.&lt;/paragraph&gt;\n          &lt;/text&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n    &lt;/structuredBody&gt;\n  &lt;/component&gt;\n&lt;/ClinicalDocument&gt;\n</code></pre>"},{"location":"reference/sandbox/use_cases/clindoc/#implemented-cda-sections","title":"Implemented CDA Sections","text":"<ul> <li>Problems</li> <li>Medications (including information on dosage, frequency, duration, route)</li> <li>Allergies (including information on severity, reaction and type of allergen)</li> <li>Progress Note (free-text)</li> </ul>"},{"location":"reference/sandbox/use_cases/use_cases/","title":"Use Cases","text":"<p>Use cases are the core building blocks of sandboxes. They define the API endpoints and the data formats for a given workflow.</p> <p>We currently support:</p> <ul> <li>Clinical Decision Support</li> <li>Clinical Documentation</li> </ul> <p>More documentation on the pros and cons of each use case will be added soon. For now, you can refer to the source code for more details.</p>"},{"location":"reference/utilities/cda_parser/","title":"CDA Parser","text":"<p>The <code>CdaAnnotator</code> class is responsible for parsing and annotating CDA (Clinical Document Architecture) documents. It extracts information about problems, medications, allergies, and notes from the CDA document into FHIR resources, and allows you to add new information to the CDA document.</p> <p>The CDA parser is used in the CDA Connector module, but can also be used independently.</p> <p>(CdaAnnotator API Reference)</p>"},{"location":"reference/utilities/cda_parser/#usage","title":"Usage","text":""},{"location":"reference/utilities/cda_parser/#parsing-cda-documents","title":"Parsing CDA documents","text":"<p>Parse a CDA document from an XML string:</p> <pre><code>from healthchain.cda_parser import CdaAnnotator\n\nwith open(\"tests/data/test_cda.xml\", \"r\") as f:\n    cda_xml_string = f.read()\n\ncda = CdaAnnotator.from_xml(cda_xml_string)\n\nconditions = cda.problem_list\nmedications = cda.medication_list\nallergies = cda.allergy_list\nnote = cda.note\n\nprint([condition.model_dump() for condition in conditions])\nprint([medication.model_dump() for medication in medications])\nprint([allergy.model_dump() for allergy in allergies])\nprint(note)\n</code></pre> <p>You can access data parsed from the CDA document in the <code>problem_list</code>, <code>medication_list</code>, <code>allergy_list</code>, and <code>note</code> attributes of the <code>CdaAnnotator</code> instance. They return a list of FHIR <code>Condition</code>, <code>MedicationStatement</code>, and <code>AllergyIntolerance</code> resources.</p>"},{"location":"reference/utilities/cda_parser/#adding-new-information-to-the-cda-document","title":"Adding new information to the CDA document","text":"<p>The methods currently available for adding new information to the CDA document are:</p> Method Description <code>.add_to_problem_list()</code> Adds a list of FHIR Condition resources <code>.add_to_medication_list()</code> Adds a list of FHIR MedicationStatement resources <code>.add_to_allergy_list()</code> Adds a list of FHIR AllergyIntolerance resources <p>The <code>overwrite</code> parameter in the <code>add_to_*_list()</code> methods is used to determine whether to overwrite the existing list or append to it. If <code>overwrite</code> is <code>True</code>, the existing list will be replaced with the new list. If <code>overwrite</code> is <code>False</code>, the new list will be appended to the existing list.</p> <p>Depending on the use case, you don't always need to return the original list of information in the CDA document you receive, although this is mostly useful if you are just developing and don't want the eye-strain of a lengthy CDA document.</p>"},{"location":"reference/utilities/cda_parser/#exporting-the-cda-document","title":"Exporting the CDA document","text":"<pre><code>xml_string = cda.export(pretty_print=True)\n</code></pre> <p>The <code>pretty_print</code> parameter is optional and defaults to <code>True</code>. If <code>pretty_print</code> is <code>True</code>, the XML string will be formatted with newlines and indentation.</p>"},{"location":"reference/utilities/cda_parser/#example","title":"Example","text":"<pre><code>from healthchain.cda_parser import CdaAnnotator\nfrom healthchain.fhir import (\n    create_condition,\n    create_medication_statement,\n    create_allergy_intolerance,\n)\n\nwith open(\"tests/data/test_cda.xml\", \"r\") as f:\n    cda_xml_string = f.read()\n\ncda = CdaAnnotator.from_xml(cda_xml_string)\n\nnew_problems = [\n    create_condition(subject=\"Patient/123\", code=\"123456\", display=\"New Problem\")\n]\nnew_medications = [\n    create_medication_statement(\n        subject=\"Patient/123\", code=\"789012\", display=\"New Medication\"\n    )\n]\nnew_allergies = [\n    create_allergy_intolerance(\n        patient=\"Patient/123\", code=\"345678\", display=\"New Allergy\"\n    )\n]\n\n# Add new problems, medications, and allergies\ncda.add_to_problem_list(new_problems, overwrite=True)\ncda.add_to_medication_list(new_medications, overwrite=True)\ncda.add_to_allergy_list(new_allergies, overwrite=True)\n\n# Export the modified CDA document\nmodified_cda_xml = cda.export()\n\nprint(modified_cda_xml)\n</code></pre> <p>The CDA parser is a work in progress. I'm just gonna be real with you, CDAs are the bane of my existence. If you, for some reason, love working with XML-based documents, please get in touch! We have plans to implement more functionality in the future, including allowing configurable templates, more CDA section methods, and using LLMs as a fallback parsing method.</p>"},{"location":"reference/utilities/data_generator/","title":"Data Generator","text":"<p>Healthcare data is interoperable, but not composable - every deployment site will have different ways of configuring data and terminology. This matters when you develop applications that need to integrate into these systems, especially when you need to reliably extract data for your model to consume.</p> <p>The aim of the data generator is not to generate realistic data suitable for use cases such as patient population studies, but rather to generate data that is structurally compliant with what is expected of EHR configurations, and to be able to test and handle variations in this.</p> <p>For this reason the data generator is opinionated by specific workflows and use cases.</p> <p>Note</p> <p>We're aware we may not cover everyone's use cases, so if you have strong opinions about this, please reach out!</p> <p>On the synthetic data spectrum defined by this UK ONS methodology working paper, HealthChain generates level 1: synthetic structural data.</p> <p></p>"},{"location":"reference/utilities/data_generator/#cds-data-generator","title":"CDS Data Generator","text":"<p>The <code>.generate_prefetch()</code> method will return a <code>Prefetch</code> model with the <code>prefetch</code> field populated with a dictionary of FHIR resources. Each key in the dictionary corresponds to a FHIR resource type, and the value is a list of FHIR resources of that type. For more information, check out the CDS Hooks documentation.</p> <p>For each workflow, a pre-configured list of FHIR resources is randomly generated and placed in the <code>prefetch</code> field of a <code>CDSRequest</code>.</p> <p>Current implemented workflows:</p> Workflow Implementation Completeness Generated Synthetic Resources patient-view <code>Patient</code>, <code>Encounter</code> (Future: <code>MedicationStatement</code>, <code>AllergyIntolerance</code>) encounter-discharge <code>Patient</code>, <code>Encounter</code>, <code>Procedure</code>, <code>MedicationRequest</code>, Optional <code>DocumentReference</code> order-sign  Partial Future: <code>MedicationRequest</code>, <code>ProcedureRequest</code>, <code>ServiceRequest</code> order-select  Partial Future: <code>MedicationRequest</code>, <code>ProcedureRequest</code>, <code>ServiceRequest</code> <p>For more information on CDS workflows, see the CDS Use Case documentation.</p> <p>You can use the data generator within a client function or on its own.</p> Within clientOn its own <pre><code>import healthchain as hc\nfrom healthchain.use_cases import ClinicalDecisionSupport\nfrom healthchain.models import Prefetch\nfrom healthchain.data_generators import CdsDataGenerator\n\n@hc.sandbox\nclass MyCoolSandbox(ClinicalDecisionSupport):\n    def __init__(self) -&gt; None:\n        self.data_generator = CdsDataGenerator()\n\n    @hc.ehr(workflow=\"patient-view\")\n    def load_data_in_client(self) -&gt; Prefetch:\n        prefetch = self.data_generator.generate_prefetch()\n        return prefetch\n\n    @hc.api\n    def my_server(self, request) -&gt; None:\n        pass\n</code></pre> <pre><code>from healthchain.data_generators import CdsDataGenerator\nfrom healthchain.workflows import Workflow\n\n# Initialize data generator\ndata_generator = CdsDataGenerator()\n\n# Generate FHIR resources for use case workflow\ndata_generator.set_workflow(Workflow.encounter_discharge)\nprefetch = data_generator.generate_prefetch()\n\nprint(prefetch.model_dump())\n\n# {\n#    \"prefetch\": {\n#        \"encounter\":\n#            {\n#              \"resourceType\": ...\n#            }\n#    }\n#}\n</code></pre>"},{"location":"reference/utilities/data_generator/#other-synthetic-data-sources","title":"Other synthetic data sources","text":"<p>If you are looking for realistic datasets, you are also free to load your own data in a sandbox run! Check out MIMIC for comprehensive continuity of care records and free-text data, or Synthea for synthetically generated FHIR resources. Both are open-source, although you will need to complete PhysioNet Credentialing to access MIMIC.</p>"},{"location":"reference/utilities/data_generator/#loading-free-text","title":"Loading free-text","text":"<p>You can specify the <code>free_text_csv</code> field of the <code>.generate_prefetch()</code> method to load in free-text sources into the data generator, e.g. discharge summaries. This will wrap the text into a FHIR DocumentReference resource (N.B. currently we place the text directly in the resource attachment, although it is technically supposed to be base64 encoded).</p> <p>A random text document from the <code>csv</code> file will be picked for each generation.</p> <pre><code># Load free text into a DocumentResource FHIR resource\ndata = data_generator.generate_prefetch(free_text_csv=\"./dir/to/csv/file\")\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/","title":"FHIR Utilities","text":"<p>The <code>fhir</code> module provides a set of helper functions to make it easier for you to work with FHIR resources.</p>"},{"location":"reference/utilities/fhir_helpers/#resource-creation","title":"Resource Creation","text":"<p>FHIR is the modern de facto standard for storing and exchanging healthcare data, but working with FHIR resources can often involve complex and nested JSON structures with required and optional fields that vary between contexts.</p> <p>Creating FHIR resources can involve a lot of boilerplate code, validation errors and manual comparison of FHIR specifications with the resource you're trying to create.</p> <p>For example, as an ML practitioner, you may only care about extracting and inserting certain codes and texts within a FHIR resource. If you want locate the SNOMED CT code for a medication, you may have to do something headache-inducing like this:</p> <pre><code>medication_statement = {\n    \"resourceType\": \"MedicationStatement\",\n    \"status\": \"active\",  # required\n    \"medication\": {  # required\n        \"concept\": {\n            \"coding\": [\n                {\n                    \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                    \"code\": \"1049221\",\n                    \"display\": \"Acetaminophen 325 MG Oral Tablet\",\n                }\n            ]\n        }\n    },\n    \"subject\": {  # required\n        \"reference\": \"Patient/example\"\n    },\n}\n\nmedication_statement[\"medication\"][\"concept\"][\"coding\"][0][\"code\"]\nmedication_statement[\"medication\"][\"concept\"][\"coding\"][0][\"display\"]\n</code></pre> <p>The <code>fhir</code> <code>create_*</code> functions create FHIR resources with sensible defaults, automatically creating a reference ID prefixed by \"<code>hc-</code>\", a status of \"<code>active</code>\" (or equivalent) and adding a creation date where necessary.</p> <p>Internally, HealthChain uses fhir.resources to validate FHIR resources, which is in turn powered by Pydantic V2. You can modify and manipulate the FHIR resources as you would any other Pydantic object after its creation.</p> <p>Please exercise caution when using these functions, as they are only meant to create minimal valid FHIR resources to make it easier to get started. Always check the sensible defaults serve your needs, and validate the resource to ensure it is correct!</p>"},{"location":"reference/utilities/fhir_helpers/#overview","title":"Overview","text":"Resource Type Required Fields Sensible Defaults Common Use Cases Condition \u2022 <code>clinicalStatus</code>\u2022 <code>subject</code> \u2022 <code>clinicalStatus</code>: \"active\"\u2022 <code>id</code>: auto-generated with \"hc-\" prefix \u2022 Recording diagnoses\u2022 Problem list items\u2022 Active conditions MedicationStatement \u2022 <code>subject</code>\u2022 <code>status</code>\u2022 <code>medication</code> \u2022 <code>status</code>: \"recorded\"\u2022 <code>id</code>: auto-generated with \"hc-\" prefix \u2022 Current medications\u2022 Medication history\u2022 Prescribed medications AllergyIntolerance \u2022 <code>patient</code> \u2022 <code>id</code>: auto-generated with \"hc-\" prefix \u2022 Allergies\u2022 Intolerances\u2022 Adverse reactions DocumentReference \u2022 <code>type</code> \u2022 <code>status</code>: \"current\"\u2022 <code>date</code>: current UTC time\u2022 <code>description</code>: default text\u2022 <code>content.attachment.title</code>: default text \u2022 Clinical notes\u2022 Lab reports\u2022 Imaging reports"},{"location":"reference/utilities/fhir_helpers/#create_condition","title":"create_condition()","text":"<p>Creates a new Condition resource.</p> <p>Required fields:</p> <ul> <li>clinicalStatus</li> <li>subject</li> </ul> <p>Sensible defaults:</p> <ul> <li><code>clinicalStatus</code> is set to \"<code>active</code>\"</li> </ul> <pre><code>from healthchain.fhir import create_condition\n\n# Create a condition representing hypertension\ncondition = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\",\n    system=\"http://snomed.info/sct\",\n)\n\n# Output the created resource\nprint(condition.model_dump())\n</code></pre> View output JSON <pre><code>{\n    \"resourceType\": \"Condition\",\n    \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n\n    // Clinical status indicating this is an active condition\n    \"clinicalStatus\": {\n        \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            \"code\": \"active\",\n            \"display\": \"Active\"\n        }]\n    },\n\n    // SNOMED CT code for Hypertension\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"38341003\",\n            \"display\": \"Hypertension\"\n        }]\n    },\n\n    // Reference to the patient this condition belongs to\n    \"subject\": {\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#create_medication_statement","title":"create_medication_statement()","text":"<p>Creates a new MedicationStatement resource.</p> <p>Required fields:</p> <ul> <li>subject</li> <li>status</li> <li>medication</li> </ul> <p>Sensible defaults:</p> <ul> <li><code>status</code> is set to \"<code>recorded</code>\"</li> </ul> <pre><code>from healthchain.fhir import create_medication_statement\n\n# Create a medication statement for Acetaminophen\nmedication = create_medication_statement(\n    subject=\"Patient/123\",\n    code=\"1049221\",\n    display=\"Acetaminophen 325 MG Oral Tablet\",\n    system=\"http://www.nlm.nih.gov/research/umls/rxnorm\",\n)\n\n# Output the created resource\nprint(medication.model_dump())\n</code></pre> View output JSON <pre><code>{\n    \"resourceType\": \"MedicationStatement\",\n    \"id\": \"hc-86a26eba-63f9-4017-b7b2-5b36f9bad5f1\",\n\n    // Required fields are highlighted\n    \"status\": \"recorded\",  // [Required] Status of the medication statement\n\n    // Required medication details using RxNorm coding\n    \"medication\": {  // [Required] Details about the medication\n        \"concept\": {\n            \"coding\": [{\n                \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                \"code\": \"1049221\",\n                \"display\": \"Acetaminophen 325 MG Oral Tablet\"\n            }]\n        }\n    },\n\n    // Required reference to the patient\n    \"subject\": {  // [Required] Reference to the patient this medication belongs to\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#create_allergy_intolerance","title":"create_allergy_intolerance()","text":"<p>Creates a new AllergyIntolerance resource.</p> <p>Required fields:</p> <ul> <li>patient</li> </ul> <p>Sensible defaults:</p> <ul> <li>None</li> </ul> <pre><code>from healthchain.fhir import create_allergy_intolerance\n\n# Create an allergy intolerance record\nallergy = create_allergy_intolerance(\n    patient=\"Patient/123\",\n    code=\"418038007\",\n    display=\"Propensity to adverse reactions to substance\",\n    system=\"http://snomed.info/sct\"\n)\n\n# Output the created resource\nprint(allergy.model_dump())\n</code></pre> View output JSON <pre><code>{\n    \"resourceType\": \"AllergyIntolerance\",\n    \"id\": \"hc-65edab39-d90b-477b-bdb5-a173b21efd44\",\n\n    // SNOMED CT code for the allergy\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"418038007\",\n            \"display\": \"Propensity to adverse reactions to substance\"\n        }]\n    },\n\n    // Required reference to the patient\n    \"patient\": {  // [Required] Reference to the patient this allergy belongs to\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#create_document_reference","title":"create_document_reference()","text":"<p>Creates a new DocumentReference resource. Handles base64 encoding of the attachment data.</p> <p>Required fields:</p> <ul> <li>type</li> </ul> <p>Sensible defaults:</p> <ul> <li><code>type</code> is set to \"<code>collection</code>\"</li> <li><code>status</code> is set to \"<code>current</code>\"</li> <li><code>date</code> is set to the current UTC timestamp</li> <li><code>description</code> is set to \"<code>DocumentReference created by HealthChain</code>\"</li> <li><code>content[0].attachment.title</code> is set to \"<code>Attachment created by HealthChain</code>\"</li> </ul> <pre><code>from healthchain.fhir import create_document_reference\n\n# Create a document reference with a simple text attachment\ndoc_ref = create_document_reference(\n    data=\"Hello World\",\n    content_type=\"text/plain\",\n    description=\"A simple text document\"\n)\n\n# Output the created resource\nprint(doc_ref.model_dump())\n</code></pre> View output JSON <pre><code>{\n    \"resourceType\": \"DocumentReference\",\n    \"id\": \"hc-60fcfdad-9617-4557-88d8-8c8db9b9fe70\",\n\n    // Document metadata\n    \"status\": \"current\",\n    \"date\": \"2025-02-28T14:55:33+00:00\",  // UTC timestamp\n    \"description\": \"A simple text document\",\n\n    // Document content with base64 encoded data\n    \"content\": [{\n        \"attachment\": {\n            \"contentType\": \"text/plain\",\n            \"data\": \"SGVsbG8gV29ybGQ=\",  // \"Hello World\" in base64\n            \"title\": \"Attachment created by HealthChain\",\n            \"creation\": \"2025-02-28T14:55:33+00:00\"  // UTC timestamp\n        }\n    }]\n}\n</code></pre> View decoded content <pre><code>Hello World\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#utilities","title":"Utilities","text":""},{"location":"reference/utilities/fhir_helpers/#set_problem_list_item_category","title":"set_problem_list_item_category()","text":"<p>Sets the category of a Condition resource to \"<code>problem-list-item</code>\".</p> <pre><code>from healthchain.fhir import set_problem_list_item_category, create_condition\n\n# Create a condition and set it as a problem list item\nproblem_list_item = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\"\n)\n\nset_problem_list_item_category(problem_list_item)\n\n# Output the modified resource\nprint(problem_list_item.model_dump())\n</code></pre> View output JSON <pre><code>{\n    \"resourceType\": \"Condition\",\n    \"id\": \"hc-3d5f62e7-729b-4da1-936c-e8e16e5a9358\",\n\n    // Required fields are highlighted\n    \"clinicalStatus\": {  // [Required] Clinical status of the condition\n        \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            \"code\": \"active\",\n            \"display\": \"Active\"\n        }]\n    },\n\n    // Category added by set_problem_list_item_category\n    \"category\": [{\n        \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-category\",\n            \"code\": \"problem-list-item\",\n            \"display\": \"Problem List Item\"\n        }]\n    }],\n\n    // SNOMED CT code for the condition\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"38341003\",\n            \"display\": \"Hypertension\"\n        }]\n    },\n\n    // Required reference to the patient\n    \"subject\": {  // [Required] Reference to the patient this condition belongs to\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#read_content_attachment","title":"read_content_attachment()","text":"<p>Reads attachments from a DocumentReference in a human-readable format.</p> <pre><code>from healthchain.fhir import read_content_attachment\n\nattachments = read_content_attachment(document_reference)\n# Returns a list of dictionaries containing:\n# [\n#     {\n#         \"data\": \"Hello World\",\n#         \"metadata\": {\n#             \"content_type\": \"text/plain\",\n#             \"title\": \"My Document\",\n#             \"creation\": datetime.datetime(2025, 2, 28, 15, 27, 55, tzinfo=TzInfo(UTC)),\n#         },\n#     }\n# ]\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#bundle-operations","title":"Bundle Operations","text":"<p>FHIR Bundles are containers that can hold multiple FHIR resources together. They are commonly used to group related resources or to send/receive multiple resources in a single request.</p> <p>The bundle operations make it easy to:</p> <ul> <li>Create and manage bundles</li> <li>Add or update resources within bundles</li> <li>Retrieve specific resource types from bundles</li> <li>Work with multiple resource types in a single bundle</li> </ul>"},{"location":"reference/utilities/fhir_helpers/#create_bundle","title":"create_bundle()","text":"<p>Creates a new Bundle resource.</p> <p>Required fields:</p> <ul> <li>type</li> </ul> <p>Sensible defaults:</p> <ul> <li><code>type</code> is set to \"<code>collection</code>\"</li> </ul> <pre><code>from healthchain.fhir import create_bundle\n\n# Create an empty bundle\nbundle = create_bundle(bundle_type=\"collection\")\n\n# Output the created resource\nprint(bundle.model_dump())\n</code></pre> View output JSON <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",  // [Required] Type of bundle\n    \"entry\": []           // Empty list of resources\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#add_resource","title":"add_resource()","text":"<p>Adds a single resource to a Bundle.</p> <pre><code>from healthchain.fhir import add_resource, create_condition, create_bundle\n\n# Create a condition to add to the bundle\ncondition = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\"\n)\n\n# Create a bundle and add the condition\nbundle = create_bundle()\nadd_resource(bundle, condition)\n\n# Output the modified bundle\nprint(bundle.model_dump())\n</code></pre> View output JSON <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n\n    // List of resources in the bundle\n    \"entry\": [{\n        \"resource\": {\n            \"resourceType\": \"Condition\",\n            \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n\n            // Required fields from the condition\n            \"clinicalStatus\": {  // [Required]\n                \"coding\": [{\n                    \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                    \"code\": \"active\",\n                    \"display\": \"Active\"\n                }]\n            },\n\n            \"code\": {\n                \"coding\": [{\n                    \"system\": \"http://snomed.info/sct\",\n                    \"code\": \"38341003\",\n                    \"display\": \"Hypertension\"\n                }]\n            },\n\n            \"subject\": {  // [Required]\n                \"reference\": \"Patient/123\"\n            }\n        }\n    }]\n}\n</code></pre> View field descriptions  | Field | Required | Description | |-------|:--------:|-------------| | `entry` | - | Array of resources in the bundle | | `entry[].resource` | \u2713 | The FHIR resource being added | | `entry[].fullUrl` | - | Optional full URL for the resource |"},{"location":"reference/utilities/fhir_helpers/#get_resources","title":"get_resources()","text":"<p>Retrieves all resources of a specific type from a Bundle.</p> <pre><code>from healthchain.fhir import get_resources\n\n# Get all conditions in the bundle\nconditions = get_resources(bundle, \"Condition\")\n\n# Or using the resource type directly\nfrom fhir.resources.condition import Condition\nconditions = get_resources(bundle, Condition)\n\n# Each resource in the returned list will be a full FHIR resource\nfor condition in conditions:\n    print(f\"Found condition: {condition.code.coding[0].display}\")\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#set_resources","title":"set_resources()","text":"<p>Sets or updates resources of a specific type in a Bundle.</p> <pre><code>from healthchain.fhir import set_resources, create_condition\n\n# Create some conditions\nconditions = [\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"38341003\",\n        display=\"Hypertension\"\n    ),\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"44054006\",\n        display=\"Diabetes\"\n    )\n]\n\n# Replace all existing conditions with new ones\nset_resources(bundle, conditions, \"Condition\", replace=True)\n\n# Or append new conditions to existing ones\nset_resources(bundle, conditions, \"Condition\", replace=False)\n</code></pre> View example bundle with multiple conditions <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": [\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"38341003\",\n                        \"display\": \"Hypertension\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-9876fedc-ba98-7654-3210-fedcba987654\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"44054006\",\n                        \"display\": \"Diabetes\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#common-patterns","title":"Common Patterns","text":""},{"location":"reference/utilities/fhir_helpers/#working-with-multiple-resource-types","title":"Working with Multiple Resource Types","text":"<p>This example shows how to work with multiple types of FHIR resources in a single bundle.</p> <pre><code>from healthchain.fhir import (\n    create_bundle,\n    create_condition,\n    create_medication_statement,\n    create_allergy_intolerance,\n    get_resources,\n    set_resources,\n)\n\n# Create a bundle to hold patient data\nbundle = create_bundle()\n\n# Add conditions (diagnoses)\nconditions = [\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"38341003\",\n        display=\"Hypertension\"\n    ),\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"44054006\",\n        display=\"Diabetes\"\n    )\n]\nset_resources(bundle, conditions, \"Condition\")\n\n# Add medications\nmedications = [\n    create_medication_statement(\n        subject=\"Patient/123\",\n        code=\"1049221\",\n        display=\"Acetaminophen 325 MG\"\n    )\n]\nset_resources(bundle, medications, \"MedicationStatement\")\n\n# Add allergies\nallergies = [\n    create_allergy_intolerance(\n        patient=\"Patient/123\",\n        code=\"418038007\",\n        display=\"Penicillin allergy\"\n    )\n]\nset_resources(bundle, allergies, \"AllergyIntolerance\")\n\n# Later, retrieve resources by type\nconditions = get_resources(bundle, \"Condition\")\nmedications = get_resources(bundle, \"MedicationStatement\")\nallergies = get_resources(bundle, \"AllergyIntolerance\")\n</code></pre> View complete bundle JSON <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": [\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"38341003\",\n                        \"display\": \"Hypertension\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-9876fedc-ba98-7654-3210-fedcba987654\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"44054006\",\n                        \"display\": \"Diabetes\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"MedicationStatement\",\n                \"id\": \"hc-86a26eba-63f9-4017-b7b2-5b36f9bad5f1\",\n                \"status\": \"recorded\",\n                \"medication\": {\n                    \"concept\": {\n                        \"coding\": [{\n                            \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                            \"code\": \"1049221\",\n                            \"display\": \"Acetaminophen 325 MG\"\n                        }]\n                    }\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"AllergyIntolerance\",\n                \"id\": \"hc-65edab39-d90b-477b-bdb5-a173b21efd44\",\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"418038007\",\n                        \"display\": \"Penicillin allergy\"\n                    }]\n                },\n                \"patient\": {\"reference\": \"Patient/123\"}\n            }\n        }\n    ]\n}\n</code></pre>"}]}